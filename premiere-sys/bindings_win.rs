/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const PF_TEMPORAL_LEVEL_1: u32 = 1;
pub const PF_TEMPORAL_LEVEL_2: u32 = 2;
pub const PF_TEMPORAL_LEVEL_3: u32 = 3;
pub const PF_NON_TEMPORAL_LEVEL_ALL: u32 = 0;
pub const PF_FLOATING_POINT_PRECISION_ERRATA: u32 = 0;
pub const PF_FLOATING_POINT_EMULATED: u32 = 1;
pub const PF_COMPARE_EXCHANGE_DOUBLE: u32 = 2;
pub const PF_MMX_INSTRUCTIONS_AVAILABLE: u32 = 3;
pub const PF_PPC_MOVEMEM_64BIT_OK: u32 = 4;
pub const PF_ALPHA_BYTE_INSTRUCTIONS: u32 = 5;
pub const PF_XMMI_INSTRUCTIONS_AVAILABLE: u32 = 6;
pub const PF_3DNOW_INSTRUCTIONS_AVAILABLE: u32 = 7;
pub const PF_RDTSC_INSTRUCTION_AVAILABLE: u32 = 8;
pub const PF_PAE_ENABLED: u32 = 9;
pub const PF_XMMI64_INSTRUCTIONS_AVAILABLE: u32 = 10;
pub const PF_SSE_DAZ_MODE_AVAILABLE: u32 = 11;
pub const PF_NX_ENABLED: u32 = 12;
pub const PF_SSE3_INSTRUCTIONS_AVAILABLE: u32 = 13;
pub const PF_COMPARE_EXCHANGE128: u32 = 14;
pub const PF_COMPARE64_EXCHANGE128: u32 = 15;
pub const PF_CHANNELS_ENABLED: u32 = 16;
pub const PF_XSAVE_ENABLED: u32 = 17;
pub const PF_ARM_VFP_32_REGISTERS_AVAILABLE: u32 = 18;
pub const PF_ARM_NEON_INSTRUCTIONS_AVAILABLE: u32 = 19;
pub const PF_SECOND_LEVEL_ADDRESS_TRANSLATION: u32 = 20;
pub const PF_VIRT_FIRMWARE_ENABLED: u32 = 21;
pub const PF_RDWRFSGSBASE_AVAILABLE: u32 = 22;
pub const PF_FASTFAIL_AVAILABLE: u32 = 23;
pub const PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE: u32 = 24;
pub const PF_ARM_64BIT_LOADSTORE_ATOMIC: u32 = 25;
pub const PF_ARM_EXTERNAL_CACHE_AVAILABLE: u32 = 26;
pub const PF_ARM_FMAC_INSTRUCTIONS_AVAILABLE: u32 = 27;
pub const PF_RDRAND_INSTRUCTION_AVAILABLE: u32 = 28;
pub const PF_ARM_V8_INSTRUCTIONS_AVAILABLE: u32 = 29;
pub const PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE: u32 = 30;
pub const PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE: u32 = 31;
pub const PF_RDTSCP_INSTRUCTION_AVAILABLE: u32 = 32;
pub const PF_RDPID_INSTRUCTION_AVAILABLE: u32 = 33;
pub const PF_ARM_V81_ATOMIC_INSTRUCTIONS_AVAILABLE: u32 = 34;
pub const PF_MONITORX_INSTRUCTION_AVAILABLE: u32 = 35;
pub const PF_SSSE3_INSTRUCTIONS_AVAILABLE: u32 = 36;
pub const PF_SSE4_1_INSTRUCTIONS_AVAILABLE: u32 = 37;
pub const PF_SSE4_2_INSTRUCTIONS_AVAILABLE: u32 = 38;
pub const PF_AVX_INSTRUCTIONS_AVAILABLE: u32 = 39;
pub const PF_AVX2_INSTRUCTIONS_AVAILABLE: u32 = 40;
pub const PF_AVX512F_INSTRUCTIONS_AVAILABLE: u32 = 41;
pub const PF_ERMS_AVAILABLE: u32 = 42;
pub const PF_ARM_V82_DP_INSTRUCTIONS_AVAILABLE: u32 = 43;
pub const PF_ARM_V83_JSCVT_INSTRUCTIONS_AVAILABLE: u32 = 44;
pub const PF_ARM_V83_LRCPC_INSTRUCTIONS_AVAILABLE: u32 = 45;
pub const PR_JOBSTATUS: u32 = 0;
pub const PFD_TYPE_RGBA: u32 = 0;
pub const PFD_TYPE_COLORINDEX: u32 = 1;
pub const PFD_MAIN_PLANE: u32 = 0;
pub const PFD_OVERLAY_PLANE: u32 = 1;
pub const PFD_UNDERLAY_PLANE: i32 = -1;
pub const PFD_DOUBLEBUFFER: u32 = 1;
pub const PFD_STEREO: u32 = 2;
pub const PFD_DRAW_TO_WINDOW: u32 = 4;
pub const PFD_DRAW_TO_BITMAP: u32 = 8;
pub const PFD_SUPPORT_GDI: u32 = 16;
pub const PFD_SUPPORT_OPENGL: u32 = 32;
pub const PFD_GENERIC_FORMAT: u32 = 64;
pub const PFD_NEED_PALETTE: u32 = 128;
pub const PFD_NEED_SYSTEM_PALETTE: u32 = 256;
pub const PFD_SWAP_EXCHANGE: u32 = 512;
pub const PFD_SWAP_COPY: u32 = 1024;
pub const PFD_SWAP_LAYER_BUFFERS: u32 = 2048;
pub const PFD_GENERIC_ACCELERATED: u32 = 4096;
pub const PFD_SUPPORT_DIRECTDRAW: u32 = 8192;
pub const PFD_DIRECT3D_ACCELERATED: u32 = 16384;
pub const PFD_SUPPORT_COMPOSITION: u32 = 32768;
pub const PFD_DEPTH_DONTCARE: u32 = 536870912;
pub const PFD_DOUBLEBUFFER_DONTCARE: u32 = 1073741824;
pub const PFD_STEREO_DONTCARE: u32 = 2147483648;
pub const PF_UNSPEC: u32 = 0;
pub const PF_UNIX: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_IMPLINK: u32 = 3;
pub const PF_PUP: u32 = 4;
pub const PF_CHAOS: u32 = 5;
pub const PF_NS: u32 = 6;
pub const PF_IPX: u32 = 6;
pub const PF_ISO: u32 = 7;
pub const PF_OSI: u32 = 7;
pub const PF_ECMA: u32 = 8;
pub const PF_DATAKIT: u32 = 9;
pub const PF_CCITT: u32 = 10;
pub const PF_SNA: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_DLI: u32 = 13;
pub const PF_LAT: u32 = 14;
pub const PF_HYLINK: u32 = 15;
pub const PF_APPLETALK: u32 = 16;
pub const PF_VOICEVIEW: u32 = 18;
pub const PF_FIREFOX: u32 = 19;
pub const PF_UNKNOWN1: u32 = 20;
pub const PF_BAN: u32 = 21;
pub const PF_MAX: u32 = 22;
pub const kPrMaxPath: u32 = 260;
pub const kPrMaxName: u32 = 260;
pub const kPrForceEnumToIntValue: u32 = 4294967295;
pub const kPrSDKTimeSuite: &[u8; 20] = b"Premiere Time Suite\0";
pub const kPrSDKTimeSuiteVersion: u32 = 1;
pub const kPrSDKClipRenderSuite: &[u8; 27] = b"Premiere Clip Render Suite\0";
pub const kPrSDKClipRenderSuiteVersion: u32 = 3;
pub const kSPNoError: u32 = 0;
pub const kSPOutOfMemoryError: u32 = 4294967148;
pub const kSPBasicSuite: &[u8; 15] = b"SP Basic Suite\0";
pub const kSPBasicSuiteVersion: u32 = 4;
pub const PR_PISUITES_VERSION_1: u32 = 1;
pub const PR_PISUITES_VERSION_2: u32 = 2;
pub const PR_PISUITES_VERSION_3: u32 = 3;
pub const PR_PISUITES_VERSION_4: u32 = 4;
pub const PR_PISUITES_VERSION_5: u32 = 5;
pub const PR_PISUITES_VERSION_6: u32 = 6;
pub const PR_PISUITES_VERSION_7: u32 = 7;
pub const PR_PISUITES_VERSION_8: u32 = 8;
pub const PR_PISUITES_VERSION_9: u32 = 9;
pub const PR_PISUITES_VERSION: u32 = 9;
pub const kVideoFilterVersion: u32 = 12;
pub const kPrSDKErrorSuite: &[u8; 21] = b"Premiere Error Suite\0";
pub const kPrSDKErrorSuiteVersion1: u32 = 1;
pub const kPrSDKErrorSuiteVersion2: u32 = 2;
pub const kPrSDKErrorSuiteVersion3: u32 = 3;
pub const kPrSDKErrorSuiteVersion: u32 = 3;
pub const kPrSDKGPUDeviceSuite: &[u8; 27] = b"MediaCore GPU Device Suite\0";
pub const kPrSDKGPUDeviceSuiteVersion: u32 = 2;
pub const PrCUDAVersion: u32 = 10010;
pub const PrOpenCLVersion: u32 = 1000;
pub const kPrSDKAudioSuite: &[u8; 21] = b"Premiere Audio Suite\0";
pub const kPrSDKAudioSuiteVersion: u32 = 1;
pub const kMaxAudioChannelCount: u32 = 32;
pub const kPrSDKPlayModuleDeviceControlSuite: &[u8; 38] =
    b"Premiere Playmod Device Control Suite\0";
pub const kPrSDKPlayModuleDeviceControlSuiteVersion: u32 = 1;
pub const kPrSDKEndOfTimeline: u64 = 91445760000000000;
pub const PrSDKGPUFilterInterfaceVersion1: u32 = 1;
pub const PrSDKGPUFilterInterfaceVersion2: u32 = 2;
pub const PrSDKGPUFilterInterfaceVersion: u32 = 2;
pub const PrGPUFilterEntryPointName: &[u8; 16] = b"xGPUFilterEntry\0";
pub const kPrSDKGPUImageProcessingSuite: &[u8; 37] = b"MediaCore GPU Image Processing Suite\0";
pub const kPrSDKGPUImageProcessingSuiteVersion: u32 = 1;
pub const kPrSDKMemoryManagerSuite: &[u8; 30] = b"Premiere Memory Manager Suite\0";
pub const kPrSDKMemoryManagerSuiteVersion1: u32 = 1;
pub const kPrSDKMemoryManagerSuiteVersion2: u32 = 2;
pub const kPrSDKMemoryManagerSuiteVersion3: u32 = 3;
pub const kPrSDKMemoryManagerSuiteVersion4: u32 = 4;
pub const kPrSDKMemoryManagerSuiteVersion: u32 = 4;
pub const kPrSDKPixelFormatSuite: &[u8; 28] = b"Premiere Pixel Format Suite\0";
pub const kPrSDKPixelFormatSuiteVersion: u32 = 1;
pub const kPrSDKPPixSuite: &[u8; 20] = b"Premiere PPix Suite\0";
pub const kPrSDKPPixSuiteVersion: u32 = 1;
pub const kPrSDKPPix2Suite: &[u8; 22] = b"Premiere PPix 2 Suite\0";
pub const kPrSDKPPix2SuiteVersion1: u32 = 1;
pub const kPrSDKPPix2SuiteVersion2: u32 = 2;
pub const kPrSDKPPix2SuiteVersion3: u32 = 3;
pub const kPrSDKPPix2SuiteVersion: u32 = 3;
pub const kPrSRGBColorSpace: &[u8; 5] = b"sRGB\0";
pub const kPrRec601525ColorSpace: &[u8; 14] = b"BT.601 (NTSC)\0";
pub const kPrRec601625ColorSpace: &[u8; 13] = b"BT.601 (PAL)\0";
pub const kPrRec709: &[u8; 7] = b"BT.709\0";
pub const kPrRec709Scene: &[u8; 15] = b"BT.709 (Scene)\0";
pub const kPrRec709RGB: &[u8; 11] = b"BT.709 RGB\0";
pub const kPrRec709RGBScene: &[u8; 19] = b"BT.709 RGB (Scene)\0";
pub const kPrOverranged709: &[u8; 16] = b"BT.709 RGB Full\0";
pub const kPrOverranged709Scene: &[u8; 24] = b"BT.709 RGB Full (Scene)\0";
pub const kPrOverranged709Display: &[u8; 26] = b"BT.709 RGB Full (Display)\0";
pub const kPrRec2020: &[u8; 8] = b"BT.2020\0";
pub const kPrRec2020Scene: &[u8; 16] = b"BT.2020 (Scene)\0";
pub const kPrRec2020RGB: &[u8; 12] = b"BT.2020 RGB\0";
pub const kPrRec2020RGBScene: &[u8; 20] = b"BT.2020 RGB (Scene)\0";
pub const kPrOverranged2020: &[u8; 17] = b"BT.2020 RGB Full\0";
pub const kPrOverranged2020Scene: &[u8; 25] = b"BT.2020 RGB Full (Scene)\0";
pub const kPrOverranged2020Display: &[u8; 27] = b"BT.2020 RGB Full (Display)\0";
pub const kPrRec2100HLG: &[u8; 12] = b"BT.2100 HLG\0";
pub const kPrRec2100HLGScene: &[u8; 20] = b"BT.2100 HLG (Scene)\0";
pub const kPrRec2100HLGRGB: &[u8; 16] = b"BT.2100 HLG RGB\0";
pub const kPrRec2100HLGRGBScene: &[u8; 24] = b"BT.2100 HLG RGB (Scene)\0";
pub const kPrOverranged2100HLG: &[u8; 21] = b"BT.2100 HLG RGB Full\0";
pub const kPrOverranged2100HLGScene: &[u8; 29] = b"BT.2100 HLG RGB Full (Scene)\0";
pub const kPrOverranged2100HLGDisplay: &[u8; 31] = b"BT.2100 HLG RGB Full (Display)\0";
pub const kPrRec2100PQ: &[u8; 11] = b"BT.2100 PQ\0";
pub const kPrRec2100PQScene: &[u8; 19] = b"BT.2100 PQ (Scene)\0";
pub const kPrRec2100PQRGB: &[u8; 15] = b"BT.2100 PQ RGB\0";
pub const kPrRec2100PQRGBScene: &[u8; 23] = b"BT.2100 PQ RGB (Scene)\0";
pub const kPrOverranged2100PQ: &[u8; 20] = b"BT.2100 PQ RGB Full\0";
pub const kPrOverranged2100PQScene: &[u8; 28] = b"BT.2100 PQ RGB Full (Scene)\0";
pub const kPrOverranged2100PQDisplay: &[u8; 30] = b"BT.2100 PQ RGB Full (Display)\0";
pub const kPrDCDMXYZ: &[u8; 12] = b"DCDM X'Y'Z'\0";
pub const kPrSonySGamutSLog2: &[u8; 18] = b"Sony SGamut/SLog2\0";
pub const kPrSony2020SLog3: &[u8; 14] = b"BT.2020/SLog3\0";
pub const kPrSonySGamut3CineSLog3: &[u8; 24] = b"Sony SGamut3.Cine/SLog3\0";
pub const kPrSonySGamut3SLog3: &[u8; 19] = b"Sony SGamut3/SLog3\0";
pub const kPrWorkingColorSpace: &[u8; 20] = b"Working Color Space\0";
pub const kPrSDKPPixCacheSuite: &[u8; 26] = b"Premiere PPix Cache Suite\0";
pub const kPrSDKPPixCacheSuiteVersion1: u32 = 1;
pub const kPrSDKPPixCacheSuiteVersion2: u32 = 2;
pub const kPrSDKPPixCacheSuiteVersion3: u32 = 3;
pub const kPrSDKPPixCacheSuiteVersion4: u32 = 4;
pub const kPrSDKPPixCacheSuiteVersion5: u32 = 5;
pub const kPrSDKPPixCacheSuiteVersion6: u32 = 6;
pub const kPrSDKPPixCacheSuiteVersion7: u32 = 7;
pub const kPrSDKPPixCacheSuiteVersion8: u32 = 8;
pub const kPrSDKPPixCacheSuiteVersion: u32 = 8;
pub const kPrSDKPPixCreator2Suite: &[u8; 30] = b"Premiere PPix Creator 2 Suite\0";
pub const kPrSDKPPixCreator2SuiteVersion1: u32 = 1;
pub const kPrSDKPPixCreator2SuiteVersion2: u32 = 2;
pub const kPrSDKPPixCreator2SuiteVersion3: u32 = 3;
pub const kPrSDKPPixCreator2SuiteVersion4: u32 = 4;
pub const kPrSDKPPixCreator2SuiteVersion: u32 = 4;
pub const kPrSDKPPixCreatorSuite: &[u8; 28] = b"Premiere PPix Creator Suite\0";
pub const kPrSDKPPixCreatorSuiteVersion: u32 = 1;
pub const kPrSDKSequenceInfoSuite: &[u8; 30] = b"MediaCore Sequence Info Suite\0";
pub const kPrSDKSequenceInfoSuiteVersion: u32 = 6;
pub const kPrSDK_StreamLabel_Stereoscopic_Left: &[u8; 23] = b"ADBE.Stereoscopic.Left\0";
pub const kPrSDK_StreamLabel_Stereoscopic_Right: &[u8; 24] = b"ADBE.Stereoscopic.Right\0";
pub const kPrSDKSequenceRenderSuite: &[u8; 32] = b"MediaCore Sequence Render Suite\0";
pub const kPrSDKSequenceRenderSuiteVersion1: u32 = 1;
pub const kPrSDKSequenceRenderSuiteVersion2: u32 = 2;
pub const kPrSDKSequenceRenderSuiteVersion3: u32 = 3;
pub const kPrSDKSequenceRenderSuiteVersion4: u32 = 4;
pub const kPrSDKSequenceRenderSuiteVersion5: u32 = 5;
pub const kPrSDKSequenceRenderSuiteVersion6: u32 = 6;
pub const kPrSDKSequenceRenderSuiteVersion: u32 = 6;
pub const kPrSDKSmartRenderingSuite: &[u8; 32] = b"MediaCore Smart Rendering Suite\0";
pub const kPrSDKSmartRenderingSuiteVersion1: u32 = 1;
pub const kPrSDKSmartRenderingSuiteVersion2: u32 = 2;
pub const kPrSDKSmartRenderingSuiteVersion3: u32 = 3;
pub const kPrSDKSmartRenderingSuiteVersion: u32 = 3;
pub const kPrSDKStringSuite: &[u8; 22] = b"MediaCore StringSuite\0";
pub const kPrSDKStringSuiteVersion: u32 = 1;
pub const kPrSDKThreadedWorkSuite: &[u8; 29] = b"Premiere Threaded Work Suite\0";
pub const kPrSDKThreadedWorkSuiteVersion2: u32 = 2;
pub const kPrSDKThreadedWorkSuiteVersion3: u32 = 3;
pub const kVideoSegmentProperty_Media_ClipID: &[u8; 18] = b"MediaNode::ClipID\0";
pub const kVideoSegmentProperty_Media_ProxyClipID: &[u8; 23] = b"MediaNode::ProxyClipID\0";
pub const kVideoSegmentProperty_Media_InstanceString: &[u8; 31] =
    b"MediaNode::MediaInstanceString\0";
pub const kVideoSegmentProperty_Media_ProxyInstanceString: &[u8; 36] =
    b"MediaNode::ProxyMediaInstanceString\0";
pub const kVideoSegmentProperty_Media_ImplementationID: &[u8; 28] =
    b"MediaNode::ImplementationID\0";
pub const kVideoSegmentProperty_Media_StreamGroup: &[u8; 28] = b"MediaNode::MediaStreamGroup\0";
pub const kVideoSegmentProperty_Media_StreamLabel: &[u8; 28] = b"MediaNode::MediaStreamLabel\0";
pub const kVideoSegmentProperty_Media_IsDraft: &[u8; 24] = b"MediaNode::MediaIsDraft\0";
pub const kVideoSegmentProperty_Media_ModState: &[u8; 25] = b"MediaNode::MediaModState\0";
pub const kVideoSegmentProperty_Media_IsOffline: &[u8; 26] = b"MediaNode::MediaIsOffline\0";
pub const kVideoSegmentProperty_Media_IsPending: &[u8; 26] = b"MediaNode::MediaIsPending\0";
pub const kVideoSegmentProperty_Media_CaptioningID: &[u8; 29] = b"MediaNode::MediaCaptioningID\0";
pub const kVideoSegmentProperty_Media_StreamFrameRate: &[u8; 27] = b"MediaNode::StreamFrameRate\0";
pub const kVideoSegmentProperty_Media_StreamAlphaType: &[u8; 27] = b"MediaNode::StreamAlphaType\0";
pub const kVideoSegmentProperty_Media_StreamIgnoreAlpha: &[u8; 29] =
    b"MediaNode::StreamIgnoreAlpha\0";
pub const kVideoSegmentProperty_Media_StreamInvertAlpha: &[u8; 29] =
    b"MediaNode::StreamInvertAlpha\0";
pub const kVideoSegmentProperty_Media_StreamAlphaMatteColor: &[u8; 33] =
    b"MediaNode::StreamAlphaMatteColor\0";
pub const kVideoSegmentProperty_Media_StreamRemovePulldown: &[u8; 32] =
    b"MediaNode::StreamRemovePulldown\0";
pub const kVideoSegmentProperty_Media_StreamPixelAspectRatioNum: &[u8; 37] =
    b"MediaNode::StreamPixelAspectRatioNum\0";
pub const kVideoSegmentProperty_Media_StreamFrameWidth: &[u8; 28] =
    b"MediaNode::StreamFrameWidth\0";
pub const kVideoSegmentProperty_Media_StreamFrameHeight: &[u8; 29] =
    b"MediaNode::StreamFrameHeight\0";
pub const kVideoSegmentProperty_Media_StreamPixelAspectRatioDen: &[u8; 37] =
    b"MediaNode::StreamPixelAspectRatioDen\0";
pub const kVideoSegmentProperty_Media_StreamFieldType: &[u8; 27] = b"MediaNode::StreamFieldType\0";
pub const kVideoSegmentProperty_Media_StreamOpaqueData: &[u8; 28] =
    b"MediaNode::StreamOpaqueData\0";
pub const kVideoSegmentProperty_Media_ProxyStreamOpaqueData: &[u8; 33] =
    b"MediaNode::ProxyStreamOpaqueData\0";
pub const kVideoSegmentProperty_Media_StreamPullDownCadence: &[u8; 33] =
    b"MediaNode::StreamPullDownCadence\0";
pub const kVideoSegmentProperty_Media_StreamFrameVidSubType: &[u8; 33] =
    b"MediaNode::StreamFrameVidSubType\0";
pub const kVideoSegmentProperty_Media_StreamIsContinuousTime: &[u8; 62] =
    b"MediaNode::kVideoSegmentProperty_Media_StreamIsContinuousTime\0";
pub const kVideoSegmentProperty_Media_StreamIsRollCrawl: &[u8; 29] =
    b"MediaNode::StreamIsRollCrawl\0";
pub const kVideoSegmentProperty_Media_RollCrawlDuration: &[u8; 29] =
    b"MediaNode::RollCrawlDuration\0";
pub const kVideoSegmentProperty_Media_ContentStart: &[u8; 24] = b"MediaNode::ContentStart\0";
pub const kVideoSegmentProperty_Media_ContentEnd: &[u8; 22] = b"MediaNode::ContentEnd\0";
pub const kVideoSegmentProperty_Media_StartTimecodeOffset: &[u8; 31] =
    b"MediaNode::StartTimecodeOffset\0";
pub const kVideoSegmentProperty_Media_ProxyStartTimecodeOffset: &[u8; 36] =
    b"MediaNode::ProxyStartTimecodeOffset\0";
pub const kVideoSegmentProperty_Media_NestedSequenceHash: &[u8; 30] =
    b"MediaNode::NestedSequenceHash\0";
pub const kVideoSegmentProperty_Media_SelectedMulticamTrackFromNestedSequence: &[u8; 33] =
    b"MediaNode::SelectedMulticamTrack\0";
pub const kVideoSegmentProperty_Media_MulticamCameraOrderFromNestedSequence: &[u8; 31] =
    b"MediaNode::MulticamCameraOrder\0";
pub const kVideoSegmentProperty_Media_MulticamCamerasPerPage: &[u8; 34] =
    b"MediaNode::MulticamCamerasPerPage\0";
pub const kVideoSegmentProperty_Media_MulticamCurrentPage: &[u8; 31] =
    b"MediaNode::MulticamCurrentPage\0";
pub const kVideoSegmentProperty_Media_SelectedMulticamTrackTimelineID: &[u8; 43] =
    b"MediaNode::SelectedMulticamTrackTimelineID\0";
pub const kVideoSegmentProperty_Media_NestedSequenceTimelineID: &[u8; 36] =
    b"MediaNode::NestedSequenceTimelineID\0";
pub const kVideoSegmentProperty_Media_TrackItemIsMuted: &[u8; 28] =
    b"MediaNode::TrackItemIsMuted\0";
pub const kVideoSegmentProperty_Media_ClipSpeed: &[u8; 21] = b"MediaNode::ClipSpeed\0";
pub const kVideoSegmentProperty_Media_ClipBackwards: &[u8; 25] = b"MediaNode::ClipBackwards\0";
pub const kVideoSegmentProperty_Media_StreamFrameBlend: &[u8; 28] =
    b"MediaNode::StreamFrameBlend\0";
pub const kVideoSegmentProperty_Media_StreamTimeInterpolationType: &[u8; 39] =
    b"MediaNode::StreamTimeInterpolationType\0";
pub const kVideoSegmentProperty_Media_ClipScaleToFrameSize: &[u8; 32] =
    b"MediaNode::ClipScaleToFrameSize\0";
pub const kVideoSegmentProperty_Media_ClipScaleToFramePolicy: &[u8; 34] =
    b"MediaNode::ClipScaleToFramePolicy\0";
pub const kVideoSegmentProperty_Media_StreamReverseFieldDominance: &[u8; 39] =
    b"MediaNode::StreamReverseFieldDominance\0";
pub const kVideoSegmentProperty_Media_DeinterlaceAlways: &[u8; 29] =
    b"MediaNode::DeinterlaceAlways\0";
pub const kVideoSegmentProperty_Media_RemoveFlicker: &[u8; 25] = b"MediaNode::RemoveFlicker\0";
pub const kVideoSegmentProperty_Media_InterlaceConsecutiveFrames: &[u8; 38] =
    b"MediaNode::InterlaceConsecutiveFrames\0";
pub const kVideoSegmentProperty_Media_SequenceColorSpace: &[u8; 30] =
    b"MediaNode::SequenceColorSpace\0";
pub const kVideoSegmentProperty_Media_StreamColorSpace: &[u8; 28] =
    b"MediaNode::StreamColorSpace\0";
pub const kVideoSegmentProperty_Media_StreamInputLUTID: &[u8; 28] =
    b"MediaNode::StreamInputLUTID\0";
pub const kVideoSegmentProperty_Media_ScanlineOffsetToImproveVerticalCentering: &[u8; 52] =
    b"MediaNode::ScanlineOffsetToImproveVerticalCentering\0";
pub const kVideoSegmentProperty_Media_InPointMediaTimeAsTicks: &[u8; 35] =
    b"MediaNode::InPointMediaTimeAsTicks\0";
pub const kVideoSegmentProperty_Media_OutPointMediaTimeAsTicks: &[u8; 36] =
    b"MediaNode::OutPointMediaTimeAsTicks\0";
pub const kVideoSegmentProperty_Media_SequenceFieldType: &[u8; 29] =
    b"MediaNode::SequenceFieldType\0";
pub const kVideoSegmentProperty_Media_SequenceFrameRate: &[u8; 29] =
    b"MediaNode::SequenceFrameRate\0";
pub const kVideoSegmentProperty_Media_SequenceWidth: &[u8; 25] = b"MediaNode::SequenceWidth\0";
pub const kVideoSegmentProperty_Media_SequenceHeight: &[u8; 26] = b"MediaNode::SequenceHeight\0";
pub const kVideoSegmentProperty_Media_SequencePixelAspectRatioNum: &[u8; 39] =
    b"MediaNode::SequencePixelAspectRatioNum\0";
pub const kVideoSegmentProperty_Media_SequencePixelAspectRatioDen: &[u8; 39] =
    b"MediaNode::SequencePixelAspectRatioDen\0";
pub const kVideoSegmentProperty_Media_OrientationType: &[u8; 27] = b"MediaNode::OrientationType\0";
pub const kVideoSegmentProperty_Media_OrientationTypeProxy: &[u8; 32] =
    b"MediaNode::OrientationTypeProxy\0";
pub const kVideoSegmentProperty_Clip_ClipSpeed: &[u8; 20] = b"ClipNode::ClipSpeed\0";
pub const kVideoSegmentProperty_Clip_ClipBackwards: &[u8; 24] = b"ClipNode::ClipBackwards\0";
pub const kVideoSegmentProperty_Clip_TimeRemapping: &[u8; 24] = b"ClipNode::TimeRemapping\0";
pub const kVideoSegmentProperty_Clip_FrameHoldAtTime: &[u8; 26] = b"ClipNode::FrameHoldAtTime\0";
pub const kVideoSegmentProperty_Clip_FrameHoldFilters: &[u8; 27] = b"ClipNode::FrameHoldFilters\0";
pub const kVideoSegmentProperty_Clip_GrowingDuration: &[u8; 26] = b"ClipNode::GrowingDuration\0";
pub const kVideoSegmentProperty_Clip_FrameHoldDeinterlace: &[u8; 31] =
    b"ClipNode::FrameHoldDeinterlace\0";
pub const kVideoSegmentProperty_Clip_TrackID: &[u8; 18] = b"ClipNode::TrackID\0";
pub const kVideoSegmentProperty_Clip_TrackItemStartAsTicks: &[u8; 32] =
    b"ClipNode::TrackItemStartAsTicks\0";
pub const kVideoSegmentProperty_Clip_TrackItemEndAsTicks: &[u8; 30] =
    b"ClipNode::TrackItemEndAsTicks\0";
pub const kVideoSegmentProperty_Clip_EffectiveTrackItemStartAsTicks: &[u8; 41] =
    b"ClipNode::EffectiveTrackItemStartAsTicks\0";
pub const kVideoSegmentProperty_Clip_EffectiveTrackItemEndAsTicks: &[u8; 39] =
    b"ClipNode::EffectiveTrackItemEndAsTicks\0";
pub const kVideoSegmentProperty_Clip_AllowLinearCompositing: &[u8; 33] =
    b"ClipNode::AllowLinearCompositing\0";
pub const kVideoSegmentProperty_Clip_HasCaptions: &[u8; 22] = b"ClipNode::HasCaptions\0";
pub const kVideoSegmentProperty_Clip_UntrimmedDuration: &[u8; 28] =
    b"ClipNode::UntrimmedDuration\0";
pub const kVideoSegmentProperty_Multicam_SelectedTrack: &[u8; 28] =
    b"MulticamNode::SelectedTrack\0";
pub const kVideoSegmentProperty_Multicam_CameraOrder: &[u8; 26] = b"MulticamNode::CameraOrder\0";
pub const kVideoSegmentProperty_Multicam_CamerasPerPage: &[u8; 29] =
    b"MulticamNode::CamerasPerPage\0";
pub const kVideoSegmentProperty_Multicam_CurrentPage: &[u8; 26] = b"MulticamNode::CurrentPage\0";
pub const kVideoSegmentProperty_Multicam_ShowProgram: &[u8; 26] = b"MulticamNode::ShowProgram\0";
pub const kVideoSegmentProperty_Multicam_Recording: &[u8; 24] = b"MulticamNode::Recording\0";
pub const kVideoSegmentProperty_Multicam_IsNonMultiCam: &[u8; 28] =
    b"MulticamNode::IsNonMultiCam\0";
pub const kVideoSegmentProperty_Multicam_UseTimeRemapping: &[u8; 31] =
    b"MulticamNode::UseTimeRemapping\0";
pub const kVideoSegmentProperty_SolidColor_Color: &[u8; 22] = b"SolidColorNode::Color\0";
pub const kVideoSegmentProperty_Effect_FilterMatchName: &[u8; 28] =
    b"EffectNode::FilterMatchName\0";
pub const kVideoSegmentProperty_Effect_FilterOpaqueData: &[u8; 29] =
    b"EffectNode::FilterOpaqueData\0";
pub const kVideoSegmentProperty_Effect_FilterParams: &[u8; 25] = b"EffectNode::FilterParams\0";
pub const kVideoSegmentProperty_Effect_EffectDuration: &[u8; 27] = b"EffectNode::EffectDuration\0";
pub const kVideoSegmentProperty_Effect_RuntimeInstanceID: &[u8; 30] =
    b"EffectNode::RuntimeInstanceID\0";
pub const kVideoSegmentProperty_Effect_LayerInputHashes: &[u8; 29] =
    b"EffectNode::LayerInputHashes\0";
pub const kVideoSegmentProperty_Effect_StreamLabel: &[u8; 24] = b"EffectNode::StreamLabel\0";
pub const kVideoSegmentProperty_Effect_ClipName: &[u8; 21] = b"EffectNode::ClipName\0";
pub const kVideoSegmentProperty_Effect_MasterClipName: &[u8; 27] = b"EffectNode::MasterClipName\0";
pub const kVideoSegmentProperty_Effect_FileName: &[u8; 21] = b"EffectNode::FileName\0";
pub const kVideoSegmentProperty_Effect_SourceTrackClipNameHashes: &[u8; 38] =
    b"EffectNode::SourceTrackClipNameHashes\0";
pub const kVideoSegmentProperty_Transition_TransitionMatchName: &[u8; 36] =
    b"TransitionNode::TransitionMatchName\0";
pub const kVideoSegmentProperty_Transition_TransitionOpaqueData: &[u8; 37] =
    b"TransitionNode::TransitionOpaqueData\0";
pub const kVideoSegmentProperty_Transition_TransitionStartPosition: &[u8; 40] =
    b"TransitionNode::TransitionStartPosition\0";
pub const kVideoSegmentProperty_Transition_TransitionEndPosition: &[u8; 38] =
    b"TransitionNode::TransitionEndPosition\0";
pub const kVideoSegmentProperty_Transition_TransitionCenterPosition: &[u8; 41] =
    b"TransitionNode::TransitionCenterPosition\0";
pub const kVideoSegmentProperty_Transition_TransitionStartPercent: &[u8; 39] =
    b"TransitionNode::TransitionStartPercent\0";
pub const kVideoSegmentProperty_Transition_TransitionEndPercent: &[u8; 37] =
    b"TransitionNode::TransitionEndPercent\0";
pub const kVideoSegmentProperty_Transition_TransitionBorderWidth: &[u8; 38] =
    b"TransitionNode::TransitionBorderWidth\0";
pub const kVideoSegmentProperty_Transition_TransitionBorderColor: &[u8; 38] =
    b"TransitionNode::TransitionBorderColor\0";
pub const kVideoSegmentProperty_Transition_TransitionSwitchSources: &[u8; 40] =
    b"TransitionNode::TransitionSwitchSources\0";
pub const kVideoSegmentProperty_Transition_TransitionReverse: &[u8; 34] =
    b"TransitionNode::TransitionReverse\0";
pub const kVideoSegmentProperty_Transition_TransitionDirection: &[u8; 36] =
    b"TransitionNode::TransitionDirection\0";
pub const kVideoSegmentProperty_Transition_TransitionAntiAliasQuality: &[u8; 43] =
    b"TransitionNode::TransitionAntiAliasQuality\0";
pub const kVideoSegmentProperty_Transition_TransitionDuration: &[u8; 35] =
    b"TransitionNode::TransitionDuration\0";
pub const kVideoSegmentProperty_Transition_TransitionParams: &[u8; 33] =
    b"TransitionNode::TransitionParams\0";
pub const kVideoSegmentProperty_Transition_RuntimeInstanceID: &[u8; 34] =
    b"TransitionNode::RuntimeInstanceID\0";
pub const kVideoSegmentProperty_Adjustment_AdjustmentMediaIsOpaque: &[u8; 40] =
    b"AdjustmentNode::AdjustmentMediaIsOpaque\0";
pub const kVideoSegmentProperty_Adjustment_InvertAlpha: &[u8; 28] =
    b"AdjustmentNode::InvertAlpha\0";
pub const kPrSDKVideoSegmentSuite: &[u8; 30] = b"MediaCore Video Segment Suite\0";
pub const kPrSDKVideoSegmentSuiteVersion4: u32 = 4;
pub const kPrSDKVideoSegmentSuiteVersion5: u32 = 5;
pub const kPrSDKVideoSegmentSuiteVersion6: u32 = 6;
pub const kPrSDKVideoSegmentSuiteVersion7: u32 = 7;
pub const kPrSDKVideoSegmentSuiteVersion8: u32 = 8;
pub const kPrSDKVideoSegmentSuiteVersion9: u32 = 9;
pub const kPrSDKVideoSegmentSuiteVersion: u32 = 9;
pub const kVideoSegment_NodeType_Clip: &[u8; 23] = b"RenderableNodeClipImpl\0";
pub const kVideoSegment_NodeType_Compositor: &[u8; 29] = b"RenderableNodeCompositorImpl\0";
pub const kVideoSegment_NodeType_Disabled: &[u8; 27] = b"RenderableNodeDisabledImpl\0";
pub const kVideoSegment_NodeType_Effect: &[u8; 25] = b"RenderableNodeEffectImpl\0";
pub const kVideoSegment_NodeType_Transition: &[u8; 29] = b"RenderableNodeTransitionImpl\0";
pub const kVideoSegment_NodeType_Media: &[u8; 24] = b"RenderableNodeMediaImpl\0";
pub const kVideoSegment_NodeType_Preview: &[u8; 26] = b"RenderableNodePreviewImpl\0";
pub const kVideoSegment_NodeType_SolidColor: &[u8; 29] = b"RenderableNodeSolidColorImpl\0";
pub const kVideoSegment_NodeType_Multicam: &[u8; 27] = b"RenderableNodeMulticamImpl\0";
pub const kVideoSegment_NodeType_Adjustment: &[u8; 30] = b"RenderableNode_AdjustmentImpl\0";
pub const kVideoSegment_NodeType_AdjustmentEffect: &[u8; 36] =
    b"RenderableNode_AdjustmentEffectImpl\0";
pub const kPrSDKWindowSuite: &[u8; 22] = b"Premiere Window Suite\0";
pub const kPrSDKWindowSuiteVersion: u32 = 1;
pub const PF_Vers_BUILD_BITS: u32 = 511;
pub const PF_Vers_BUILD_SHIFT: u32 = 0;
pub const PF_Vers_STAGE_BITS: u32 = 3;
pub const PF_Vers_STAGE_SHIFT: u32 = 9;
pub const PF_Vers_BUGFIX_BITS: u32 = 15;
pub const PF_Vers_BUGFIX_SHIFT: u32 = 11;
pub const PF_Vers_SUBVERS_BITS: u32 = 15;
pub const PF_Vers_SUBVERS_SHIFT: u32 = 15;
pub const PF_Vers_VERS_BITS: u32 = 7;
pub const PF_Vers_VERS_SHIFT: u32 = 19;
pub const PF_Vers_VERS_HIGH_BITS: u32 = 15;
pub const PF_Vers_VERS_HIGH_SHIFT: u32 = 26;
pub const PF_Vers_VERS_LOW_SHIFT: u32 = 3;
pub const PF_AE234_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE234_PLUG_IN_SUBVERS: u32 = 28;
pub const PF_AE220_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE220_PLUG_IN_SUBVERS: u32 = 27;
pub const PF_AE184_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE184_PLUG_IN_SUBVERS: u32 = 26;
pub const PF_AE182_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE182_PLUG_IN_SUBVERS: u32 = 25;
pub const PF_AE180_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE180_PLUG_IN_SUBVERS: u32 = 24;
pub const PF_AE177_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE177_PLUG_IN_SUBVERS: u32 = 23;
pub const PF_AE176_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE176_PLUG_IN_SUBVERS: u32 = 22;
pub const PF_AE175_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE175_PLUG_IN_SUBVERS: u32 = 21;
pub const PF_AE171_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE171_PLUG_IN_SUBVERS: u32 = 20;
pub const PF_AE170_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE170_PLUG_IN_SUBVERS: u32 = 18;
pub const PF_AE161_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE161_PLUG_IN_SUBVERS: u32 = 17;
pub const PF_AE160_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE160_PLUG_IN_SUBVERS: u32 = 16;
pub const PF_AE151_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE151_PLUG_IN_SUBVERS: u32 = 15;
pub const PF_AE150_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE150_PLUG_IN_SUBVERS: u32 = 15;
pub const PF_AE142_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE142_PLUG_IN_SUBVERS: u32 = 14;
pub const PF_AE140_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE140_PLUG_IN_SUBVERS: u32 = 13;
pub const PF_AE138_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE138_PLUG_IN_SUBVERS: u32 = 11;
pub const PF_AE136_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE136_PLUG_IN_SUBVERS: u32 = 10;
pub const PF_AE135_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE135_PLUG_IN_SUBVERS: u32 = 9;
pub const PF_AE130_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE130_PLUG_IN_SUBVERS: u32 = 7;
pub const PF_AE122_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE122_PLUG_IN_SUBVERS: u32 = 6;
pub const PF_AE121_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE121_PLUG_IN_SUBVERS: u32 = 5;
pub const PF_AE120_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE120_PLUG_IN_SUBVERS: u32 = 4;
pub const PF_AE1101_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE1101_PLUG_IN_SUBVERS: u32 = 3;
pub const PF_AE110_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE110_PLUG_IN_SUBVERS: u32 = 2;
pub const PF_AE105_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE105_PLUG_IN_SUBVERS: u32 = 1;
pub const PF_AE100_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE100_PLUG_IN_SUBVERS: u32 = 0;
pub const PF_AE90_PLUG_IN_VERSION: u32 = 12;
pub const PF_AE90_PLUG_IN_SUBVERS: u32 = 14;
pub const PF_AE80_PLUG_IN_VERSION: u32 = 12;
pub const PF_AE80_PLUG_IN_SUBVERS: u32 = 13;
pub const PF_AE70_PLUG_IN_VERSION: u32 = 12;
pub const PF_AE70_PLUG_IN_SUBVERS: u32 = 12;
pub const PF_AE65_PLUG_IN_VERSION: u32 = 12;
pub const PF_AE65_PLUG_IN_SUBVERS: u32 = 11;
pub const PF_AE41_PLUG_IN_VERSION: u32 = 12;
pub const PF_AE41_PLUG_IN_SUBVERS: u32 = 2;
pub const PF_AE40_PLUG_IN_VERSION: u32 = 12;
pub const PF_AE40_PLUG_IN_SUBVERS: u32 = 1;
pub const PF_AE31_PLUG_IN_VERSION: u32 = 11;
pub const PF_AE31_PLUG_IN_SUBVERS: u32 = 6;
pub const PF_AE31_PLUG_IN_SUBVERS_STRICTIFY: u32 = 8;
pub const PF_AE_PLUG_IN_VERSION: u32 = 13;
pub const PF_AE_PLUG_IN_SUBVERS: u32 = 28;
pub const PF_MAX_EFFECT_NAME_LEN: u32 = 31;
pub const PF_MAX_EFFECT_CATEGORY_NAME_LEN: u32 = 31;
pub const PF_MAX_EFFECT_PARAM_NAME_LEN: u32 = 31;
pub const PF_MAX_PARAM_DESCRIPTION_LEN: u32 = 31;
pub const PF_MAX_PARAM_VALUE_LEN: u32 = 31;
pub const PF_MAX_EFFECT_MSG_LEN: u32 = 255;
pub const PF_AE65_AND_EARLIER_MAX_NUM_EFFECT_PARAMS: u32 = 127;
pub const PF_MAX_WORLD_WIDTH: u32 = 30000;
pub const PF_MAX_WORLD_HEIGHT: u32 = 30000;
pub const PF_FIRST_ERR: u32 = 512;
pub const PF_Category_BLUR_AND_SHARPEN: &[u8; 15] = b"Blur & Sharpen\0";
pub const PF_Category_CHANNEL: &[u8; 8] = b"Channel\0";
pub const PF_Category_DISTORT: &[u8; 8] = b"Distort\0";
pub const PF_Category_IMAGE_CONTROL: &[u8; 14] = b"Image Control\0";
pub const PF_Category_KEYING: &[u8; 7] = b"Keying\0";
pub const PF_Category_PERSPECTIVE: &[u8; 12] = b"Perspective\0";
pub const PF_Category_STYLIZE: &[u8; 8] = b"Stylize\0";
pub const PF_Category_TEXT: &[u8; 5] = b"Text\0";
pub const PF_Category_VIDEO: &[u8; 6] = b"Video\0";
pub const PF_Category_TRANSITION: &[u8; 11] = b"Transition\0";
pub const PF_Category_AUDIO: &[u8; 6] = b"Audio\0";
pub const PF_Category_OTHER: &[u8; 6] = b"Other\0";
pub const PF_MAX_CHAN8: u32 = 255;
pub const PF_HALF_CHAN8: u32 = 128;
pub const PF_MAX_CHAN16: u32 = 32768;
pub const PF_HALF_CHAN16: u32 = 16384;
pub const PF_HUE_UNDEFINED: u32 = 2147483648;
pub const PF_CHANNEL_NAME_LEN: u32 = 63;
pub const PF_PI: f64 = 3.141592653589793;
pub const PF_2PI: f64 = 6.283185307179586;
pub const PF_HALF_PI: f64 = 1.5707963267948966;
pub const PF_E: f64 = 2.718281828459045;
pub const PF_SQRT2: f64 = 1.4142135623730951;
pub const PF_RAD_PER_DEGREE: f64 = 0.017453292519943295;
pub const PF_KernelFlag_2D: u32 = 0;
pub const PF_KernelFlag_1D: u32 = 1;
pub const PF_KernelFlag_UNNORMALIZED: u32 = 0;
pub const PF_KernelFlag_NORMALIZED: u32 = 2;
pub const PF_KernelFlag_CLAMP: u32 = 0;
pub const PF_KernelFlag_NO_CLAMP: u32 = 4;
pub const PF_KernelFlag_USE_LONG: u32 = 0;
pub const PF_KernelFlag_USE_CHAR: u32 = 8;
pub const PF_KernelFlag_USE_FIXED: u32 = 16;
pub const PF_KernelFlag_USE_UNDEFINED: u32 = 24;
pub const PF_KernelFlag_HORIZONTAL: u32 = 0;
pub const PF_KernelFlag_VERTICAL: u32 = 32;
pub const PF_KernelFlag_TRANSPARENT_BORDERS: u32 = 0;
pub const PF_KernelFlag_REPLICATE_BORDERS: u32 = 64;
pub const PF_KernelFlag_STRAIGHT_CONVOLVE: u32 = 0;
pub const PF_KernelFlag_ALPHA_WEIGHT_CONVOLVE: u32 = 128;
pub const PF_Iterations_ONCE_PER_PROCESSOR: i32 = -1;
pub const PF_Iteratations_ONCE_PER_PROCESSOR: i32 = -1;
pub const kPFCacheOnLoadSuite: &[u8; 23] = b"PF Cache On Load Suite\0";
pub const kPFCacheOnLoadSuiteVersion1: u32 = 1;
pub const kPFPixelFormatSuite: &[u8; 22] = b"PF Pixel Format Suite\0";
pub const kPFPixelFormatSuiteVersion1: u32 = 1;
pub const kPFBackgroundFrameSuite: &[u8; 26] = b"PF Background Frame Suite\0";
pub const kPFBackgroundFrameSuiteVersion1: u32 = 1;
pub const kPFUtilitySuite: &[u8; 17] = b"PF Utility Suite\0";
pub const kPFUtilitySuiteVersion2: u32 = 2;
pub const kPFUtilitySuiteVersion3: u32 = 3;
pub const kPFUtilitySuiteVersion4: u32 = 4;
pub const kPFUtilitySuiteVersion5: u32 = 5;
pub const kPFUtilitySuiteVersion6: u32 = 6;
pub const kPFUtilitySuiteVersion7: u32 = 7;
pub const kPFUtilitySuiteVersion8: u32 = 8;
pub const kPFUtilitySuiteVersion9: u32 = 9;
pub const kPFUtilitySuiteVersion10: u32 = 10;
pub const kPFUtilitySuiteVersion11: u32 = 11;
pub const kPFUtilitySuiteVersion: u32 = 11;
pub const kPFSourceSettingsSuite: &[u8; 25] = b"PF Source Settings Suite\0";
pub const kPFSourceSettingsSuiteVersion1: u32 = 1;
pub const kPFSourceSettingsSuiteVersion2: u32 = 2;
pub const kPFSourceSettingsSuiteVersion: u32 = 2;
pub const kPFTransitionSuite: &[u8; 20] = b"PF Transition Suite\0";
pub const kPFTransitionSuiteVersion1: u32 = 1;
pub const kPFTransitionSuiteVersion2: u32 = 2;
pub const kPFTransitionSuiteVersion: u32 = 2;
pub const kPrSDKOpaqueEffectDataSuite: &[u8; 25] = b"Opaque Effect Data Suite\0";
pub const kPrSDKOpaqueEffectDataSuiteVersion2: u32 = 2;
pub const kPrSDKOpaqueEffectDataSuiteVersion: u32 = 2;
pub type ULONG = ::std::os::raw::c_ulong;
pub type PULONG = *mut ULONG;
pub type USHORT = ::std::os::raw::c_ushort;
pub type UCHAR = ::std::os::raw::c_uchar;
pub type DWORD = ::std::os::raw::c_ulong;
pub type BOOL = ::std::os::raw::c_int;
pub type BYTE = ::std::os::raw::c_uchar;
pub type WORD = ::std::os::raw::c_ushort;
pub type FLOAT = f32;
pub type PFLOAT = *mut FLOAT;
pub type LPBOOL = *mut BOOL;
pub type PBYTE = *mut BYTE;
pub type PDWORD = *mut DWORD;
pub type LPVOID = *mut ::std::os::raw::c_void;
pub type INT = ::std::os::raw::c_int;
pub type UINT = ::std::os::raw::c_uint;
pub type INT_PTR = ::std::os::raw::c_longlong;
pub type UINT_PTR = ::std::os::raw::c_ulonglong;
pub type LONG_PTR = ::std::os::raw::c_longlong;
pub type ULONG_PTR = ::std::os::raw::c_ulonglong;
pub type SIZE_T = ULONG_PTR;
pub type DWORD_PTR = ULONG_PTR;
pub type PVOID = *mut ::std::os::raw::c_void;
pub type CHAR = ::std::os::raw::c_char;
pub type SHORT = ::std::os::raw::c_short;
pub type LONG = ::std::os::raw::c_long;
pub type WCHAR = u16;
pub type LPWSTR = *mut WCHAR;
pub type PWSTR = *mut WCHAR;
pub type LPCWSTR = *const WCHAR;
pub type PCWSTR = *const WCHAR;
pub type LPSTR = *mut CHAR;
pub type LPCSTR = *const CHAR;
pub type HANDLE = *mut ::std::os::raw::c_void;
pub type HRESULT = ::std::os::raw::c_long;
pub type CCHAR = ::std::os::raw::c_char;
pub type LCID = DWORD;
pub type LANGID = WORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLOAT128 {
    pub LowPart: ::std::os::raw::c_longlong,
    pub HighPart: ::std::os::raw::c_longlong,
}
pub type FLOAT128 = _FLOAT128;
pub type PFLOAT128 = *mut FLOAT128;
pub type LONGLONG = ::std::os::raw::c_longlong;
pub type ULONGLONG = ::std::os::raw::c_ulonglong;
pub type USN = LONGLONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
    pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
    pub u: _LARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
pub type LARGE_INTEGER = _LARGE_INTEGER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ULARGE_INTEGER {
    pub __bindgen_anon_1: _ULARGE_INTEGER__bindgen_ty_1,
    pub u: _ULARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: DWORD,
    pub HighPart: DWORD,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: DWORD,
    pub HighPart: DWORD,
}
pub type ULARGE_INTEGER = _ULARGE_INTEGER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
pub type LUID = _LUID;
pub type DWORDLONG = ULONGLONG;
pub type BOOLEAN = BYTE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUID {
    pub Data1: ::std::os::raw::c_ulong,
    pub Data2: ::std::os::raw::c_ushort,
    pub Data3: ::std::os::raw::c_ushort,
    pub Data4: [::std::os::raw::c_uchar; 8usize],
}
pub type GUID = _GUID;
pub type IID = GUID;
pub type CLSID = GUID;
pub type FMTID = GUID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID_AND_ATTRIBUTES {
    pub Luid: LUID,
    pub Attributes: DWORD,
}
pub type LUID_AND_ATTRIBUTES = _LUID_AND_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_IDENTIFIER_AUTHORITY {
    pub Value: [BYTE; 6usize],
}
pub type SID_IDENTIFIER_AUTHORITY = _SID_IDENTIFIER_AUTHORITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID {
    pub Revision: BYTE,
    pub SubAuthorityCount: BYTE,
    pub IdentifierAuthority: SID_IDENTIFIER_AUTHORITY,
    pub SubAuthority: [DWORD; 1usize],
}
pub type SID = _SID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRIVILEGE_SET {
    pub PrivilegeCount: DWORD,
    pub Control: DWORD,
    pub Privilege: [LUID_AND_ATTRIBUTES; 1usize],
}
pub type PPRIVILEGE_SET = *mut _PRIVILEGE_SET;
pub const _FIRMWARE_TYPE_FirmwareTypeUnknown: _FIRMWARE_TYPE = 0;
pub const _FIRMWARE_TYPE_FirmwareTypeBios: _FIRMWARE_TYPE = 1;
pub const _FIRMWARE_TYPE_FirmwareTypeUefi: _FIRMWARE_TYPE = 2;
pub const _FIRMWARE_TYPE_FirmwareTypeMax: _FIRMWARE_TYPE = 3;
pub type _FIRMWARE_TYPE = ::std::os::raw::c_int;
pub type PFIRMWARE_TYPE = *mut _FIRMWARE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ID_128 {
    pub Identifier: [BYTE; 16usize],
}
pub type FILE_ID_128 = _FILE_ID_128;
pub type PFILE_ID_128 = *mut _FILE_ID_128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_NOTIFY_INFORMATION {
    pub NextEntryOffset: DWORD,
    pub Action: DWORD,
    pub FileNameLength: DWORD,
    pub FileName: [WCHAR; 1usize],
}
pub type PFILE_NOTIFY_INFORMATION = *mut _FILE_NOTIFY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NOTIFY_EXTENDED_INFORMATION {
    pub NextEntryOffset: DWORD,
    pub Action: DWORD,
    pub CreationTime: LARGE_INTEGER,
    pub LastModificationTime: LARGE_INTEGER,
    pub LastChangeTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub AllocatedLength: LARGE_INTEGER,
    pub FileSize: LARGE_INTEGER,
    pub FileAttributes: DWORD,
    pub __bindgen_anon_1: _FILE_NOTIFY_EXTENDED_INFORMATION__bindgen_ty_1,
    pub FileId: LARGE_INTEGER,
    pub ParentFileId: LARGE_INTEGER,
    pub FileNameLength: DWORD,
    pub FileName: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_NOTIFY_EXTENDED_INFORMATION__bindgen_ty_1 {
    pub ReparsePointTag: DWORD,
    pub EaSize: DWORD,
}
pub type PFILE_NOTIFY_EXTENDED_INFORMATION = *mut _FILE_NOTIFY_EXTENDED_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NOTIFY_FULL_INFORMATION {
    pub NextEntryOffset: DWORD,
    pub Action: DWORD,
    pub CreationTime: LARGE_INTEGER,
    pub LastModificationTime: LARGE_INTEGER,
    pub LastChangeTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub AllocatedLength: LARGE_INTEGER,
    pub FileSize: LARGE_INTEGER,
    pub FileAttributes: DWORD,
    pub __bindgen_anon_1: _FILE_NOTIFY_FULL_INFORMATION__bindgen_ty_1,
    pub FileId: LARGE_INTEGER,
    pub ParentFileId: LARGE_INTEGER,
    pub FileNameLength: WORD,
    pub FileNameFlags: BYTE,
    pub Reserved: BYTE,
    pub FileName: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_NOTIFY_FULL_INFORMATION__bindgen_ty_1 {
    pub ReparsePointTag: DWORD,
    pub EaSize: DWORD,
}
pub type PFILE_NOTIFY_FULL_INFORMATION = *mut _FILE_NOTIFY_FULL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_SEGMENT_ELEMENT {
    pub Buffer: *mut ::std::os::raw::c_void,
    pub Alignment: ULONGLONG,
}
pub type PFILE_SEGMENT_ELEMENT = *mut _FILE_SEGMENT_ELEMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FPO_DATA {
    pub ulOffStart: DWORD,
    pub cbProcSize: DWORD,
    pub cdwLocals: DWORD,
    pub cdwParams: WORD,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl _FPO_DATA {
    #[inline]
    pub fn cbProlog(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_cbProlog(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn cbRegs(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_cbRegs(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn fHasSEH(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fHasSEH(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fUseBP(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fUseBP(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cbFrame(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_cbFrame(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cbProlog: WORD,
        cbRegs: WORD,
        fHasSEH: WORD,
        fUseBP: WORD,
        reserved: WORD,
        cbFrame: WORD,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let cbProlog: u16 = unsafe { ::std::mem::transmute(cbProlog) };
            cbProlog as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let cbRegs: u16 = unsafe { ::std::mem::transmute(cbRegs) };
            cbRegs as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let fHasSEH: u16 = unsafe { ::std::mem::transmute(fHasSEH) };
            fHasSEH as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let fUseBP: u16 = unsafe { ::std::mem::transmute(fUseBP) };
            fUseBP as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let cbFrame: u16 = unsafe { ::std::mem::transmute(cbFrame) };
            cbFrame as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PFPO_DATA = *mut _FPO_DATA;
pub type PFLS_CALLBACK_FUNCTION = ::std::option::Option<unsafe extern "C" fn(lpFlsData: PVOID)>;
pub type WPARAM = UINT_PTR;
pub type LPARAM = LONG_PTR;
pub type HGLOBAL = HANDLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HINSTANCE__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HINSTANCE = *mut HINSTANCE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILETIME {
    pub dwLowDateTime: DWORD,
    pub dwHighDateTime: DWORD,
}
pub type FILETIME = _FILETIME;
pub type PFILETIME = *mut _FILETIME;
pub type LPFILETIME = *mut _FILETIME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HWND__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HWND = *mut HWND__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HBITMAP__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HBITMAP = *mut HBITMAP__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HDC__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HDC = *mut HDC__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HICON__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HICON = *mut HICON__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HPALETTE__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HPALETTE = *mut HPALETTE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RECTL {
    pub left: LONG,
    pub top: LONG,
    pub right: LONG,
    pub bottom: LONG,
}
pub type RECTL = _RECTL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSIZE {
    pub cx: LONG,
    pub cy: LONG,
}
pub type SIZE = tagSIZE;
pub type SIZEL = SIZE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OVERLAPPED {
    pub Internal: ULONG_PTR,
    pub InternalHigh: ULONG_PTR,
    pub __bindgen_anon_1: _OVERLAPPED__bindgen_ty_1,
    pub hEvent: HANDLE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _OVERLAPPED__bindgen_ty_1 {
    pub __bindgen_anon_1: _OVERLAPPED__bindgen_ty_1__bindgen_ty_1,
    pub Pointer: PVOID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OVERLAPPED__bindgen_ty_1__bindgen_ty_1 {
    pub Offset: DWORD,
    pub OffsetHigh: DWORD,
}
pub type LPOVERLAPPED = *mut _OVERLAPPED;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileBasicInfo: _FILE_INFO_BY_HANDLE_CLASS = 0;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileStandardInfo: _FILE_INFO_BY_HANDLE_CLASS = 1;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileNameInfo: _FILE_INFO_BY_HANDLE_CLASS = 2;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileRenameInfo: _FILE_INFO_BY_HANDLE_CLASS = 3;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileDispositionInfo: _FILE_INFO_BY_HANDLE_CLASS = 4;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileAllocationInfo: _FILE_INFO_BY_HANDLE_CLASS = 5;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileEndOfFileInfo: _FILE_INFO_BY_HANDLE_CLASS = 6;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileStreamInfo: _FILE_INFO_BY_HANDLE_CLASS = 7;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileCompressionInfo: _FILE_INFO_BY_HANDLE_CLASS = 8;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileAttributeTagInfo: _FILE_INFO_BY_HANDLE_CLASS = 9;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileIdBothDirectoryInfo: _FILE_INFO_BY_HANDLE_CLASS = 10;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileIdBothDirectoryRestartInfo: _FILE_INFO_BY_HANDLE_CLASS =
    11;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileIoPriorityHintInfo: _FILE_INFO_BY_HANDLE_CLASS = 12;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileRemoteProtocolInfo: _FILE_INFO_BY_HANDLE_CLASS = 13;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileFullDirectoryInfo: _FILE_INFO_BY_HANDLE_CLASS = 14;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileFullDirectoryRestartInfo: _FILE_INFO_BY_HANDLE_CLASS = 15;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileStorageInfo: _FILE_INFO_BY_HANDLE_CLASS = 16;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileAlignmentInfo: _FILE_INFO_BY_HANDLE_CLASS = 17;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileIdInfo: _FILE_INFO_BY_HANDLE_CLASS = 18;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileIdExtdDirectoryInfo: _FILE_INFO_BY_HANDLE_CLASS = 19;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileIdExtdDirectoryRestartInfo: _FILE_INFO_BY_HANDLE_CLASS =
    20;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileDispositionInfoEx: _FILE_INFO_BY_HANDLE_CLASS = 21;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileRenameInfoEx: _FILE_INFO_BY_HANDLE_CLASS = 22;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileCaseSensitiveInfo: _FILE_INFO_BY_HANDLE_CLASS = 23;
pub const _FILE_INFO_BY_HANDLE_CLASS_FileNormalizedNameInfo: _FILE_INFO_BY_HANDLE_CLASS = 24;
pub const _FILE_INFO_BY_HANDLE_CLASS_MaximumFileInfoByHandleClass: _FILE_INFO_BY_HANDLE_CLASS = 25;
pub type _FILE_INFO_BY_HANDLE_CLASS = ::std::os::raw::c_int;
pub type PFILE_INFO_BY_HANDLE_CLASS = *mut _FILE_INFO_BY_HANDLE_CLASS;
extern "C" {
    pub fn ProcessIdToSessionId(dwProcessId: DWORD, pSessionId: *mut DWORD) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WIN32_MEMORY_RANGE_ENTRY {
    pub VirtualAddress: PVOID,
    pub NumberOfBytes: SIZE_T,
}
pub type PWIN32_MEMORY_RANGE_ENTRY = *mut _WIN32_MEMORY_RANGE_ENTRY;
extern "C" {
    pub fn PrefetchVirtualMemory(
        hProcess: HANDLE,
        NumberOfEntries: ULONG_PTR,
        VirtualAddresses: PWIN32_MEMORY_RANGE_ENTRY,
        Flags: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn PrivilegeCheck(
        ClientToken: HANDLE,
        RequiredPrivileges: PPRIVILEGE_SET,
        pfResult: LPBOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn PrivilegedServiceAuditAlarmW(
        SubsystemName: LPCWSTR,
        ServiceName: LPCWSTR,
        ClientToken: HANDLE,
        Privileges: PPRIVILEGE_SET,
        AccessGranted: BOOL,
    ) -> BOOL;
}
pub type PFIBER_START_ROUTINE =
    ::std::option::Option<unsafe extern "C" fn(lpFiberParameter: LPVOID)>;
pub type PFIBER_CALLOUT_ROUTINE =
    ::std::option::Option<unsafe extern "C" fn(lpParameter: LPVOID) -> LPVOID>;
extern "C" {
    pub fn PrepareTape(hDevice: HANDLE, dwOperation: DWORD, bImmediate: BOOL) -> DWORD;
}
pub type PFE_EXPORT_FUNC = ::std::option::Option<
    unsafe extern "C" fn(pbData: PBYTE, pvCallbackContext: PVOID, ulLength: ULONG) -> DWORD,
>;
pub type PFE_IMPORT_FUNC = ::std::option::Option<
    unsafe extern "C" fn(pbData: PBYTE, pvCallbackContext: PVOID, ulLength: PULONG) -> DWORD,
>;
extern "C" {
    pub fn PrivilegedServiceAuditAlarmA(
        SubsystemName: LPCSTR,
        ServiceName: LPCSTR,
        ClientToken: HANDLE,
        Privileges: PPRIVILEGE_SET,
        AccessGranted: BOOL,
    ) -> BOOL;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BASIC_INFO {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub FileAttributes: DWORD,
}
pub type PFILE_BASIC_INFO = *mut _FILE_BASIC_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STANDARD_INFO {
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub NumberOfLinks: DWORD,
    pub DeletePending: BOOLEAN,
    pub Directory: BOOLEAN,
}
pub type PFILE_STANDARD_INFO = *mut _FILE_STANDARD_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_NAME_INFO {
    pub FileNameLength: DWORD,
    pub FileName: [WCHAR; 1usize],
}
pub type PFILE_NAME_INFO = *mut _FILE_NAME_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_CASE_SENSITIVE_INFO {
    pub Flags: ULONG,
}
pub type PFILE_CASE_SENSITIVE_INFO = *mut _FILE_CASE_SENSITIVE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_RENAME_INFO {
    pub __bindgen_anon_1: _FILE_RENAME_INFO__bindgen_ty_1,
    pub RootDirectory: HANDLE,
    pub FileNameLength: DWORD,
    pub FileName: [WCHAR; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_RENAME_INFO__bindgen_ty_1 {
    pub ReplaceIfExists: BOOLEAN,
    pub Flags: DWORD,
}
pub type PFILE_RENAME_INFO = *mut _FILE_RENAME_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ALLOCATION_INFO {
    pub AllocationSize: LARGE_INTEGER,
}
pub type PFILE_ALLOCATION_INFO = *mut _FILE_ALLOCATION_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_END_OF_FILE_INFO {
    pub EndOfFile: LARGE_INTEGER,
}
pub type PFILE_END_OF_FILE_INFO = *mut _FILE_END_OF_FILE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STREAM_INFO {
    pub NextEntryOffset: DWORD,
    pub StreamNameLength: DWORD,
    pub StreamSize: LARGE_INTEGER,
    pub StreamAllocationSize: LARGE_INTEGER,
    pub StreamName: [WCHAR; 1usize],
}
pub type PFILE_STREAM_INFO = *mut _FILE_STREAM_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_COMPRESSION_INFO {
    pub CompressedFileSize: LARGE_INTEGER,
    pub CompressionFormat: WORD,
    pub CompressionUnitShift: UCHAR,
    pub ChunkShift: UCHAR,
    pub ClusterShift: UCHAR,
    pub Reserved: [UCHAR; 3usize],
}
pub type PFILE_COMPRESSION_INFO = *mut _FILE_COMPRESSION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ATTRIBUTE_TAG_INFO {
    pub FileAttributes: DWORD,
    pub ReparseTag: DWORD,
}
pub type PFILE_ATTRIBUTE_TAG_INFO = *mut _FILE_ATTRIBUTE_TAG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_DISPOSITION_INFO {
    pub DeleteFileA: BOOLEAN,
}
pub type PFILE_DISPOSITION_INFO = *mut _FILE_DISPOSITION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_DISPOSITION_INFO_EX {
    pub Flags: DWORD,
}
pub type PFILE_DISPOSITION_INFO_EX = *mut _FILE_DISPOSITION_INFO_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_BOTH_DIR_INFO {
    pub NextEntryOffset: DWORD,
    pub FileIndex: DWORD,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: DWORD,
    pub FileNameLength: DWORD,
    pub EaSize: DWORD,
    pub ShortNameLength: CCHAR,
    pub ShortName: [WCHAR; 12usize],
    pub FileId: LARGE_INTEGER,
    pub FileName: [WCHAR; 1usize],
}
pub type PFILE_ID_BOTH_DIR_INFO = *mut _FILE_ID_BOTH_DIR_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FULL_DIR_INFO {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub FileName: [WCHAR; 1usize],
}
pub type PFILE_FULL_DIR_INFO = *mut _FILE_FULL_DIR_INFO;
pub const _PRIORITY_HINT_IoPriorityHintVeryLow: _PRIORITY_HINT = 0;
pub const _PRIORITY_HINT_IoPriorityHintLow: _PRIORITY_HINT = 1;
pub const _PRIORITY_HINT_IoPriorityHintNormal: _PRIORITY_HINT = 2;
pub const _PRIORITY_HINT_MaximumIoPriorityHintType: _PRIORITY_HINT = 3;
pub type _PRIORITY_HINT = ::std::os::raw::c_int;
pub use self::_PRIORITY_HINT as PRIORITY_HINT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_IO_PRIORITY_HINT_INFO {
    pub PriorityHint: PRIORITY_HINT,
}
pub type PFILE_IO_PRIORITY_HINT_INFO = *mut _FILE_IO_PRIORITY_HINT_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ALIGNMENT_INFO {
    pub AlignmentRequirement: ULONG,
}
pub type PFILE_ALIGNMENT_INFO = *mut _FILE_ALIGNMENT_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_STORAGE_INFO {
    pub LogicalBytesPerSector: ULONG,
    pub PhysicalBytesPerSectorForAtomicity: ULONG,
    pub PhysicalBytesPerSectorForPerformance: ULONG,
    pub FileSystemEffectivePhysicalBytesPerSectorForAtomicity: ULONG,
    pub Flags: ULONG,
    pub ByteOffsetForSectorAlignment: ULONG,
    pub ByteOffsetForPartitionAlignment: ULONG,
}
pub type PFILE_STORAGE_INFO = *mut _FILE_STORAGE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ID_INFO {
    pub VolumeSerialNumber: ULONGLONG,
    pub FileId: FILE_ID_128,
}
pub type PFILE_ID_INFO = *mut _FILE_ID_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ID_EXTD_DIR_INFO {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub ReparsePointTag: ULONG,
    pub FileId: FILE_ID_128,
    pub FileName: [WCHAR; 1usize],
}
pub type PFILE_ID_EXTD_DIR_INFO = *mut _FILE_ID_EXTD_DIR_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFO {
    pub StructureVersion: USHORT,
    pub StructureSize: USHORT,
    pub Protocol: ULONG,
    pub ProtocolMajorVersion: USHORT,
    pub ProtocolMinorVersion: USHORT,
    pub ProtocolRevision: USHORT,
    pub Reserved: USHORT,
    pub Flags: ULONG,
    pub GenericReserved: _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_1,
    pub ProtocolSpecific: _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_1 {
    pub Reserved: [ULONG; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2 {
    pub Smb2: _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1,
    pub Reserved: [ULONG; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1 {
    pub Server: _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub Share: _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub Capabilities: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REMOTE_PROTOCOL_INFO__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub Capabilities: ULONG,
    pub ShareFlags: ULONG,
}
pub type PFILE_REMOTE_PROTOCOL_INFO = *mut _FILE_REMOTE_PROTOCOL_INFO;
pub const _FILE_ID_TYPE_FileIdType: _FILE_ID_TYPE = 0;
pub const _FILE_ID_TYPE_ObjectIdType: _FILE_ID_TYPE = 1;
pub const _FILE_ID_TYPE_ExtendedFileIdType: _FILE_ID_TYPE = 2;
pub const _FILE_ID_TYPE_MaximumFileIdType: _FILE_ID_TYPE = 3;
pub type _FILE_ID_TYPE = ::std::os::raw::c_int;
pub type PFILE_ID_TYPE = *mut _FILE_ID_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagFONTSIGNATURE {
    pub fsUsb: [DWORD; 4usize],
    pub fsCsb: [DWORD; 2usize],
}
pub type PFONTSIGNATURE = *mut tagFONTSIGNATURE;
pub type DLGPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> INT_PTR,
>;
extern "C" {
    pub fn PrintWindow(hwnd: HWND, hdcBlt: HDC, nFlags: UINT) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLASHWINFO {
    pub cbSize: UINT,
    pub hwnd: HWND,
    pub dwFlags: DWORD,
    pub uCount: UINT,
    pub dwTimeout: DWORD,
}
pub type PFLASHWINFO = *mut FLASHWINFO;
#[repr(C, packed(2))]
#[derive(Debug, Copy, Clone)]
pub struct DLGTEMPLATE {
    pub style: DWORD,
    pub dwExtendedStyle: DWORD,
    pub cdit: WORD,
    pub x: ::std::os::raw::c_short,
    pub y: ::std::os::raw::c_short,
    pub cx: ::std::os::raw::c_short,
    pub cy: ::std::os::raw::c_short,
}
pub type LPCDLGTEMPLATEA = *const DLGTEMPLATE;
pub type LPCDLGTEMPLATE = LPCDLGTEMPLATEA;
extern "C" {
    pub fn PrivateExtractIconsA(
        szFileName: LPCSTR,
        nIconIndex: ::std::os::raw::c_int,
        cxIcon: ::std::os::raw::c_int,
        cyIcon: ::std::os::raw::c_int,
        phicon: *mut HICON,
        piconid: *mut UINT,
        nIcons: UINT,
        flags: UINT,
    ) -> UINT;
}
extern "C" {
    pub fn PrivateExtractIconsW(
        szFileName: LPCWSTR,
        nIconIndex: ::std::os::raw::c_int,
        cxIcon: ::std::os::raw::c_int,
        cyIcon: ::std::os::raw::c_int,
        phicon: *mut HICON,
        piconid: *mut UINT,
        nIcons: UINT,
        flags: UINT,
    ) -> UINT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILEMUIINFO {
    pub dwSize: DWORD,
    pub dwVersion: DWORD,
    pub dwFileType: DWORD,
    pub pChecksum: [BYTE; 16usize],
    pub pServiceChecksum: [BYTE; 16usize],
    pub dwLanguageNameOffset: DWORD,
    pub dwTypeIDMainSize: DWORD,
    pub dwTypeIDMainOffset: DWORD,
    pub dwTypeNameMainOffset: DWORD,
    pub dwTypeIDMUISize: DWORD,
    pub dwTypeIDMUIOffset: DWORD,
    pub dwTypeNameMUIOffset: DWORD,
    pub abBuffer: [BYTE; 8usize],
}
pub type PFILEMUIINFO = *mut _FILEMUIINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FOCUS_EVENT_RECORD {
    pub bSetFocus: BOOL,
}
pub type PFOCUS_EVENT_RECORD = *mut _FOCUS_EVENT_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HCONV__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HCONV = *mut HCONV__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HSZ__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HSZ = *mut HSZ__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HDDEDATA__ {
    pub unused: ::std::os::raw::c_int,
}
pub type HDDEDATA = *mut HDDEDATA__;
pub type PFNCALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        wType: UINT,
        wFmt: UINT,
        hConv: HCONV,
        hsz1: HSZ,
        hsz2: HSZ,
        hData: HDDEDATA,
        dwData1: ULONG_PTR,
        dwData2: ULONG_PTR,
    ) -> HDDEDATA,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FIND_NAME_HEADER {
    pub node_count: WORD,
    pub reserved: UCHAR,
    pub unique_group: UCHAR,
}
pub type PFIND_NAME_HEADER = *mut _FIND_NAME_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FIND_NAME_BUFFER {
    pub length: UCHAR,
    pub access_control: UCHAR,
    pub frame_control: UCHAR,
    pub destination_addr: [UCHAR; 6usize],
    pub source_addr: [UCHAR; 6usize],
    pub routing_info: [UCHAR; 18usize],
}
pub type PFIND_NAME_BUFFER = *mut _FIND_NAME_BUFFER;
pub const _RPC_NOTIFICATION_TYPES_RpcNotificationTypeNone: _RPC_NOTIFICATION_TYPES = 0;
pub const _RPC_NOTIFICATION_TYPES_RpcNotificationTypeEvent: _RPC_NOTIFICATION_TYPES = 1;
pub const _RPC_NOTIFICATION_TYPES_RpcNotificationTypeApc: _RPC_NOTIFICATION_TYPES = 2;
pub const _RPC_NOTIFICATION_TYPES_RpcNotificationTypeIoc: _RPC_NOTIFICATION_TYPES = 3;
pub const _RPC_NOTIFICATION_TYPES_RpcNotificationTypeHwnd: _RPC_NOTIFICATION_TYPES = 4;
pub const _RPC_NOTIFICATION_TYPES_RpcNotificationTypeCallback: _RPC_NOTIFICATION_TYPES = 5;
pub type _RPC_NOTIFICATION_TYPES = ::std::os::raw::c_int;
pub use self::_RPC_NOTIFICATION_TYPES as RPC_NOTIFICATION_TYPES;
pub const _RPC_ASYNC_EVENT_RpcCallComplete: _RPC_ASYNC_EVENT = 0;
pub const _RPC_ASYNC_EVENT_RpcSendComplete: _RPC_ASYNC_EVENT = 1;
pub const _RPC_ASYNC_EVENT_RpcReceiveComplete: _RPC_ASYNC_EVENT = 2;
pub const _RPC_ASYNC_EVENT_RpcClientDisconnect: _RPC_ASYNC_EVENT = 3;
pub const _RPC_ASYNC_EVENT_RpcClientCancel: _RPC_ASYNC_EVENT = 4;
pub type _RPC_ASYNC_EVENT = ::std::os::raw::c_int;
pub use self::_RPC_ASYNC_EVENT as RPC_ASYNC_EVENT;
pub type PFN_RPCNOTIFICATION_ROUTINE = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut _RPC_ASYNC_STATE,
        arg2: *mut ::std::os::raw::c_void,
        arg3: RPC_ASYNC_EVENT,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RPC_ASYNC_NOTIFICATION_INFO {
    pub APC: _RPC_ASYNC_NOTIFICATION_INFO__bindgen_ty_1,
    pub IOC: _RPC_ASYNC_NOTIFICATION_INFO__bindgen_ty_2,
    pub HWND: _RPC_ASYNC_NOTIFICATION_INFO__bindgen_ty_3,
    pub hEvent: HANDLE,
    pub NotificationRoutine: PFN_RPCNOTIFICATION_ROUTINE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_ASYNC_NOTIFICATION_INFO__bindgen_ty_1 {
    pub NotificationRoutine: PFN_RPCNOTIFICATION_ROUTINE,
    pub hThread: HANDLE,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_ASYNC_NOTIFICATION_INFO__bindgen_ty_2 {
    pub hIOPort: HANDLE,
    pub dwNumberOfBytesTransferred: DWORD,
    pub dwCompletionKey: DWORD_PTR,
    pub lpOverlapped: LPOVERLAPPED,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RPC_ASYNC_NOTIFICATION_INFO__bindgen_ty_3 {
    pub hWnd: HWND,
    pub Msg: UINT,
}
pub type RPC_ASYNC_NOTIFICATION_INFO = _RPC_ASYNC_NOTIFICATION_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RPC_ASYNC_STATE {
    pub Size: ::std::os::raw::c_uint,
    pub Signature: ::std::os::raw::c_ulong,
    pub Lock: ::std::os::raw::c_long,
    pub Flags: ::std::os::raw::c_ulong,
    pub StubInfo: *mut ::std::os::raw::c_void,
    pub UserInfo: *mut ::std::os::raw::c_void,
    pub RuntimeInfo: *mut ::std::os::raw::c_void,
    pub Event: RPC_ASYNC_EVENT,
    pub NotificationType: RPC_NOTIFICATION_TYPES,
    pub u: RPC_ASYNC_NOTIFICATION_INFO,
    pub Reserved: [LONG_PTR; 4usize],
}
pub type PFNCANSHAREFOLDERW =
    ::std::option::Option<unsafe extern "C" fn(pszPath: PCWSTR) -> HRESULT>;
pub type PFNSHOWSHAREFOLDERUIW =
    ::std::option::Option<unsafe extern "C" fn(hwndParent: HWND, pszPath: PCWSTR) -> HRESULT>;
pub type u_int = ::std::os::raw::c_uint;
pub type SOCKET = UINT_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fd_count: u_int,
    pub fd_array: [SOCKET; 64usize],
}
pub type PFD_SET = *mut fd_set;
pub type ALG_ID = ::std::os::raw::c_uint;
pub type HCRYPTPROV = ULONG_PTR;
pub type HCRYPTKEY = ULONG_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPTOAPI_BLOB {
    pub cbData: DWORD,
    pub pbData: *mut BYTE,
}
pub type CRYPT_INTEGER_BLOB = _CRYPTOAPI_BLOB;
pub type CRYPT_OBJID_BLOB = _CRYPTOAPI_BLOB;
pub type CERT_NAME_BLOB = _CRYPTOAPI_BLOB;
pub type PCERT_NAME_BLOB = *mut _CRYPTOAPI_BLOB;
pub type CRYPT_DATA_BLOB = _CRYPTOAPI_BLOB;
pub type PCRYPT_DATA_BLOB = *mut _CRYPTOAPI_BLOB;
pub type CRYPT_HASH_BLOB = _CRYPTOAPI_BLOB;
pub type CRYPT_DER_BLOB = _CRYPTOAPI_BLOB;
pub type PCRYPT_ATTR_BLOB = *mut _CRYPTOAPI_BLOB;
pub type BCRYPT_KEY_HANDLE = PVOID;
pub type PFN_NCRYPT_ALLOC = ::std::option::Option<unsafe extern "C" fn(cbSize: SIZE_T) -> LPVOID>;
pub type PFN_NCRYPT_FREE = ::std::option::Option<unsafe extern "C" fn(pv: LPVOID)>;
pub type NCRYPT_KEY_HANDLE = ULONG_PTR;
pub type HCRYPTPROV_LEGACY = ULONG_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_BIT_BLOB {
    pub cbData: DWORD,
    pub pbData: *mut BYTE,
    pub cUnusedBits: DWORD,
}
pub type CRYPT_BIT_BLOB = _CRYPT_BIT_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_ALGORITHM_IDENTIFIER {
    pub pszObjId: LPSTR,
    pub Parameters: CRYPT_OBJID_BLOB,
}
pub type CRYPT_ALGORITHM_IDENTIFIER = _CRYPT_ALGORITHM_IDENTIFIER;
pub type PCRYPT_ALGORITHM_IDENTIFIER = *mut _CRYPT_ALGORITHM_IDENTIFIER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_EXTENSION {
    pub pszObjId: LPSTR,
    pub fCritical: BOOL,
    pub Value: CRYPT_OBJID_BLOB,
}
pub type PCERT_EXTENSION = *mut _CERT_EXTENSION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_ATTRIBUTE_TYPE_VALUE {
    pub pszObjId: LPSTR,
    pub Value: CRYPT_OBJID_BLOB,
}
pub type PCRYPT_ATTRIBUTE_TYPE_VALUE = *mut _CRYPT_ATTRIBUTE_TYPE_VALUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_ATTRIBUTE {
    pub pszObjId: LPSTR,
    pub cValue: DWORD,
    pub rgValue: PCRYPT_ATTR_BLOB,
}
pub type PCRYPT_ATTRIBUTE = *mut _CRYPT_ATTRIBUTE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_ATTRIBUTES {
    pub cAttr: DWORD,
    pub rgAttr: PCRYPT_ATTRIBUTE,
}
pub type PCRYPT_ATTRIBUTES = *mut _CRYPT_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_PUBLIC_KEY_INFO {
    pub Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub PublicKey: CRYPT_BIT_BLOB,
}
pub type CERT_PUBLIC_KEY_INFO = _CERT_PUBLIC_KEY_INFO;
pub type PCERT_PUBLIC_KEY_INFO = *mut _CERT_PUBLIC_KEY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_PRIVATE_KEY_INFO {
    pub Version: DWORD,
    pub Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub PrivateKey: CRYPT_DER_BLOB,
    pub pAttributes: PCRYPT_ATTRIBUTES,
}
pub type CRYPT_PRIVATE_KEY_INFO = _CRYPT_PRIVATE_KEY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_INFO {
    pub dwVersion: DWORD,
    pub SerialNumber: CRYPT_INTEGER_BLOB,
    pub SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub Issuer: CERT_NAME_BLOB,
    pub NotBefore: FILETIME,
    pub NotAfter: FILETIME,
    pub Subject: CERT_NAME_BLOB,
    pub SubjectPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    pub IssuerUniqueId: CRYPT_BIT_BLOB,
    pub SubjectUniqueId: CRYPT_BIT_BLOB,
    pub cExtension: DWORD,
    pub rgExtension: PCERT_EXTENSION,
}
pub type PCERT_INFO = *mut _CERT_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRL_ENTRY {
    pub SerialNumber: CRYPT_INTEGER_BLOB,
    pub RevocationDate: FILETIME,
    pub cExtension: DWORD,
    pub rgExtension: PCERT_EXTENSION,
}
pub type PCRL_ENTRY = *mut _CRL_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRL_INFO {
    pub dwVersion: DWORD,
    pub SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub Issuer: CERT_NAME_BLOB,
    pub ThisUpdate: FILETIME,
    pub NextUpdate: FILETIME,
    pub cCRLEntry: DWORD,
    pub rgCRLEntry: PCRL_ENTRY,
    pub cExtension: DWORD,
    pub rgExtension: PCERT_EXTENSION,
}
pub type PCRL_INFO = *mut _CRL_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CTL_USAGE {
    pub cUsageIdentifier: DWORD,
    pub rgpszUsageIdentifier: *mut LPSTR,
}
pub type CTL_USAGE = _CTL_USAGE;
pub type PCERT_ENHKEY_USAGE = *mut _CTL_USAGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CTL_ENTRY {
    pub SubjectIdentifier: CRYPT_DATA_BLOB,
    pub cAttribute: DWORD,
    pub rgAttribute: PCRYPT_ATTRIBUTE,
}
pub type PCTL_ENTRY = *mut _CTL_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CTL_INFO {
    pub dwVersion: DWORD,
    pub SubjectUsage: CTL_USAGE,
    pub ListIdentifier: CRYPT_DATA_BLOB,
    pub SequenceNumber: CRYPT_INTEGER_BLOB,
    pub ThisUpdate: FILETIME,
    pub NextUpdate: FILETIME,
    pub SubjectAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub cCTLEntry: DWORD,
    pub rgCTLEntry: PCTL_ENTRY,
    pub cExtension: DWORD,
    pub rgExtension: PCERT_EXTENSION,
}
pub type PCTL_INFO = *mut _CTL_INFO;
pub type PFN_CRYPT_ALLOC = ::std::option::Option<unsafe extern "C" fn(cbSize: usize) -> LPVOID>;
pub type PFN_CRYPT_FREE = ::std::option::Option<unsafe extern "C" fn(pv: LPVOID)>;
pub type HCRYPTOIDFUNCADDR = *mut ::std::os::raw::c_void;
pub type PFN_CRYPT_ENUM_OID_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        dwEncodingType: DWORD,
        pszFuncName: LPCSTR,
        pszOID: LPCSTR,
        cValue: DWORD,
        rgdwValueType: *const DWORD,
        rgpwszValueName: *const LPCWSTR,
        rgpbValueData: *const *const BYTE,
        rgcbValueData: *const DWORD,
        pvArg: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CRYPT_OID_INFO {
    pub cbSize: DWORD,
    pub pszOID: LPCSTR,
    pub pwszName: LPCWSTR,
    pub dwGroupId: DWORD,
    pub __bindgen_anon_1: _CRYPT_OID_INFO__bindgen_ty_1,
    pub ExtraInfo: CRYPT_DATA_BLOB,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CRYPT_OID_INFO__bindgen_ty_1 {
    pub dwValue: DWORD,
    pub Algid: ALG_ID,
    pub dwLength: DWORD,
}
pub type CRYPT_OID_INFO = _CRYPT_OID_INFO;
pub type PCCRYPT_OID_INFO = *const CRYPT_OID_INFO;
pub type PFN_CRYPT_ENUM_OID_INFO = ::std::option::Option<
    unsafe extern "C" fn(pInfo: PCCRYPT_OID_INFO, pvArg: *mut ::std::os::raw::c_void) -> BOOL,
>;
pub type HCRYPTMSG = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_ISSUER_SERIAL_NUMBER {
    pub Issuer: CERT_NAME_BLOB,
    pub SerialNumber: CRYPT_INTEGER_BLOB,
}
pub type CERT_ISSUER_SERIAL_NUMBER = _CERT_ISSUER_SERIAL_NUMBER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CERT_ID {
    pub dwIdChoice: DWORD,
    pub __bindgen_anon_1: _CERT_ID__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CERT_ID__bindgen_ty_1 {
    pub IssuerSerialNumber: CERT_ISSUER_SERIAL_NUMBER,
    pub KeyId: CRYPT_HASH_BLOB,
    pub HashId: CRYPT_HASH_BLOB,
}
pub type CERT_ID = _CERT_ID;
pub type PCERT_ID = *mut _CERT_ID;
pub type PCMSG_RECIPIENT_ENCODE_INFO = *mut _CMSG_RECIPIENT_ENCODE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO {
    pub cbSize: DWORD,
    pub KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub pvKeyEncryptionAuxInfo: *mut ::std::os::raw::c_void,
    pub hCryptProv: HCRYPTPROV_LEGACY,
    pub RecipientPublicKey: CRYPT_BIT_BLOB,
    pub RecipientId: CERT_ID,
}
pub type PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO = *mut _CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO {
    pub cbSize: DWORD,
    pub RecipientPublicKey: CRYPT_BIT_BLOB,
    pub RecipientId: CERT_ID,
    pub Date: FILETIME,
    pub pOtherAttr: PCRYPT_ATTRIBUTE_TYPE_VALUE,
}
pub type PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO = *mut _CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO {
    pub cbSize: DWORD,
    pub KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub pvKeyEncryptionAuxInfo: *mut ::std::os::raw::c_void,
    pub KeyWrapAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub pvKeyWrapAuxInfo: *mut ::std::os::raw::c_void,
    pub hCryptProv: HCRYPTPROV_LEGACY,
    pub dwKeySpec: DWORD,
    pub dwKeyChoice: DWORD,
    pub __bindgen_anon_1: _CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO__bindgen_ty_1,
    pub UserKeyingMaterial: CRYPT_DATA_BLOB,
    pub cRecipientEncryptedKeys: DWORD,
    pub rgpRecipientEncryptedKeys: *mut PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO__bindgen_ty_1 {
    pub pEphemeralAlgorithm: PCRYPT_ALGORITHM_IDENTIFIER,
    pub pSenderId: PCERT_ID,
}
pub type PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO = *mut _CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO {
    pub cbSize: DWORD,
    pub KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub pvKeyEncryptionAuxInfo: *mut ::std::os::raw::c_void,
    pub hCryptProv: HCRYPTPROV,
    pub dwKeyChoice: DWORD,
    pub __bindgen_anon_1: _CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO__bindgen_ty_1,
    pub KeyId: CRYPT_DATA_BLOB,
    pub Date: FILETIME,
    pub pOtherAttr: PCRYPT_ATTRIBUTE_TYPE_VALUE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO__bindgen_ty_1 {
    pub hKeyEncryptionKey: HCRYPTKEY,
    pub pvKeyEncryptionKey: *mut ::std::os::raw::c_void,
}
pub type PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO = *mut _CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_RECIPIENT_ENCODE_INFO {
    pub dwRecipientChoice: DWORD,
    pub __bindgen_anon_1: _CMSG_RECIPIENT_ENCODE_INFO__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMSG_RECIPIENT_ENCODE_INFO__bindgen_ty_1 {
    pub pKeyTrans: PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO,
    pub pKeyAgree: PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO,
    pub pMailList: PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO,
}
pub type PFN_CMSG_STREAM_OUTPUT = ::std::option::Option<
    unsafe extern "C" fn(
        pvArg: *const ::std::os::raw::c_void,
        pbData: *mut BYTE,
        cbData: DWORD,
        fFinal: BOOL,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_KEY_TRANS_RECIPIENT_INFO {
    pub dwVersion: DWORD,
    pub RecipientId: CERT_ID,
    pub KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub EncryptedKey: CRYPT_DATA_BLOB,
}
pub type PCMSG_KEY_TRANS_RECIPIENT_INFO = *mut _CMSG_KEY_TRANS_RECIPIENT_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_RECIPIENT_ENCRYPTED_KEY_INFO {
    pub RecipientId: CERT_ID,
    pub EncryptedKey: CRYPT_DATA_BLOB,
    pub Date: FILETIME,
    pub pOtherAttr: PCRYPT_ATTRIBUTE_TYPE_VALUE,
}
pub type PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO = *mut _CMSG_RECIPIENT_ENCRYPTED_KEY_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_KEY_AGREE_RECIPIENT_INFO {
    pub dwVersion: DWORD,
    pub dwOriginatorChoice: DWORD,
    pub __bindgen_anon_1: _CMSG_KEY_AGREE_RECIPIENT_INFO__bindgen_ty_1,
    pub UserKeyingMaterial: CRYPT_DATA_BLOB,
    pub KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub cRecipientEncryptedKeys: DWORD,
    pub rgpRecipientEncryptedKeys: *mut PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMSG_KEY_AGREE_RECIPIENT_INFO__bindgen_ty_1 {
    pub OriginatorCertId: CERT_ID,
    pub OriginatorPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
}
pub type PCMSG_KEY_AGREE_RECIPIENT_INFO = *mut _CMSG_KEY_AGREE_RECIPIENT_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_MAIL_LIST_RECIPIENT_INFO {
    pub dwVersion: DWORD,
    pub KeyId: CRYPT_DATA_BLOB,
    pub KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub EncryptedKey: CRYPT_DATA_BLOB,
    pub Date: FILETIME,
    pub pOtherAttr: PCRYPT_ATTRIBUTE_TYPE_VALUE,
}
pub type PCMSG_MAIL_LIST_RECIPIENT_INFO = *mut _CMSG_MAIL_LIST_RECIPIENT_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_CTRL_KEY_TRANS_DECRYPT_PARA {
    pub cbSize: DWORD,
    pub __bindgen_anon_1: _CMSG_CTRL_KEY_TRANS_DECRYPT_PARA__bindgen_ty_1,
    pub dwKeySpec: DWORD,
    pub pKeyTrans: PCMSG_KEY_TRANS_RECIPIENT_INFO,
    pub dwRecipientIndex: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMSG_CTRL_KEY_TRANS_DECRYPT_PARA__bindgen_ty_1 {
    pub hCryptProv: HCRYPTPROV,
    pub hNCryptKey: NCRYPT_KEY_HANDLE,
}
pub type PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA = *mut _CMSG_CTRL_KEY_TRANS_DECRYPT_PARA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_CTRL_KEY_AGREE_DECRYPT_PARA {
    pub cbSize: DWORD,
    pub __bindgen_anon_1: _CMSG_CTRL_KEY_AGREE_DECRYPT_PARA__bindgen_ty_1,
    pub dwKeySpec: DWORD,
    pub pKeyAgree: PCMSG_KEY_AGREE_RECIPIENT_INFO,
    pub dwRecipientIndex: DWORD,
    pub dwRecipientEncryptedKeyIndex: DWORD,
    pub OriginatorPublicKey: CRYPT_BIT_BLOB,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMSG_CTRL_KEY_AGREE_DECRYPT_PARA__bindgen_ty_1 {
    pub hCryptProv: HCRYPTPROV,
    pub hNCryptKey: NCRYPT_KEY_HANDLE,
}
pub type PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA = *mut _CMSG_CTRL_KEY_AGREE_DECRYPT_PARA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_CTRL_MAIL_LIST_DECRYPT_PARA {
    pub cbSize: DWORD,
    pub hCryptProv: HCRYPTPROV,
    pub pMailList: PCMSG_MAIL_LIST_RECIPIENT_INFO,
    pub dwRecipientIndex: DWORD,
    pub dwKeyChoice: DWORD,
    pub __bindgen_anon_1: _CMSG_CTRL_MAIL_LIST_DECRYPT_PARA__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMSG_CTRL_MAIL_LIST_DECRYPT_PARA__bindgen_ty_1 {
    pub hKeyEncryptionKey: HCRYPTKEY,
    pub pvKeyEncryptionKey: *mut ::std::os::raw::c_void,
}
pub type PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA = *mut _CMSG_CTRL_MAIL_LIST_DECRYPT_PARA;
pub type PFN_CMSG_ALLOC =
    ::std::option::Option<unsafe extern "C" fn(cb: usize) -> *mut ::std::os::raw::c_void>;
pub type PFN_CMSG_FREE =
    ::std::option::Option<unsafe extern "C" fn(pv: *mut ::std::os::raw::c_void)>;
pub type PFN_CMSG_GEN_ENCRYPT_KEY = ::std::option::Option<
    unsafe extern "C" fn(
        phCryptProv: *mut HCRYPTPROV,
        paiEncrypt: PCRYPT_ALGORITHM_IDENTIFIER,
        pvEncryptAuxInfo: PVOID,
        pPublicKeyInfo: PCERT_PUBLIC_KEY_INFO,
        pfnAlloc: PFN_CMSG_ALLOC,
        phEncryptKey: *mut HCRYPTKEY,
        ppbEncryptParameters: *mut PBYTE,
        pcbEncryptParameters: PDWORD,
    ) -> BOOL,
>;
pub type PFN_CMSG_EXPORT_ENCRYPT_KEY = ::std::option::Option<
    unsafe extern "C" fn(
        hCryptProv: HCRYPTPROV,
        hEncryptKey: HCRYPTKEY,
        pPublicKeyInfo: PCERT_PUBLIC_KEY_INFO,
        pbData: PBYTE,
        pcbData: PDWORD,
    ) -> BOOL,
>;
pub type PFN_CMSG_IMPORT_ENCRYPT_KEY = ::std::option::Option<
    unsafe extern "C" fn(
        hCryptProv: HCRYPTPROV,
        dwKeySpec: DWORD,
        paiEncrypt: PCRYPT_ALGORITHM_IDENTIFIER,
        paiPubKey: PCRYPT_ALGORITHM_IDENTIFIER,
        pbEncodedKey: PBYTE,
        cbEncodedKey: DWORD,
        phEncryptKey: *mut HCRYPTKEY,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_CONTENT_ENCRYPT_INFO {
    pub cbSize: DWORD,
    pub hCryptProv: HCRYPTPROV_LEGACY,
    pub ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub pvEncryptionAuxInfo: *mut ::std::os::raw::c_void,
    pub cRecipients: DWORD,
    pub rgCmsRecipients: PCMSG_RECIPIENT_ENCODE_INFO,
    pub pfnAlloc: PFN_CMSG_ALLOC,
    pub pfnFree: PFN_CMSG_FREE,
    pub dwEncryptFlags: DWORD,
    pub __bindgen_anon_1: _CMSG_CONTENT_ENCRYPT_INFO__bindgen_ty_1,
    pub dwFlags: DWORD,
    pub fCNG: BOOL,
    pub pbCNGContentEncryptKeyObject: *mut BYTE,
    pub pbContentEncryptKey: *mut BYTE,
    pub cbContentEncryptKey: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMSG_CONTENT_ENCRYPT_INFO__bindgen_ty_1 {
    pub hContentEncryptKey: HCRYPTKEY,
    pub hCNGContentEncryptKey: BCRYPT_KEY_HANDLE,
}
pub type PCMSG_CONTENT_ENCRYPT_INFO = *mut _CMSG_CONTENT_ENCRYPT_INFO;
pub type PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY = ::std::option::Option<
    unsafe extern "C" fn(
        pContentEncryptInfo: PCMSG_CONTENT_ENCRYPT_INFO,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_KEY_TRANS_ENCRYPT_INFO {
    pub cbSize: DWORD,
    pub dwRecipientIndex: DWORD,
    pub KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub EncryptedKey: CRYPT_DATA_BLOB,
    pub dwFlags: DWORD,
}
pub type PCMSG_KEY_TRANS_ENCRYPT_INFO = *mut _CMSG_KEY_TRANS_ENCRYPT_INFO;
pub type PFN_CMSG_EXPORT_KEY_TRANS = ::std::option::Option<
    unsafe extern "C" fn(
        pContentEncryptInfo: PCMSG_CONTENT_ENCRYPT_INFO,
        pKeyTransEncodeInfo: PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO,
        pKeyTransEncryptInfo: PCMSG_KEY_TRANS_ENCRYPT_INFO,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_KEY_AGREE_KEY_ENCRYPT_INFO {
    pub cbSize: DWORD,
    pub EncryptedKey: CRYPT_DATA_BLOB,
}
pub type PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO = *mut _CMSG_KEY_AGREE_KEY_ENCRYPT_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CMSG_KEY_AGREE_ENCRYPT_INFO {
    pub cbSize: DWORD,
    pub dwRecipientIndex: DWORD,
    pub KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub UserKeyingMaterial: CRYPT_DATA_BLOB,
    pub dwOriginatorChoice: DWORD,
    pub __bindgen_anon_1: _CMSG_KEY_AGREE_ENCRYPT_INFO__bindgen_ty_1,
    pub cKeyAgreeKeyEncryptInfo: DWORD,
    pub rgpKeyAgreeKeyEncryptInfo: *mut PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO,
    pub dwFlags: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CMSG_KEY_AGREE_ENCRYPT_INFO__bindgen_ty_1 {
    pub OriginatorCertId: CERT_ID,
    pub OriginatorPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
}
pub type PCMSG_KEY_AGREE_ENCRYPT_INFO = *mut _CMSG_KEY_AGREE_ENCRYPT_INFO;
pub type PFN_CMSG_EXPORT_KEY_AGREE = ::std::option::Option<
    unsafe extern "C" fn(
        pContentEncryptInfo: PCMSG_CONTENT_ENCRYPT_INFO,
        pKeyAgreeEncodeInfo: PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO,
        pKeyAgreeEncryptInfo: PCMSG_KEY_AGREE_ENCRYPT_INFO,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_MAIL_LIST_ENCRYPT_INFO {
    pub cbSize: DWORD,
    pub dwRecipientIndex: DWORD,
    pub KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub EncryptedKey: CRYPT_DATA_BLOB,
    pub dwFlags: DWORD,
}
pub type PCMSG_MAIL_LIST_ENCRYPT_INFO = *mut _CMSG_MAIL_LIST_ENCRYPT_INFO;
pub type PFN_CMSG_EXPORT_MAIL_LIST = ::std::option::Option<
    unsafe extern "C" fn(
        pContentEncryptInfo: PCMSG_CONTENT_ENCRYPT_INFO,
        pMailListEncodeInfo: PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO,
        pMailListEncryptInfo: PCMSG_MAIL_LIST_ENCRYPT_INFO,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
pub type PFN_CMSG_IMPORT_KEY_TRANS = ::std::option::Option<
    unsafe extern "C" fn(
        pContentEncryptionAlgorithm: PCRYPT_ALGORITHM_IDENTIFIER,
        pKeyTransDecryptPara: PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
        phContentEncryptKey: *mut HCRYPTKEY,
    ) -> BOOL,
>;
pub type PFN_CMSG_IMPORT_KEY_AGREE = ::std::option::Option<
    unsafe extern "C" fn(
        pContentEncryptionAlgorithm: PCRYPT_ALGORITHM_IDENTIFIER,
        pKeyAgreeDecryptPara: PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
        phContentEncryptKey: *mut HCRYPTKEY,
    ) -> BOOL,
>;
pub type PFN_CMSG_IMPORT_MAIL_LIST = ::std::option::Option<
    unsafe extern "C" fn(
        pContentEncryptionAlgorithm: PCRYPT_ALGORITHM_IDENTIFIER,
        pMailListDecryptPara: PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
        phContentEncryptKey: *mut HCRYPTKEY,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CMSG_CNG_CONTENT_DECRYPT_INFO {
    pub cbSize: DWORD,
    pub ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pub pfnAlloc: PFN_CMSG_ALLOC,
    pub pfnFree: PFN_CMSG_FREE,
    pub hNCryptKey: NCRYPT_KEY_HANDLE,
    pub pbContentEncryptKey: *mut BYTE,
    pub cbContentEncryptKey: DWORD,
    pub hCNGContentEncryptKey: BCRYPT_KEY_HANDLE,
    pub pbCNGContentEncryptKeyObject: *mut BYTE,
}
pub type PCMSG_CNG_CONTENT_DECRYPT_INFO = *mut _CMSG_CNG_CONTENT_DECRYPT_INFO;
pub type PFN_CMSG_CNG_IMPORT_KEY_TRANS = ::std::option::Option<
    unsafe extern "C" fn(
        pCNGContentDecryptInfo: PCMSG_CNG_CONTENT_DECRYPT_INFO,
        pKeyTransDecryptPara: PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
pub type PFN_CMSG_CNG_IMPORT_KEY_AGREE = ::std::option::Option<
    unsafe extern "C" fn(
        pCNGContentDecryptInfo: PCMSG_CNG_CONTENT_DECRYPT_INFO,
        pKeyAgreeDecryptPara: PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
pub type PFN_CMSG_CNG_IMPORT_CONTENT_ENCRYPT_KEY = ::std::option::Option<
    unsafe extern "C" fn(
        pCNGContentDecryptInfo: PCMSG_CNG_CONTENT_DECRYPT_INFO,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
pub type HCERTSTORE = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_CONTEXT {
    pub dwCertEncodingType: DWORD,
    pub pbCertEncoded: *mut BYTE,
    pub cbCertEncoded: DWORD,
    pub pCertInfo: PCERT_INFO,
    pub hCertStore: HCERTSTORE,
}
pub type CERT_CONTEXT = _CERT_CONTEXT;
pub type PCCERT_CONTEXT = *const CERT_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRL_CONTEXT {
    pub dwCertEncodingType: DWORD,
    pub pbCrlEncoded: *mut BYTE,
    pub cbCrlEncoded: DWORD,
    pub pCrlInfo: PCRL_INFO,
    pub hCertStore: HCERTSTORE,
}
pub type CRL_CONTEXT = _CRL_CONTEXT;
pub type PCCRL_CONTEXT = *const CRL_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CTL_CONTEXT {
    pub dwMsgAndCertEncodingType: DWORD,
    pub pbCtlEncoded: *mut BYTE,
    pub cbCtlEncoded: DWORD,
    pub pCtlInfo: PCTL_INFO,
    pub hCertStore: HCERTSTORE,
    pub hCryptMsg: HCRYPTMSG,
    pub pbCtlContent: *mut BYTE,
    pub cbCtlContent: DWORD,
}
pub type CTL_CONTEXT = _CTL_CONTEXT;
pub type PCCTL_CONTEXT = *const CTL_CONTEXT;
pub type HCERTSTOREPROV = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_STORE_PROV_INFO {
    pub cbSize: DWORD,
    pub cStoreProvFunc: DWORD,
    pub rgpvStoreProvFunc: *mut *mut ::std::os::raw::c_void,
    pub hStoreProv: HCERTSTOREPROV,
    pub dwStoreProvFlags: DWORD,
    pub hStoreProvFuncAddr2: HCRYPTOIDFUNCADDR,
}
pub type PCERT_STORE_PROV_INFO = *mut _CERT_STORE_PROV_INFO;
pub type PFN_CERT_DLL_OPEN_STORE_PROV_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        lpszStoreProvider: LPCSTR,
        dwEncodingType: DWORD,
        hCryptProv: HCRYPTPROV_LEGACY,
        dwFlags: DWORD,
        pvPara: *const ::std::os::raw::c_void,
        hCertStore: HCERTSTORE,
        pStoreProvInfo: PCERT_STORE_PROV_INFO,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_CLOSE =
    ::std::option::Option<unsafe extern "C" fn(hStoreProv: HCERTSTOREPROV, dwFlags: DWORD)>;
pub type PFN_CERT_STORE_PROV_READ_CERT = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pStoreCertContext: PCCERT_CONTEXT,
        dwFlags: DWORD,
        ppProvCertContext: *mut PCCERT_CONTEXT,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_WRITE_CERT = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCertContext: PCCERT_CONTEXT,
        dwFlags: DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_DELETE_CERT = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCertContext: PCCERT_CONTEXT,
        dwFlags: DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_SET_CERT_PROPERTY = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCertContext: PCCERT_CONTEXT,
        dwPropId: DWORD,
        dwFlags: DWORD,
        pvData: *const ::std::os::raw::c_void,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_READ_CRL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pStoreCrlContext: PCCRL_CONTEXT,
        dwFlags: DWORD,
        ppProvCrlContext: *mut PCCRL_CONTEXT,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_WRITE_CRL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCrlContext: PCCRL_CONTEXT,
        dwFlags: DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_DELETE_CRL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCrlContext: PCCRL_CONTEXT,
        dwFlags: DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_SET_CRL_PROPERTY = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCrlContext: PCCRL_CONTEXT,
        dwPropId: DWORD,
        dwFlags: DWORD,
        pvData: *const ::std::os::raw::c_void,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_READ_CTL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pStoreCtlContext: PCCTL_CONTEXT,
        dwFlags: DWORD,
        ppProvCtlContext: *mut PCCTL_CONTEXT,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_WRITE_CTL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCtlContext: PCCTL_CONTEXT,
        dwFlags: DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_DELETE_CTL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCtlContext: PCCTL_CONTEXT,
        dwFlags: DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_SET_CTL_PROPERTY = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCtlContext: PCCTL_CONTEXT,
        dwPropId: DWORD,
        dwFlags: DWORD,
        pvData: *const ::std::os::raw::c_void,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_CONTROL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        dwFlags: DWORD,
        dwCtrlType: DWORD,
        pvCtrlPara: *const ::std::os::raw::c_void,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_STORE_PROV_FIND_INFO {
    pub cbSize: DWORD,
    pub dwMsgAndCertEncodingType: DWORD,
    pub dwFindFlags: DWORD,
    pub dwFindType: DWORD,
    pub pvFindPara: *const ::std::os::raw::c_void,
}
pub type CERT_STORE_PROV_FIND_INFO = _CERT_STORE_PROV_FIND_INFO;
pub type PCCERT_STORE_PROV_FIND_INFO = *const CERT_STORE_PROV_FIND_INFO;
pub type PFN_CERT_STORE_PROV_FIND_CERT = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pFindInfo: PCCERT_STORE_PROV_FIND_INFO,
        pPrevCertContext: PCCERT_CONTEXT,
        dwFlags: DWORD,
        ppvStoreProvFindInfo: *mut *mut ::std::os::raw::c_void,
        ppProvCertContext: *mut PCCERT_CONTEXT,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_FREE_FIND_CERT = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCertContext: PCCERT_CONTEXT,
        pvStoreProvFindInfo: *mut ::std::os::raw::c_void,
        dwFlags: DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_GET_CERT_PROPERTY = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCertContext: PCCERT_CONTEXT,
        dwPropId: DWORD,
        dwFlags: DWORD,
        pvData: *mut ::std::os::raw::c_void,
        pcbData: *mut DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_FIND_CRL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pFindInfo: PCCERT_STORE_PROV_FIND_INFO,
        pPrevCrlContext: PCCRL_CONTEXT,
        dwFlags: DWORD,
        ppvStoreProvFindInfo: *mut *mut ::std::os::raw::c_void,
        ppProvCrlContext: *mut PCCRL_CONTEXT,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_FREE_FIND_CRL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCrlContext: PCCRL_CONTEXT,
        pvStoreProvFindInfo: *mut ::std::os::raw::c_void,
        dwFlags: DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_GET_CRL_PROPERTY = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCrlContext: PCCRL_CONTEXT,
        dwPropId: DWORD,
        dwFlags: DWORD,
        pvData: *mut ::std::os::raw::c_void,
        pcbData: *mut DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_FIND_CTL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pFindInfo: PCCERT_STORE_PROV_FIND_INFO,
        pPrevCtlContext: PCCTL_CONTEXT,
        dwFlags: DWORD,
        ppvStoreProvFindInfo: *mut *mut ::std::os::raw::c_void,
        ppProvCtlContext: *mut PCCTL_CONTEXT,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_FREE_FIND_CTL = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCtlContext: PCCTL_CONTEXT,
        pvStoreProvFindInfo: *mut ::std::os::raw::c_void,
        dwFlags: DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_STORE_PROV_GET_CTL_PROPERTY = ::std::option::Option<
    unsafe extern "C" fn(
        hStoreProv: HCERTSTOREPROV,
        pCtlContext: PCCTL_CONTEXT,
        dwPropId: DWORD,
        dwFlags: DWORD,
        pvData: *mut ::std::os::raw::c_void,
        pcbData: *mut DWORD,
    ) -> BOOL,
>;
pub type PFN_CERT_CREATE_CONTEXT_SORT_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        cbTotalEncoded: DWORD,
        cbRemainEncoded: DWORD,
        cEntry: DWORD,
        pvSort: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_SYSTEM_STORE_INFO {
    pub cbSize: DWORD,
}
pub type PCERT_SYSTEM_STORE_INFO = *mut _CERT_SYSTEM_STORE_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_PHYSICAL_STORE_INFO {
    pub cbSize: DWORD,
    pub pszOpenStoreProvider: LPSTR,
    pub dwOpenEncodingType: DWORD,
    pub dwOpenFlags: DWORD,
    pub OpenParameters: CRYPT_DATA_BLOB,
    pub dwFlags: DWORD,
    pub dwPriority: DWORD,
}
pub type PCERT_PHYSICAL_STORE_INFO = *mut _CERT_PHYSICAL_STORE_INFO;
pub type PFN_CERT_ENUM_SYSTEM_STORE_LOCATION = ::std::option::Option<
    unsafe extern "C" fn(
        pwszStoreLocation: LPCWSTR,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
        pvArg: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
pub type PFN_CERT_ENUM_SYSTEM_STORE = ::std::option::Option<
    unsafe extern "C" fn(
        pvSystemStore: *const ::std::os::raw::c_void,
        dwFlags: DWORD,
        pStoreInfo: PCERT_SYSTEM_STORE_INFO,
        pvReserved: *mut ::std::os::raw::c_void,
        pvArg: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
pub type PFN_CERT_ENUM_PHYSICAL_STORE = ::std::option::Option<
    unsafe extern "C" fn(
        pvSystemStore: *const ::std::os::raw::c_void,
        dwFlags: DWORD,
        pwszStoreName: LPCWSTR,
        pStoreInfo: PCERT_PHYSICAL_STORE_INFO,
        pvReserved: *mut ::std::os::raw::c_void,
        pvArg: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_REVOCATION_CRL_INFO {
    pub cbSize: DWORD,
    pub pBaseCrlContext: PCCRL_CONTEXT,
    pub pDeltaCrlContext: PCCRL_CONTEXT,
    pub pCrlEntry: PCRL_ENTRY,
    pub fDeltaCrlEntry: BOOL,
}
pub type PCERT_REVOCATION_CRL_INFO = *mut _CERT_REVOCATION_CRL_INFO;
pub type PFN_CRYPT_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        dwCertEncodingType: DWORD,
        pSignatureAlgorithm: PCRYPT_ALGORITHM_IDENTIFIER,
        ppvDecodedSignPara: *mut *mut ::std::os::raw::c_void,
        ppwszCNGHashAlgid: *mut LPWSTR,
    ) -> BOOL,
>;
pub type PFN_CRYPT_SIGN_AND_ENCODE_HASH_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        hKey: NCRYPT_KEY_HANDLE,
        dwCertEncodingType: DWORD,
        pSignatureAlgorithm: PCRYPT_ALGORITHM_IDENTIFIER,
        pvDecodedSignPara: *mut ::std::os::raw::c_void,
        pwszCNGPubKeyAlgid: LPCWSTR,
        pwszCNGHashAlgid: LPCWSTR,
        pbComputedHash: *mut BYTE,
        cbComputedHash: DWORD,
        pbSignature: *mut BYTE,
        pcbSignature: *mut DWORD,
    ) -> BOOL,
>;
pub type PFN_CRYPT_VERIFY_ENCODED_SIGNATURE_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        dwCertEncodingType: DWORD,
        pPubKeyInfo: PCERT_PUBLIC_KEY_INFO,
        pSignatureAlgorithm: PCRYPT_ALGORITHM_IDENTIFIER,
        pvDecodedSignPara: *mut ::std::os::raw::c_void,
        pwszCNGPubKeyAlgid: LPCWSTR,
        pwszCNGHashAlgid: LPCWSTR,
        pbComputedHash: *mut BYTE,
        cbComputedHash: DWORD,
        pbSignature: *mut BYTE,
        cbSignature: DWORD,
    ) -> BOOL,
>;
pub type PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        hNCryptKey: NCRYPT_KEY_HANDLE,
        dwCertEncodingType: DWORD,
        pszPublicKeyObjId: LPSTR,
        dwFlags: DWORD,
        pvAuxInfo: *mut ::std::os::raw::c_void,
        pInfo: PCERT_PUBLIC_KEY_INFO,
        pcbInfo: *mut DWORD,
    ) -> BOOL,
>;
pub type PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        hBCryptKey: BCRYPT_KEY_HANDLE,
        dwCertEncodingType: DWORD,
        pszPublicKeyObjId: LPSTR,
        dwFlags: DWORD,
        pvAuxInfo: *mut ::std::os::raw::c_void,
        pInfo: PCERT_PUBLIC_KEY_INFO,
        pcbInfo: *mut DWORD,
    ) -> BOOL,
>;
pub type PFN_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        dwCertEncodingType: DWORD,
        pInfo: PCERT_PUBLIC_KEY_INFO,
        dwFlags: DWORD,
        pvAuxInfo: *mut ::std::os::raw::c_void,
        phKey: *mut BCRYPT_KEY_HANDLE,
    ) -> BOOL,
>;
pub type PFN_IMPORT_PRIV_KEY_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        hCryptProv: HCRYPTPROV,
        pPrivateKeyInfo: *mut CRYPT_PRIVATE_KEY_INFO,
        dwFlags: DWORD,
        pvAuxInfo: *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
pub type PFN_EXPORT_PRIV_KEY_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        hCryptProv: HCRYPTPROV,
        dwKeySpec: DWORD,
        pszPrivateKeyObjId: LPSTR,
        dwFlags: DWORD,
        pvAuxInfo: *mut ::std::os::raw::c_void,
        pPrivateKeyInfo: *mut CRYPT_PRIVATE_KEY_INFO,
        pcbPrivateKeyInfo: *mut DWORD,
    ) -> BOOL,
>;
pub type PFN_CRYPT_GET_SIGNER_CERTIFICATE = ::std::option::Option<
    unsafe extern "C" fn(
        pvGetArg: *mut ::std::os::raw::c_void,
        dwCertEncodingType: DWORD,
        pSignerId: PCERT_INFO,
        hMsgCertStore: HCERTSTORE,
    ) -> PCCERT_CONTEXT,
>;
pub type HCRYPTASYNC = HANDLE;
pub type PFN_CRYPT_ASYNC_PARAM_FREE_FUNC =
    ::std::option::Option<unsafe extern "C" fn(pszParamOid: LPSTR, pvParam: LPVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_BLOB_ARRAY {
    pub cBlob: DWORD,
    pub rgBlob: PCRYPT_DATA_BLOB,
}
pub type PCRYPT_BLOB_ARRAY = *mut _CRYPT_BLOB_ARRAY;
pub type PFN_FREE_ENCODED_OBJECT_FUNC = ::std::option::Option<
    unsafe extern "C" fn(pszObjectOid: LPCSTR, pObject: PCRYPT_BLOB_ARRAY, pvFreeContext: LPVOID),
>;
pub type PFN_CRYPT_CANCEL_RETRIEVAL = ::std::option::Option<
    unsafe extern "C" fn(dwFlags: DWORD, pvArg: *mut ::std::os::raw::c_void) -> BOOL,
>;
pub type PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pvCompletion: LPVOID,
        dwCompletionCode: DWORD,
        pszUrl: LPCSTR,
        pszObjectOid: LPSTR,
        pvObject: LPVOID,
    ),
>;
pub type PFN_CANCEL_ASYNC_RETRIEVAL_FUNC =
    ::std::option::Option<unsafe extern "C" fn(hAsyncRetrieve: HCRYPTASYNC) -> BOOL>;
pub type PFN_CRYPT_ENUM_KEYID_PROP = ::std::option::Option<
    unsafe extern "C" fn(
        pKeyIdentifier: *const CRYPT_HASH_BLOB,
        dwFlags: DWORD,
        pvReserved: *mut ::std::os::raw::c_void,
        pvArg: *mut ::std::os::raw::c_void,
        cProp: DWORD,
        rgdwPropId: *mut DWORD,
        rgpvData: *mut *mut ::std::os::raw::c_void,
        rgcbData: *mut DWORD,
    ) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_TRUST_STATUS {
    pub dwErrorStatus: DWORD,
    pub dwInfoStatus: DWORD,
}
pub type CERT_TRUST_STATUS = _CERT_TRUST_STATUS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_REVOCATION_INFO {
    pub cbSize: DWORD,
    pub dwRevocationResult: DWORD,
    pub pszRevocationOid: LPCSTR,
    pub pvOidSpecificInfo: LPVOID,
    pub fHasFreshnessTime: BOOL,
    pub dwFreshnessTime: DWORD,
    pub pCrlInfo: PCERT_REVOCATION_CRL_INFO,
}
pub type PCERT_REVOCATION_INFO = *mut _CERT_REVOCATION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_TRUST_LIST_INFO {
    pub cbSize: DWORD,
    pub pCtlEntry: PCTL_ENTRY,
    pub pCtlContext: PCCTL_CONTEXT,
}
pub type PCERT_TRUST_LIST_INFO = *mut _CERT_TRUST_LIST_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_CHAIN_ELEMENT {
    pub cbSize: DWORD,
    pub pCertContext: PCCERT_CONTEXT,
    pub TrustStatus: CERT_TRUST_STATUS,
    pub pRevocationInfo: PCERT_REVOCATION_INFO,
    pub pIssuanceUsage: PCERT_ENHKEY_USAGE,
    pub pApplicationUsage: PCERT_ENHKEY_USAGE,
    pub pwszExtendedErrorInfo: LPCWSTR,
}
pub type PCERT_CHAIN_ELEMENT = *mut _CERT_CHAIN_ELEMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_SIMPLE_CHAIN {
    pub cbSize: DWORD,
    pub TrustStatus: CERT_TRUST_STATUS,
    pub cElement: DWORD,
    pub rgpElement: *mut PCERT_CHAIN_ELEMENT,
    pub pTrustListInfo: PCERT_TRUST_LIST_INFO,
    pub fHasRevocationFreshnessTime: BOOL,
    pub dwRevocationFreshnessTime: DWORD,
}
pub type PCERT_SIMPLE_CHAIN = *mut _CERT_SIMPLE_CHAIN;
pub type CERT_CHAIN_CONTEXT = _CERT_CHAIN_CONTEXT;
pub type PCCERT_CHAIN_CONTEXT = *const CERT_CHAIN_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_CHAIN_CONTEXT {
    pub cbSize: DWORD,
    pub TrustStatus: CERT_TRUST_STATUS,
    pub cChain: DWORD,
    pub rgpChain: *mut PCERT_SIMPLE_CHAIN,
    pub cLowerQualityChainContext: DWORD,
    pub rgpLowerQualityChainContext: *mut PCCERT_CHAIN_CONTEXT,
    pub fHasRevocationFreshnessTime: BOOL,
    pub dwRevocationFreshnessTime: DWORD,
    pub dwCreateFlags: DWORD,
    pub ChainId: GUID,
}
pub type PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(pCert: PCCERT_CONTEXT, pvFindArg: *mut ::std::os::raw::c_void) -> BOOL,
>;
extern "C" {
    pub fn PFXImportCertStore(
        pPFX: *mut CRYPT_DATA_BLOB,
        szPassword: LPCWSTR,
        dwFlags: DWORD,
    ) -> HCERTSTORE;
}
extern "C" {
    pub fn PFXIsPFXBlob(pPFX: *mut CRYPT_DATA_BLOB) -> BOOL;
}
extern "C" {
    pub fn PFXVerifyPassword(
        pPFX: *mut CRYPT_DATA_BLOB,
        szPassword: LPCWSTR,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn PFXExportCertStoreEx(
        hStore: HCERTSTORE,
        pPFX: *mut CRYPT_DATA_BLOB,
        szPassword: LPCWSTR,
        pvPara: *mut ::std::os::raw::c_void,
        dwFlags: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn PFXExportCertStore(
        hStore: HCERTSTORE,
        pPFX: *mut CRYPT_DATA_BLOB,
        szPassword: LPCWSTR,
        dwFlags: DWORD,
    ) -> BOOL;
}
pub type CERT_SERVER_OCSP_RESPONSE_CONTEXT = _CERT_SERVER_OCSP_RESPONSE_CONTEXT;
pub type PCCERT_SERVER_OCSP_RESPONSE_CONTEXT = *const CERT_SERVER_OCSP_RESPONSE_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CERT_SERVER_OCSP_RESPONSE_CONTEXT {
    pub cbSize: DWORD,
    pub pbEncodedOcspResponse: *mut BYTE,
    pub cbEncodedOcspResponse: DWORD,
}
pub type PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        pChainContext: PCCERT_CHAIN_CONTEXT,
        pServerOcspResponseContext: PCCERT_SERVER_OCSP_RESPONSE_CONTEXT,
        pNewCrlContext: PCCRL_CONTEXT,
        pPrevCrlContext: PCCRL_CONTEXT,
        pvArg: PVOID,
        dwWriteOcspFileError: DWORD,
    ),
>;
pub type PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH = ::std::option::Option<
    unsafe extern "C" fn(
        pContext: LPVOID,
        rgIdentifierOrNameList: *mut PCERT_NAME_BLOB,
        dwIdentifierOrNameListCount: DWORD,
    ) -> BOOL,
>;
pub type PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET = ::std::option::Option<
    unsafe extern "C" fn(
        pPluginContext: LPVOID,
        pIdentifier: PCRYPT_DATA_BLOB,
        dwNameType: DWORD,
        pNameBlob: PCERT_NAME_BLOB,
        ppbContent: *mut PBYTE,
        pcbContent: *mut DWORD,
        ppwszPassword: *mut PCWSTR,
        ppIdentifier: *mut PCRYPT_DATA_BLOB,
    ) -> BOOL,
>;
pub type PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE =
    ::std::option::Option<unsafe extern "C" fn(dwReason: DWORD, pPluginContext: LPVOID)>;
pub type PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD =
    ::std::option::Option<unsafe extern "C" fn(pPluginContext: LPVOID, pwszPassword: PCWSTR)>;
pub type PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE =
    ::std::option::Option<unsafe extern "C" fn(pPluginContext: LPVOID, pbData: PBYTE)>;
pub type PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER = ::std::option::Option<
    unsafe extern "C" fn(pPluginContext: LPVOID, pIdentifier: PCRYPT_DATA_BLOB),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE {
    pub cbSize: DWORD,
    pub pfnGet: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET,
    pub pfnRelease: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE,
    pub pfnFreePassword: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD,
    pub pfnFree: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE,
    pub pfnFreeIdentifier: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER,
}
pub type PCRYPT_OBJECT_LOCATOR_PROVIDER_TABLE = *mut _CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE;
pub type PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_INITIALIZE = ::std::option::Option<
    unsafe extern "C" fn(
        pfnFlush: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH,
        pContext: LPVOID,
        pdwExpectedObjectCount: *mut DWORD,
        ppFuncTable: *mut PCRYPT_OBJECT_LOCATOR_PROVIDER_TABLE,
        ppPluginContext: *mut *mut ::std::os::raw::c_void,
    ) -> BOOL,
>;
pub type PFN_CERT_IS_WEAK_HASH = ::std::option::Option<
    unsafe extern "C" fn(
        dwHashUseType: DWORD,
        pwszCNGHashAlgid: LPCWSTR,
        dwChainFlags: DWORD,
        pSignerChainContext: PCCERT_CHAIN_CONTEXT,
        pTimeStamp: LPFILETIME,
        pwszFileName: LPCWSTR,
    ) -> BOOL,
>;
pub type byte = ::std::os::raw::c_uchar;
pub type cs_byte = byte;
pub type PFORMAT_STRING = *const ::std::os::raw::c_uchar;
pub const XLAT_SIDE_XLAT_SERVER: XLAT_SIDE = 1;
pub const XLAT_SIDE_XLAT_CLIENT: XLAT_SIDE = 2;
pub type XLAT_SIDE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FULL_PTR_XLAT_TABLES {
    pub RefIdToPointer: *mut ::std::os::raw::c_void,
    pub PointerToRefId: *mut ::std::os::raw::c_void,
    pub NextRefId: ::std::os::raw::c_ulong,
    pub XlatSide: XLAT_SIDE,
}
pub type PFULL_PTR_XLAT_TABLES = *mut _FULL_PTR_XLAT_TABLES;
pub type OLECHAR = WCHAR;
pub type LPOLESTR = *mut OLECHAR;
pub type LPCOLESTR = *const OLECHAR;
pub type DOUBLE = f64;
pub type SCODE = LONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagBLOB {
    pub cbSize: ULONG,
    pub pBlobData: *mut BYTE,
}
pub type BLOB = tagBLOB;
pub type DATE = f64;
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagCY {
    pub __bindgen_anon_1: tagCY__bindgen_ty_1,
    pub int64: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCY__bindgen_ty_1 {
    pub Lo: ULONG,
    pub Hi: LONG,
}
pub type CY = tagCY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagDEC {
    pub wReserved: USHORT,
    pub __bindgen_anon_1: tagDEC__bindgen_ty_1,
    pub Hi32: ULONG,
    pub __bindgen_anon_2: tagDEC__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagDEC__bindgen_ty_1 {
    pub __bindgen_anon_1: tagDEC__bindgen_ty_1__bindgen_ty_1,
    pub signscale: USHORT,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDEC__bindgen_ty_1__bindgen_ty_1 {
    pub scale: BYTE,
    pub sign: BYTE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagDEC__bindgen_ty_2 {
    pub __bindgen_anon_1: tagDEC__bindgen_ty_2__bindgen_ty_1,
    pub Lo64: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDEC__bindgen_ty_2__bindgen_ty_1 {
    pub Lo32: ULONG,
    pub Mid32: ULONG,
}
pub type DECIMAL = tagDEC;
pub type BSTR = *mut OLECHAR;
pub type VARIANT_BOOL = ::std::os::raw::c_short;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagBSTRBLOB {
    pub cbSize: ULONG,
    pub pData: *mut BYTE,
}
pub type BSTRBLOB = tagBSTRBLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCLIPDATA {
    pub cbSize: ULONG,
    pub ulClipFmt: LONG,
    pub pClipData: *mut BYTE,
}
pub type CLIPDATA = tagCLIPDATA;
pub type VARTYPE = ::std::os::raw::c_ushort;
pub const _MEDIA_TYPE_Unknown: _MEDIA_TYPE = 0;
pub const _MEDIA_TYPE_F5_1Pt2_512: _MEDIA_TYPE = 1;
pub const _MEDIA_TYPE_F3_1Pt44_512: _MEDIA_TYPE = 2;
pub const _MEDIA_TYPE_F3_2Pt88_512: _MEDIA_TYPE = 3;
pub const _MEDIA_TYPE_F3_20Pt8_512: _MEDIA_TYPE = 4;
pub const _MEDIA_TYPE_F3_720_512: _MEDIA_TYPE = 5;
pub const _MEDIA_TYPE_F5_360_512: _MEDIA_TYPE = 6;
pub const _MEDIA_TYPE_F5_320_512: _MEDIA_TYPE = 7;
pub const _MEDIA_TYPE_F5_320_1024: _MEDIA_TYPE = 8;
pub const _MEDIA_TYPE_F5_180_512: _MEDIA_TYPE = 9;
pub const _MEDIA_TYPE_F5_160_512: _MEDIA_TYPE = 10;
pub const _MEDIA_TYPE_RemovableMedia: _MEDIA_TYPE = 11;
pub const _MEDIA_TYPE_FixedMedia: _MEDIA_TYPE = 12;
pub const _MEDIA_TYPE_F3_120M_512: _MEDIA_TYPE = 13;
pub const _MEDIA_TYPE_F3_640_512: _MEDIA_TYPE = 14;
pub const _MEDIA_TYPE_F5_640_512: _MEDIA_TYPE = 15;
pub const _MEDIA_TYPE_F5_720_512: _MEDIA_TYPE = 16;
pub const _MEDIA_TYPE_F3_1Pt2_512: _MEDIA_TYPE = 17;
pub const _MEDIA_TYPE_F3_1Pt23_1024: _MEDIA_TYPE = 18;
pub const _MEDIA_TYPE_F5_1Pt23_1024: _MEDIA_TYPE = 19;
pub const _MEDIA_TYPE_F3_128Mb_512: _MEDIA_TYPE = 20;
pub const _MEDIA_TYPE_F3_230Mb_512: _MEDIA_TYPE = 21;
pub const _MEDIA_TYPE_F8_256_128: _MEDIA_TYPE = 22;
pub const _MEDIA_TYPE_F3_200Mb_512: _MEDIA_TYPE = 23;
pub const _MEDIA_TYPE_F3_240M_512: _MEDIA_TYPE = 24;
pub const _MEDIA_TYPE_F3_32M_512: _MEDIA_TYPE = 25;
pub type _MEDIA_TYPE = ::std::os::raw::c_int;
pub use self::_MEDIA_TYPE as MEDIA_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FORMAT_PARAMETERS {
    pub MediaType: MEDIA_TYPE,
    pub StartCylinderNumber: DWORD,
    pub EndCylinderNumber: DWORD,
    pub StartHeadNumber: DWORD,
    pub EndHeadNumber: DWORD,
}
pub type PFORMAT_PARAMETERS = *mut _FORMAT_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FORMAT_EX_PARAMETERS {
    pub MediaType: MEDIA_TYPE,
    pub StartCylinderNumber: DWORD,
    pub EndCylinderNumber: DWORD,
    pub StartHeadNumber: DWORD,
    pub EndHeadNumber: DWORD,
    pub FormatGapLength: WORD,
    pub SectorsPerTrack: WORD,
    pub SectorNumber: [WORD; 1usize],
}
pub type PFORMAT_EX_PARAMETERS = *mut _FORMAT_EX_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_QUERY_FAT_BPB_BUFFER {
    pub First0x24BytesOfBootSector: [BYTE; 36usize],
}
pub type PFSCTL_QUERY_FAT_BPB_BUFFER = *mut _FSCTL_QUERY_FAT_BPB_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FIND_BY_SID_DATA {
    pub Restart: DWORD,
    pub Sid: SID,
}
pub type PFIND_BY_SID_DATA = *mut FIND_BY_SID_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FIND_BY_SID_OUTPUT {
    pub NextEntryOffset: DWORD,
    pub FileIndex: DWORD,
    pub FileNameLength: DWORD,
    pub FileName: [WCHAR; 1usize],
}
pub type PFIND_BY_SID_OUTPUT = *mut FIND_BY_SID_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PREFETCH {
    pub Type: DWORD,
    pub Count: DWORD,
    pub Prefetch: [DWORDLONG; 1usize],
}
pub type PFILE_PREFETCH = *mut _FILE_PREFETCH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PREFETCH_EX {
    pub Type: DWORD,
    pub Count: DWORD,
    pub Context: PVOID,
    pub Prefetch: [DWORDLONG; 1usize],
}
pub type PFILE_PREFETCH_EX = *mut _FILE_PREFETCH_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILESYSTEM_STATISTICS {
    pub FileSystemType: WORD,
    pub Version: WORD,
    pub SizeOfCompleteStructure: DWORD,
    pub UserFileReads: DWORD,
    pub UserFileReadBytes: DWORD,
    pub UserDiskReads: DWORD,
    pub UserFileWrites: DWORD,
    pub UserFileWriteBytes: DWORD,
    pub UserDiskWrites: DWORD,
    pub MetaDataReads: DWORD,
    pub MetaDataReadBytes: DWORD,
    pub MetaDataDiskReads: DWORD,
    pub MetaDataWrites: DWORD,
    pub MetaDataWriteBytes: DWORD,
    pub MetaDataDiskWrites: DWORD,
}
pub type PFILESYSTEM_STATISTICS = *mut _FILESYSTEM_STATISTICS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FAT_STATISTICS {
    pub CreateHits: DWORD,
    pub SuccessfulCreates: DWORD,
    pub FailedCreates: DWORD,
    pub NonCachedReads: DWORD,
    pub NonCachedReadBytes: DWORD,
    pub NonCachedWrites: DWORD,
    pub NonCachedWriteBytes: DWORD,
    pub NonCachedDiskReads: DWORD,
    pub NonCachedDiskWrites: DWORD,
}
pub type PFAT_STATISTICS = *mut _FAT_STATISTICS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILESYSTEM_STATISTICS_EX {
    pub FileSystemType: WORD,
    pub Version: WORD,
    pub SizeOfCompleteStructure: DWORD,
    pub UserFileReads: DWORDLONG,
    pub UserFileReadBytes: DWORDLONG,
    pub UserDiskReads: DWORDLONG,
    pub UserFileWrites: DWORDLONG,
    pub UserFileWriteBytes: DWORDLONG,
    pub UserDiskWrites: DWORDLONG,
    pub MetaDataReads: DWORDLONG,
    pub MetaDataReadBytes: DWORDLONG,
    pub MetaDataDiskReads: DWORDLONG,
    pub MetaDataWrites: DWORDLONG,
    pub MetaDataWriteBytes: DWORDLONG,
    pub MetaDataDiskWrites: DWORDLONG,
}
pub type PFILESYSTEM_STATISTICS_EX = *mut _FILESYSTEM_STATISTICS_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_OBJECTID_BUFFER {
    pub ObjectId: [BYTE; 16usize],
    pub __bindgen_anon_1: _FILE_OBJECTID_BUFFER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_OBJECTID_BUFFER__bindgen_ty_1 {
    pub __bindgen_anon_1: _FILE_OBJECTID_BUFFER__bindgen_ty_1__bindgen_ty_1,
    pub ExtendedInfo: [BYTE; 48usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_OBJECTID_BUFFER__bindgen_ty_1__bindgen_ty_1 {
    pub BirthVolumeId: [BYTE; 16usize],
    pub BirthObjectId: [BYTE; 16usize],
    pub DomainId: [BYTE; 16usize],
}
pub type PFILE_OBJECTID_BUFFER = *mut _FILE_OBJECTID_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_SET_SPARSE_BUFFER {
    pub SetSparse: BOOLEAN,
}
pub type PFILE_SET_SPARSE_BUFFER = *mut _FILE_SET_SPARSE_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ZERO_DATA_INFORMATION {
    pub FileOffset: LARGE_INTEGER,
    pub BeyondFinalZero: LARGE_INTEGER,
}
pub type PFILE_ZERO_DATA_INFORMATION = *mut _FILE_ZERO_DATA_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ZERO_DATA_INFORMATION_EX {
    pub FileOffset: LARGE_INTEGER,
    pub BeyondFinalZero: LARGE_INTEGER,
    pub Flags: DWORD,
}
pub type PFILE_ZERO_DATA_INFORMATION_EX = *mut _FILE_ZERO_DATA_INFORMATION_EX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ALLOCATED_RANGE_BUFFER {
    pub FileOffset: LARGE_INTEGER,
    pub Length: LARGE_INTEGER,
}
pub type PFILE_ALLOCATED_RANGE_BUFFER = *mut _FILE_ALLOCATED_RANGE_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MAKE_COMPATIBLE_BUFFER {
    pub CloseDisc: BOOLEAN,
}
pub type PFILE_MAKE_COMPATIBLE_BUFFER = *mut _FILE_MAKE_COMPATIBLE_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_SET_DEFECT_MGMT_BUFFER {
    pub Disable: BOOLEAN,
}
pub type PFILE_SET_DEFECT_MGMT_BUFFER = *mut _FILE_SET_DEFECT_MGMT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_QUERY_SPARING_BUFFER {
    pub SparingUnitBytes: DWORD,
    pub SoftwareSparing: BOOLEAN,
    pub TotalSpareBlocks: DWORD,
    pub FreeSpareBlocks: DWORD,
}
pub type PFILE_QUERY_SPARING_BUFFER = *mut _FILE_QUERY_SPARING_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_QUERY_ON_DISK_VOL_INFO_BUFFER {
    pub DirectoryCount: LARGE_INTEGER,
    pub FileCount: LARGE_INTEGER,
    pub FsFormatMajVersion: WORD,
    pub FsFormatMinVersion: WORD,
    pub FsFormatName: [WCHAR; 12usize],
    pub FormatTime: LARGE_INTEGER,
    pub LastUpdateTime: LARGE_INTEGER,
    pub CopyrightInfo: [WCHAR; 34usize],
    pub AbstractInfo: [WCHAR; 34usize],
    pub FormattingImplementationInfo: [WCHAR; 34usize],
    pub LastModifyingImplementationInfo: [WCHAR; 34usize],
}
pub type PFILE_QUERY_ON_DISK_VOL_INFO_BUFFER = *mut _FILE_QUERY_ON_DISK_VOL_INFO_BUFFER;
pub type CLSN = DWORDLONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_INITIATE_REPAIR_OUTPUT_BUFFER {
    pub Hint1: DWORDLONG,
    pub Hint2: DWORDLONG,
    pub Clsn: CLSN,
    pub Status: DWORD,
}
pub type PFILE_INITIATE_REPAIR_OUTPUT_BUFFER = *mut _FILE_INITIATE_REPAIR_OUTPUT_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_PERSISTENT_VOLUME_INFORMATION {
    pub VolumeFlags: DWORD,
    pub FlagMask: DWORD,
    pub Version: DWORD,
    pub Reserved: DWORD,
}
pub type PFILE_FS_PERSISTENT_VOLUME_INFORMATION = *mut _FILE_FS_PERSISTENT_VOLUME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_SYSTEM_RECOGNITION_INFORMATION {
    pub FileSystem: [CHAR; 9usize],
}
pub type PFILE_SYSTEM_RECOGNITION_INFORMATION = *mut _FILE_SYSTEM_RECOGNITION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_TYPE_NOTIFICATION_INPUT {
    pub Flags: DWORD,
    pub NumFileTypeIDs: DWORD,
    pub FileTypeID: [GUID; 1usize],
}
pub type PFILE_TYPE_NOTIFICATION_INPUT = *mut _FILE_TYPE_NOTIFICATION_INPUT;
pub const _STORAGE_RESERVE_ID_StorageReserveIdNone: _STORAGE_RESERVE_ID = 0;
pub const _STORAGE_RESERVE_ID_StorageReserveIdHard: _STORAGE_RESERVE_ID = 1;
pub const _STORAGE_RESERVE_ID_StorageReserveIdSoft: _STORAGE_RESERVE_ID = 2;
pub const _STORAGE_RESERVE_ID_StorageReserveIdUpdateScratch: _STORAGE_RESERVE_ID = 3;
pub const _STORAGE_RESERVE_ID_StorageReserveIdMax: _STORAGE_RESERVE_ID = 4;
pub type _STORAGE_RESERVE_ID = ::std::os::raw::c_int;
pub use self::_STORAGE_RESERVE_ID as STORAGE_RESERVE_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LEVEL_TRIM_RANGE {
    pub Offset: DWORDLONG,
    pub Length: DWORDLONG,
}
pub type FILE_LEVEL_TRIM_RANGE = _FILE_LEVEL_TRIM_RANGE;
pub type PFILE_LEVEL_TRIM_RANGE = *mut _FILE_LEVEL_TRIM_RANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LEVEL_TRIM {
    pub Key: DWORD,
    pub NumRanges: DWORD,
    pub Ranges: [FILE_LEVEL_TRIM_RANGE; 1usize],
}
pub type PFILE_LEVEL_TRIM = *mut _FILE_LEVEL_TRIM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LEVEL_TRIM_OUTPUT {
    pub NumRangesProcessed: DWORD,
}
pub type PFILE_LEVEL_TRIM_OUTPUT = *mut _FILE_LEVEL_TRIM_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REFERENCE_RANGE {
    pub StartingFileReferenceNumber: DWORDLONG,
    pub EndingFileReferenceNumber: DWORDLONG,
}
pub type PFILE_REFERENCE_RANGE = *mut _FILE_REFERENCE_RANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LAYOUT_ENTRY {
    pub Version: DWORD,
    pub NextFileOffset: DWORD,
    pub Flags: DWORD,
    pub FileAttributes: DWORD,
    pub FileReferenceNumber: DWORDLONG,
    pub FirstNameOffset: DWORD,
    pub FirstStreamOffset: DWORD,
    pub ExtraInfoOffset: DWORD,
    pub ExtraInfoLength: DWORD,
}
pub type PFILE_LAYOUT_ENTRY = *mut _FILE_LAYOUT_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LAYOUT_NAME_ENTRY {
    pub NextNameOffset: DWORD,
    pub Flags: DWORD,
    pub ParentFileReferenceNumber: DWORDLONG,
    pub FileNameLength: DWORD,
    pub Reserved: DWORD,
    pub FileName: [WCHAR; 1usize],
}
pub type PFILE_LAYOUT_NAME_ENTRY = *mut _FILE_LAYOUT_NAME_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_LAYOUT_INFO_ENTRY {
    pub BasicInformation: _FILE_LAYOUT_INFO_ENTRY__bindgen_ty_1,
    pub OwnerId: DWORD,
    pub SecurityId: DWORD,
    pub Usn: USN,
    pub StorageReserveId: STORAGE_RESERVE_ID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_LAYOUT_INFO_ENTRY__bindgen_ty_1 {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub FileAttributes: DWORD,
}
pub type PFILE_LAYOUT_INFO_ENTRY = *mut _FILE_LAYOUT_INFO_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_GET_INTEGRITY_INFORMATION_BUFFER {
    pub ChecksumAlgorithm: WORD,
    pub Reserved: WORD,
    pub Flags: DWORD,
    pub ChecksumChunkSizeInBytes: DWORD,
    pub ClusterSizeInBytes: DWORD,
}
pub type PFSCTL_GET_INTEGRITY_INFORMATION_BUFFER = *mut _FSCTL_GET_INTEGRITY_INFORMATION_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER {
    pub ChecksumAlgorithm: WORD,
    pub Reserved: WORD,
    pub Flags: DWORD,
}
pub type PFSCTL_SET_INTEGRITY_INFORMATION_BUFFER = *mut _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX {
    pub EnableIntegrity: BYTE,
    pub KeepIntegrityStateUnchanged: BYTE,
    pub Reserved: WORD,
    pub Flags: DWORD,
    pub Version: BYTE,
    pub Reserved2: [BYTE; 7usize],
}
pub type PFSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX =
    *mut _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_OFFLOAD_READ_INPUT {
    pub Size: DWORD,
    pub Flags: DWORD,
    pub TokenTimeToLive: DWORD,
    pub Reserved: DWORD,
    pub FileOffset: DWORDLONG,
    pub CopyLength: DWORDLONG,
}
pub type PFSCTL_OFFLOAD_READ_INPUT = *mut _FSCTL_OFFLOAD_READ_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_OFFLOAD_READ_OUTPUT {
    pub Size: DWORD,
    pub Flags: DWORD,
    pub TransferLength: DWORDLONG,
    pub Token: [BYTE; 512usize],
}
pub type PFSCTL_OFFLOAD_READ_OUTPUT = *mut _FSCTL_OFFLOAD_READ_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_OFFLOAD_WRITE_INPUT {
    pub Size: DWORD,
    pub Flags: DWORD,
    pub FileOffset: DWORDLONG,
    pub CopyLength: DWORDLONG,
    pub TransferOffset: DWORDLONG,
    pub Token: [BYTE; 512usize],
}
pub type PFSCTL_OFFLOAD_WRITE_INPUT = *mut _FSCTL_OFFLOAD_WRITE_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_OFFLOAD_WRITE_OUTPUT {
    pub Size: DWORD,
    pub Flags: DWORD,
    pub LengthWritten: DWORDLONG,
}
pub type PFSCTL_OFFLOAD_WRITE_OUTPUT = *mut _FSCTL_OFFLOAD_WRITE_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REGION_INFO {
    pub FileOffset: LONGLONG,
    pub Length: LONGLONG,
    pub Usage: DWORD,
    pub Reserved: DWORD,
}
pub type FILE_REGION_INFO = _FILE_REGION_INFO;
pub type PFILE_REGION_INFO = *mut _FILE_REGION_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REGION_OUTPUT {
    pub Flags: DWORD,
    pub TotalRegionEntryCount: DWORD,
    pub RegionEntryCount: DWORD,
    pub Reserved: DWORD,
    pub Region: [FILE_REGION_INFO; 1usize],
}
pub type PFILE_REGION_OUTPUT = *mut _FILE_REGION_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REGION_INPUT {
    pub FileOffset: LONGLONG,
    pub Length: LONGLONG,
    pub DesiredUsage: DWORD,
}
pub type PFILE_REGION_INPUT = *mut _FILE_REGION_INPUT;
pub const _FILE_STORAGE_TIER_MEDIA_TYPE_FileStorageTierMediaTypeUnspecified:
    _FILE_STORAGE_TIER_MEDIA_TYPE = 0;
pub const _FILE_STORAGE_TIER_MEDIA_TYPE_FileStorageTierMediaTypeDisk:
    _FILE_STORAGE_TIER_MEDIA_TYPE = 1;
pub const _FILE_STORAGE_TIER_MEDIA_TYPE_FileStorageTierMediaTypeSsd: _FILE_STORAGE_TIER_MEDIA_TYPE =
    2;
pub const _FILE_STORAGE_TIER_MEDIA_TYPE_FileStorageTierMediaTypeScm: _FILE_STORAGE_TIER_MEDIA_TYPE =
    4;
pub const _FILE_STORAGE_TIER_MEDIA_TYPE_FileStorageTierMediaTypeMax: _FILE_STORAGE_TIER_MEDIA_TYPE =
    5;
pub type _FILE_STORAGE_TIER_MEDIA_TYPE = ::std::os::raw::c_int;
pub use self::_FILE_STORAGE_TIER_MEDIA_TYPE as FILE_STORAGE_TIER_MEDIA_TYPE;
pub type PFILE_STORAGE_TIER_MEDIA_TYPE = *mut _FILE_STORAGE_TIER_MEDIA_TYPE;
pub const _FILE_STORAGE_TIER_CLASS_FileStorageTierClassUnspecified: _FILE_STORAGE_TIER_CLASS = 0;
pub const _FILE_STORAGE_TIER_CLASS_FileStorageTierClassCapacity: _FILE_STORAGE_TIER_CLASS = 1;
pub const _FILE_STORAGE_TIER_CLASS_FileStorageTierClassPerformance: _FILE_STORAGE_TIER_CLASS = 2;
pub const _FILE_STORAGE_TIER_CLASS_FileStorageTierClassMax: _FILE_STORAGE_TIER_CLASS = 3;
pub type _FILE_STORAGE_TIER_CLASS = ::std::os::raw::c_int;
pub use self::_FILE_STORAGE_TIER_CLASS as FILE_STORAGE_TIER_CLASS;
pub type PFILE_STORAGE_TIER_CLASS = *mut _FILE_STORAGE_TIER_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_STORAGE_TIER {
    pub Id: GUID,
    pub Name: [WCHAR; 256usize],
    pub Description: [WCHAR; 256usize],
    pub Flags: DWORDLONG,
    pub ProvisionedCapacity: DWORDLONG,
    pub MediaType: FILE_STORAGE_TIER_MEDIA_TYPE,
    pub Class: FILE_STORAGE_TIER_CLASS,
}
pub type FILE_STORAGE_TIER = _FILE_STORAGE_TIER;
pub type PFILE_STORAGE_TIER = *mut _FILE_STORAGE_TIER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_QUERY_STORAGE_CLASSES_OUTPUT {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Flags: DWORD,
    pub TotalNumberOfTiers: DWORD,
    pub NumberOfTiersReturned: DWORD,
    pub Tiers: [FILE_STORAGE_TIER; 1usize],
}
pub type PFSCTL_QUERY_STORAGE_CLASSES_OUTPUT = *mut _FSCTL_QUERY_STORAGE_CLASSES_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_QUERY_REGION_INFO_INPUT {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Flags: DWORD,
    pub NumberOfTierIds: DWORD,
    pub TierIds: [GUID; 1usize],
}
pub type PFSCTL_QUERY_REGION_INFO_INPUT = *mut _FSCTL_QUERY_REGION_INFO_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_STORAGE_TIER_REGION {
    pub TierId: GUID,
    pub Offset: DWORDLONG,
    pub Length: DWORDLONG,
}
pub type FILE_STORAGE_TIER_REGION = _FILE_STORAGE_TIER_REGION;
pub type PFILE_STORAGE_TIER_REGION = *mut _FILE_STORAGE_TIER_REGION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSCTL_QUERY_REGION_INFO_OUTPUT {
    pub Version: DWORD,
    pub Size: DWORD,
    pub Flags: DWORD,
    pub Reserved: DWORD,
    pub Alignment: DWORDLONG,
    pub TotalNumberOfRegions: DWORD,
    pub NumberOfRegionsReturned: DWORD,
    pub Regions: [FILE_STORAGE_TIER_REGION; 1usize],
}
pub type PFSCTL_QUERY_REGION_INFO_OUTPUT = *mut _FSCTL_QUERY_REGION_INFO_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_DESIRED_STORAGE_CLASS_INFORMATION {
    pub Class: FILE_STORAGE_TIER_CLASS,
    pub Flags: DWORD,
}
pub type PFILE_DESIRED_STORAGE_CLASS_INFORMATION = *mut _FILE_DESIRED_STORAGE_CLASS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PROVIDER_EXTERNAL_INFO_V0 {
    pub Version: DWORD,
    pub Algorithm: DWORD,
}
pub type PFILE_PROVIDER_EXTERNAL_INFO_V0 = *mut _FILE_PROVIDER_EXTERNAL_INFO_V0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PROVIDER_EXTERNAL_INFO_V1 {
    pub Version: DWORD,
    pub Algorithm: DWORD,
    pub Flags: DWORD,
}
pub type PFILE_PROVIDER_EXTERNAL_INFO_V1 = *mut _FILE_PROVIDER_EXTERNAL_INFO_V1;
pub type PFILE_PROVIDER_EXTERNAL_INFO = PFILE_PROVIDER_EXTERNAL_INFO_V1;
pub const _FS_BPIO_OPERATIONS_FS_BPIO_OP_ENABLE: _FS_BPIO_OPERATIONS = 1;
pub const _FS_BPIO_OPERATIONS_FS_BPIO_OP_DISABLE: _FS_BPIO_OPERATIONS = 2;
pub const _FS_BPIO_OPERATIONS_FS_BPIO_OP_QUERY: _FS_BPIO_OPERATIONS = 3;
pub const _FS_BPIO_OPERATIONS_FS_BPIO_OP_VOLUME_STACK_PAUSE: _FS_BPIO_OPERATIONS = 4;
pub const _FS_BPIO_OPERATIONS_FS_BPIO_OP_VOLUME_STACK_RESUME: _FS_BPIO_OPERATIONS = 5;
pub const _FS_BPIO_OPERATIONS_FS_BPIO_OP_STREAM_PAUSE: _FS_BPIO_OPERATIONS = 6;
pub const _FS_BPIO_OPERATIONS_FS_BPIO_OP_STREAM_RESUME: _FS_BPIO_OPERATIONS = 7;
pub const _FS_BPIO_OPERATIONS_FS_BPIO_OP_GET_INFO: _FS_BPIO_OPERATIONS = 8;
pub const _FS_BPIO_OPERATIONS_FS_BPIO_OP_MAX_OPERATION: _FS_BPIO_OPERATIONS = 9;
pub type _FS_BPIO_OPERATIONS = ::std::os::raw::c_int;
pub use self::_FS_BPIO_OPERATIONS as FS_BPIO_OPERATIONS;
pub const _FS_BPIO_INFLAGS_FSBPIO_INFL_None: _FS_BPIO_INFLAGS = 0;
pub const _FS_BPIO_INFLAGS_FSBPIO_INFL_SKIP_STORAGE_STACK_QUERY: _FS_BPIO_INFLAGS = 1;
pub type _FS_BPIO_INFLAGS = ::std::os::raw::c_int;
pub use self::_FS_BPIO_INFLAGS as FS_BPIO_INFLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_BPIO_INPUT {
    pub Operation: FS_BPIO_OPERATIONS,
    pub InFlags: FS_BPIO_INFLAGS,
    pub Reserved1: DWORDLONG,
    pub Reserved2: DWORDLONG,
}
pub type PFS_BPIO_INPUT = *mut _FS_BPIO_INPUT;
pub const _FS_BPIO_OUTFLAGS_FSBPIO_OUTFL_None: _FS_BPIO_OUTFLAGS = 0;
pub const _FS_BPIO_OUTFLAGS_FSBPIO_OUTFL_VOLUME_STACK_BYPASS_PAUSED: _FS_BPIO_OUTFLAGS = 1;
pub const _FS_BPIO_OUTFLAGS_FSBPIO_OUTFL_STREAM_BYPASS_PAUSED: _FS_BPIO_OUTFLAGS = 2;
pub const _FS_BPIO_OUTFLAGS_FSBPIO_OUTFL_FILTER_ATTACH_BLOCKED: _FS_BPIO_OUTFLAGS = 4;
pub const _FS_BPIO_OUTFLAGS_FSBPIO_OUTFL_COMPATIBLE_STORAGE_DRIVER: _FS_BPIO_OUTFLAGS = 8;
pub type _FS_BPIO_OUTFLAGS = ::std::os::raw::c_int;
pub use self::_FS_BPIO_OUTFLAGS as FS_BPIO_OUTFLAGS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_BPIO_RESULTS {
    pub OpStatus: DWORD,
    pub FailingDriverNameLen: WORD,
    pub FailingDriverName: [WCHAR; 32usize],
    pub FailureReasonLen: WORD,
    pub FailureReason: [WCHAR; 128usize],
}
pub type FS_BPIO_RESULTS = _FS_BPIO_RESULTS;
pub type PFS_BPIO_RESULTS = *mut _FS_BPIO_RESULTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FS_BPIO_INFO {
    pub ActiveBypassIoCount: DWORD,
    pub StorageDriverNameLen: WORD,
    pub StorageDriverName: [WCHAR; 32usize],
}
pub type FS_BPIO_INFO = _FS_BPIO_INFO;
pub type PFS_BPIO_INFO = *mut _FS_BPIO_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FS_BPIO_OUTPUT {
    pub Operation: FS_BPIO_OPERATIONS,
    pub OutFlags: FS_BPIO_OUTFLAGS,
    pub Reserved1: DWORDLONG,
    pub Reserved2: DWORDLONG,
    pub __bindgen_anon_1: _FS_BPIO_OUTPUT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FS_BPIO_OUTPUT__bindgen_ty_1 {
    pub Enable: FS_BPIO_RESULTS,
    pub Query: FS_BPIO_RESULTS,
    pub VolumeStackResume: FS_BPIO_RESULTS,
    pub StreamResume: FS_BPIO_RESULTS,
    pub GetInfo: FS_BPIO_INFO,
}
pub type PFS_BPIO_OUTPUT = *mut _FS_BPIO_OUTPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PSP {
    _unused: [u8; 0],
}
pub type HPROPSHEETPAGE = *mut _PSP;
pub type LPFNPSPCALLBACKA = ::std::option::Option<
    unsafe extern "C" fn(hwnd: HWND, uMsg: UINT, ppsp: *mut _PROPSHEETPAGEA) -> UINT,
>;
pub type LPFNPSPCALLBACKW = ::std::option::Option<
    unsafe extern "C" fn(hwnd: HWND, uMsg: UINT, ppsp: *mut _PROPSHEETPAGEW) -> UINT,
>;
pub type PROPSHEETPAGE_RESOURCE = LPCDLGTEMPLATE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROPSHEETPAGEA {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub hInstance: HINSTANCE,
    pub __bindgen_anon_1: _PROPSHEETPAGEA__bindgen_ty_1,
    pub __bindgen_anon_2: _PROPSHEETPAGEA__bindgen_ty_2,
    pub pszTitle: LPCSTR,
    pub pfnDlgProc: DLGPROC,
    pub lParam: LPARAM,
    pub pfnCallback: LPFNPSPCALLBACKA,
    pub pcRefParent: *mut UINT,
    pub pszHeaderTitle: LPCSTR,
    pub pszHeaderSubTitle: LPCSTR,
    pub hActCtx: HANDLE,
    pub __bindgen_anon_3: _PROPSHEETPAGEA__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEA__bindgen_ty_1 {
    pub pszTemplate: LPCSTR,
    pub pResource: PROPSHEETPAGE_RESOURCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEA__bindgen_ty_2 {
    pub hIcon: HICON,
    pub pszIcon: LPCSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEA__bindgen_ty_3 {
    pub hbmHeader: HBITMAP,
    pub pszbmHeader: LPCSTR,
}
pub type PROPSHEETPAGEA_V4 = _PROPSHEETPAGEA;
pub type LPCPROPSHEETPAGEA_V4 = *const PROPSHEETPAGEA_V4;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROPSHEETPAGEW {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub hInstance: HINSTANCE,
    pub __bindgen_anon_1: _PROPSHEETPAGEW__bindgen_ty_1,
    pub __bindgen_anon_2: _PROPSHEETPAGEW__bindgen_ty_2,
    pub pszTitle: LPCWSTR,
    pub pfnDlgProc: DLGPROC,
    pub lParam: LPARAM,
    pub pfnCallback: LPFNPSPCALLBACKW,
    pub pcRefParent: *mut UINT,
    pub pszHeaderTitle: LPCWSTR,
    pub pszHeaderSubTitle: LPCWSTR,
    pub hActCtx: HANDLE,
    pub __bindgen_anon_3: _PROPSHEETPAGEW__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEW__bindgen_ty_1 {
    pub pszTemplate: LPCWSTR,
    pub pResource: PROPSHEETPAGE_RESOURCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEW__bindgen_ty_2 {
    pub hIcon: HICON,
    pub pszIcon: LPCWSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETPAGEW__bindgen_ty_3 {
    pub hbmHeader: HBITMAP,
    pub pszbmHeader: LPCWSTR,
}
pub type PROPSHEETPAGEW_V4 = _PROPSHEETPAGEW;
pub type LPCPROPSHEETPAGEW_V4 = *const PROPSHEETPAGEW_V4;
pub type LPCPROPSHEETPAGEA = LPCPROPSHEETPAGEA_V4;
pub type LPCPROPSHEETPAGEW = LPCPROPSHEETPAGEW_V4;
pub type PFNPROPSHEETCALLBACK = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: LPARAM) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROPSHEETHEADERA_V2 {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub hwndParent: HWND,
    pub hInstance: HINSTANCE,
    pub __bindgen_anon_1: _PROPSHEETHEADERA_V2__bindgen_ty_1,
    pub pszCaption: LPCSTR,
    pub nPages: UINT,
    pub __bindgen_anon_2: _PROPSHEETHEADERA_V2__bindgen_ty_2,
    pub __bindgen_anon_3: _PROPSHEETHEADERA_V2__bindgen_ty_3,
    pub pfnCallback: PFNPROPSHEETCALLBACK,
    pub __bindgen_anon_4: _PROPSHEETHEADERA_V2__bindgen_ty_4,
    pub hplWatermark: HPALETTE,
    pub __bindgen_anon_5: _PROPSHEETHEADERA_V2__bindgen_ty_5,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERA_V2__bindgen_ty_1 {
    pub hIcon: HICON,
    pub pszIcon: LPCSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERA_V2__bindgen_ty_2 {
    pub nStartPage: UINT,
    pub pStartPage: LPCSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERA_V2__bindgen_ty_3 {
    pub ppsp: LPCPROPSHEETPAGEA,
    pub phpage: *mut HPROPSHEETPAGE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERA_V2__bindgen_ty_4 {
    pub hbmWatermark: HBITMAP,
    pub pszbmWatermark: LPCSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERA_V2__bindgen_ty_5 {
    pub hbmHeader: HBITMAP,
    pub pszbmHeader: LPCSTR,
}
pub type PROPSHEETHEADERA_V2 = _PROPSHEETHEADERA_V2;
pub type LPCPROPSHEETHEADERA_V2 = *const PROPSHEETHEADERA_V2;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROPSHEETHEADERW_V2 {
    pub dwSize: DWORD,
    pub dwFlags: DWORD,
    pub hwndParent: HWND,
    pub hInstance: HINSTANCE,
    pub __bindgen_anon_1: _PROPSHEETHEADERW_V2__bindgen_ty_1,
    pub pszCaption: LPCWSTR,
    pub nPages: UINT,
    pub __bindgen_anon_2: _PROPSHEETHEADERW_V2__bindgen_ty_2,
    pub __bindgen_anon_3: _PROPSHEETHEADERW_V2__bindgen_ty_3,
    pub pfnCallback: PFNPROPSHEETCALLBACK,
    pub __bindgen_anon_4: _PROPSHEETHEADERW_V2__bindgen_ty_4,
    pub hplWatermark: HPALETTE,
    pub __bindgen_anon_5: _PROPSHEETHEADERW_V2__bindgen_ty_5,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERW_V2__bindgen_ty_1 {
    pub hIcon: HICON,
    pub pszIcon: LPCWSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERW_V2__bindgen_ty_2 {
    pub nStartPage: UINT,
    pub pStartPage: LPCWSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERW_V2__bindgen_ty_3 {
    pub ppsp: LPCPROPSHEETPAGEW,
    pub phpage: *mut HPROPSHEETPAGE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERW_V2__bindgen_ty_4 {
    pub hbmWatermark: HBITMAP,
    pub pszbmWatermark: LPCWSTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROPSHEETHEADERW_V2__bindgen_ty_5 {
    pub hbmHeader: HBITMAP,
    pub pszbmHeader: LPCWSTR,
}
pub type PROPSHEETHEADERW_V2 = _PROPSHEETHEADERW_V2;
pub type LPCPROPSHEETHEADERW_V2 = *const PROPSHEETHEADERW_V2;
pub type LPCPROPSHEETHEADERA = LPCPROPSHEETHEADERA_V2;
pub type LPCPROPSHEETHEADERW = LPCPROPSHEETHEADERW_V2;
extern "C" {
    pub fn PropertySheetA(arg1: LPCPROPSHEETHEADERA) -> INT_PTR;
}
extern "C" {
    pub fn PropertySheetW(arg1: LPCPROPSHEETHEADERW) -> INT_PTR;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FORM_INFO_1A {
    pub Flags: DWORD,
    pub pName: LPSTR,
    pub Size: SIZEL,
    pub ImageableArea: RECTL,
}
pub type PFORM_INFO_1A = *mut _FORM_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FORM_INFO_1W {
    pub Flags: DWORD,
    pub pName: LPWSTR,
    pub Size: SIZEL,
    pub ImageableArea: RECTL,
}
pub type PFORM_INFO_1W = *mut _FORM_INFO_1W;
pub type PFORM_INFO_1 = PFORM_INFO_1A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FORM_INFO_2A {
    pub Flags: DWORD,
    pub pName: LPCSTR,
    pub Size: SIZEL,
    pub ImageableArea: RECTL,
    pub pKeyword: LPCSTR,
    pub StringType: DWORD,
    pub pMuiDll: LPCSTR,
    pub dwResourceId: DWORD,
    pub pDisplayName: LPCSTR,
    pub wLangId: LANGID,
}
pub type PFORM_INFO_2A = *mut _FORM_INFO_2A;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FORM_INFO_2W {
    pub Flags: DWORD,
    pub pName: LPCWSTR,
    pub Size: SIZEL,
    pub ImageableArea: RECTL,
    pub pKeyword: LPCSTR,
    pub StringType: DWORD,
    pub pMuiDll: LPCWSTR,
    pub dwResourceId: DWORD,
    pub pDisplayName: LPCWSTR,
    pub wLangId: LANGID,
}
pub type PFORM_INFO_2W = *mut _FORM_INFO_2W;
pub type PFORM_INFO_2 = PFORM_INFO_2A;
extern "C" {
    pub fn PrinterProperties(hWnd: HWND, hPrinter: HANDLE) -> BOOL;
}
extern "C" {
    pub fn PrinterMessageBoxA(
        hPrinter: HANDLE,
        Error: DWORD,
        hWnd: HWND,
        pText: LPSTR,
        pCaption: LPSTR,
        dwType: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn PrinterMessageBoxW(
        hPrinter: HANDLE,
        Error: DWORD,
        hWnd: HWND,
        pText: LPWSTR,
        pCaption: LPWSTR,
        dwType: DWORD,
    ) -> DWORD;
}
pub const EPrintPropertyType_kPropertyTypeString: EPrintPropertyType = 1;
pub const EPrintPropertyType_kPropertyTypeInt32: EPrintPropertyType = 2;
pub const EPrintPropertyType_kPropertyTypeInt64: EPrintPropertyType = 3;
pub const EPrintPropertyType_kPropertyTypeByte: EPrintPropertyType = 4;
pub const EPrintPropertyType_kPropertyTypeTime: EPrintPropertyType = 5;
pub const EPrintPropertyType_kPropertyTypeDevMode: EPrintPropertyType = 6;
pub const EPrintPropertyType_kPropertyTypeSD: EPrintPropertyType = 7;
pub const EPrintPropertyType_kPropertyTypeNotificationReply: EPrintPropertyType = 8;
pub const EPrintPropertyType_kPropertyTypeNotificationOptions: EPrintPropertyType = 9;
pub const EPrintPropertyType_kPropertyTypeBuffer: EPrintPropertyType = 10;
pub type EPrintPropertyType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PrintPropertyValue {
    pub ePropertyType: EPrintPropertyType,
    pub value: PrintPropertyValue__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PrintPropertyValue__bindgen_ty_1 {
    pub propertyByte: BYTE,
    pub propertyString: PWSTR,
    pub propertyInt32: LONG,
    pub propertyInt64: LONGLONG,
    pub propertyBlob: PrintPropertyValue__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrintPropertyValue__bindgen_ty_1__bindgen_ty_1 {
    pub cbBuf: DWORD,
    pub pBuf: LPVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PrintNamedProperty {
    pub propertyName: *mut WCHAR,
    pub propertyValue: PrintPropertyValue,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrintPropertiesCollection {
    pub numberOfProperties: ULONG,
    pub propertiesCollection: *mut PrintNamedProperty,
}
pub type LPUNKNOWN = *mut IUnknown;
#[repr(C)]
pub struct IUnknown__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IUnknown {
    pub vtable_: *const IUnknown__bindgen_vtable,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ISequentialStream {
    pub _base: IUnknown,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagSTATSTG {
    pub pwcsName: LPOLESTR,
    pub type_: DWORD,
    pub cbSize: ULARGE_INTEGER,
    pub mtime: FILETIME,
    pub ctime: FILETIME,
    pub atime: FILETIME,
    pub grfMode: DWORD,
    pub grfLocksSupported: DWORD,
    pub clsid: CLSID,
    pub grfStateBits: DWORD,
    pub reserved: DWORD,
}
pub type STATSTG = tagSTATSTG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IStream {
    pub _base: ISequentialStream,
}
extern "C" {
    pub fn ProgIDFromCLSID(clsid: *const IID, lplpszProgID: *mut LPOLESTR) -> HRESULT;
}
pub type PROPVARIANT = tagPROPVARIANT;
extern "C" {
    pub fn PropVariantCopy(pvarDest: *mut PROPVARIANT, pvarSrc: *const PROPVARIANT) -> HRESULT;
}
extern "C" {
    pub fn PropVariantClear(pvar: *mut PROPVARIANT) -> HRESULT;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IEnumSTATSTG {
    pub _base: IUnknown,
}
pub type SNB = *mut LPOLESTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IStorage {
    pub _base: IUnknown,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSAFEARRAYBOUND {
    pub cElements: ULONG,
    pub lLbound: LONG,
}
pub type SAFEARRAYBOUND = tagSAFEARRAYBOUND;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagSAFEARRAY {
    pub cDims: USHORT,
    pub fFeatures: USHORT,
    pub cbElements: ULONG,
    pub cLocks: ULONG,
    pub pvData: PVOID,
    pub rgsabound: [SAFEARRAYBOUND; 1usize],
}
pub type SAFEARRAY = tagSAFEARRAY;
pub type LPSAFEARRAY = *mut SAFEARRAY;
pub type VARIANT = tagVARIANT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagVARIANT {
    pub __bindgen_anon_1: tagVARIANT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagVARIANT__bindgen_ty_1 {
    pub __bindgen_anon_1: tagVARIANT__bindgen_ty_1__bindgen_ty_1,
    pub decVal: DECIMAL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagVARIANT__bindgen_ty_1__bindgen_ty_1 {
    pub vt: VARTYPE,
    pub wReserved1: WORD,
    pub wReserved2: WORD,
    pub wReserved3: WORD,
    pub __bindgen_anon_1: tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub llVal: LONGLONG,
    pub lVal: LONG,
    pub bVal: BYTE,
    pub iVal: SHORT,
    pub fltVal: FLOAT,
    pub dblVal: DOUBLE,
    pub boolVal: VARIANT_BOOL,
    pub __OBSOLETE__VARIANT_BOOL: VARIANT_BOOL,
    pub scode: SCODE,
    pub cyVal: CY,
    pub date: DATE,
    pub bstrVal: BSTR,
    pub punkVal: *mut IUnknown,
    pub pdispVal: *mut IDispatch,
    pub parray: *mut SAFEARRAY,
    pub pbVal: *mut BYTE,
    pub piVal: *mut SHORT,
    pub plVal: *mut LONG,
    pub pllVal: *mut LONGLONG,
    pub pfltVal: *mut FLOAT,
    pub pdblVal: *mut DOUBLE,
    pub pboolVal: *mut VARIANT_BOOL,
    pub __OBSOLETE__VARIANT_PBOOL: *mut VARIANT_BOOL,
    pub pscode: *mut SCODE,
    pub pcyVal: *mut CY,
    pub pdate: *mut DATE,
    pub pbstrVal: *mut BSTR,
    pub ppunkVal: *mut *mut IUnknown,
    pub ppdispVal: *mut *mut IDispatch,
    pub pparray: *mut *mut SAFEARRAY,
    pub pvarVal: *mut VARIANT,
    pub byref: PVOID,
    pub cVal: CHAR,
    pub uiVal: USHORT,
    pub ulVal: ULONG,
    pub ullVal: ULONGLONG,
    pub intVal: INT,
    pub uintVal: UINT,
    pub pdecVal: *mut DECIMAL,
    pub pcVal: *mut CHAR,
    pub puiVal: *mut USHORT,
    pub pulVal: *mut ULONG,
    pub pullVal: *mut ULONGLONG,
    pub pintVal: *mut INT,
    pub puintVal: *mut UINT,
    pub __bindgen_anon_1: tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub pvRecord: PVOID,
    pub pRecInfo: *mut IRecordInfo,
}
pub type VARIANTARG = VARIANT;
pub type DISPID = LONG;
pub type MEMBERID = DISPID;
pub type HREFTYPE = DWORD;
pub const tagTYPEKIND_TKIND_ENUM: tagTYPEKIND = 0;
pub const tagTYPEKIND_TKIND_RECORD: tagTYPEKIND = 1;
pub const tagTYPEKIND_TKIND_MODULE: tagTYPEKIND = 2;
pub const tagTYPEKIND_TKIND_INTERFACE: tagTYPEKIND = 3;
pub const tagTYPEKIND_TKIND_DISPATCH: tagTYPEKIND = 4;
pub const tagTYPEKIND_TKIND_COCLASS: tagTYPEKIND = 5;
pub const tagTYPEKIND_TKIND_ALIAS: tagTYPEKIND = 6;
pub const tagTYPEKIND_TKIND_UNION: tagTYPEKIND = 7;
pub const tagTYPEKIND_TKIND_MAX: tagTYPEKIND = 8;
pub type tagTYPEKIND = ::std::os::raw::c_int;
pub use self::tagTYPEKIND as TYPEKIND;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagTYPEDESC {
    pub __bindgen_anon_1: tagTYPEDESC__bindgen_ty_1,
    pub vt: VARTYPE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagTYPEDESC__bindgen_ty_1 {
    pub lptdesc: *mut tagTYPEDESC,
    pub lpadesc: *mut tagARRAYDESC,
    pub hreftype: HREFTYPE,
}
pub type TYPEDESC = tagTYPEDESC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagARRAYDESC {
    pub tdescElem: TYPEDESC,
    pub cDims: USHORT,
    pub rgbounds: [SAFEARRAYBOUND; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagPARAMDESCEX {
    pub cBytes: ULONG,
    pub varDefaultValue: VARIANTARG,
}
pub type LPPARAMDESCEX = *mut tagPARAMDESCEX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPARAMDESC {
    pub pparamdescex: LPPARAMDESCEX,
    pub wParamFlags: USHORT,
}
pub type PARAMDESC = tagPARAMDESC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagIDLDESC {
    pub dwReserved: ULONG_PTR,
    pub wIDLFlags: USHORT,
}
pub type IDLDESC = tagIDLDESC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagELEMDESC {
    pub tdesc: TYPEDESC,
    pub __bindgen_anon_1: tagELEMDESC__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagELEMDESC__bindgen_ty_1 {
    pub idldesc: IDLDESC,
    pub paramdesc: PARAMDESC,
}
pub type ELEMDESC = tagELEMDESC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagTYPEATTR {
    pub guid: GUID,
    pub lcid: LCID,
    pub dwReserved: DWORD,
    pub memidConstructor: MEMBERID,
    pub memidDestructor: MEMBERID,
    pub lpstrSchema: LPOLESTR,
    pub cbSizeInstance: ULONG,
    pub typekind: TYPEKIND,
    pub cFuncs: WORD,
    pub cVars: WORD,
    pub cImplTypes: WORD,
    pub cbSizeVft: WORD,
    pub cbAlignment: WORD,
    pub wTypeFlags: WORD,
    pub wMajorVerNum: WORD,
    pub wMinorVerNum: WORD,
    pub tdescAlias: TYPEDESC,
    pub idldescType: IDLDESC,
}
pub type TYPEATTR = tagTYPEATTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagDISPPARAMS {
    pub rgvarg: *mut VARIANTARG,
    pub rgdispidNamedArgs: *mut DISPID,
    pub cArgs: UINT,
    pub cNamedArgs: UINT,
}
pub type DISPPARAMS = tagDISPPARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagEXCEPINFO {
    pub wCode: WORD,
    pub wReserved: WORD,
    pub bstrSource: BSTR,
    pub bstrDescription: BSTR,
    pub bstrHelpFile: BSTR,
    pub dwHelpContext: DWORD,
    pub pvReserved: PVOID,
    pub pfnDeferredFillIn:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut tagEXCEPINFO) -> HRESULT>,
    pub scode: SCODE,
}
pub type EXCEPINFO = tagEXCEPINFO;
pub const tagCALLCONV_CC_FASTCALL: tagCALLCONV = 0;
pub const tagCALLCONV_CC_CDECL: tagCALLCONV = 1;
pub const tagCALLCONV_CC_MSCPASCAL: tagCALLCONV = 2;
pub const tagCALLCONV_CC_PASCAL: tagCALLCONV = 2;
pub const tagCALLCONV_CC_MACPASCAL: tagCALLCONV = 3;
pub const tagCALLCONV_CC_STDCALL: tagCALLCONV = 4;
pub const tagCALLCONV_CC_FPFASTCALL: tagCALLCONV = 5;
pub const tagCALLCONV_CC_SYSCALL: tagCALLCONV = 6;
pub const tagCALLCONV_CC_MPWCDECL: tagCALLCONV = 7;
pub const tagCALLCONV_CC_MPWPASCAL: tagCALLCONV = 8;
pub const tagCALLCONV_CC_MAX: tagCALLCONV = 9;
pub type tagCALLCONV = ::std::os::raw::c_int;
pub use self::tagCALLCONV as CALLCONV;
pub const tagFUNCKIND_FUNC_VIRTUAL: tagFUNCKIND = 0;
pub const tagFUNCKIND_FUNC_PUREVIRTUAL: tagFUNCKIND = 1;
pub const tagFUNCKIND_FUNC_NONVIRTUAL: tagFUNCKIND = 2;
pub const tagFUNCKIND_FUNC_STATIC: tagFUNCKIND = 3;
pub const tagFUNCKIND_FUNC_DISPATCH: tagFUNCKIND = 4;
pub type tagFUNCKIND = ::std::os::raw::c_int;
pub use self::tagFUNCKIND as FUNCKIND;
pub const tagINVOKEKIND_INVOKE_FUNC: tagINVOKEKIND = 1;
pub const tagINVOKEKIND_INVOKE_PROPERTYGET: tagINVOKEKIND = 2;
pub const tagINVOKEKIND_INVOKE_PROPERTYPUT: tagINVOKEKIND = 4;
pub const tagINVOKEKIND_INVOKE_PROPERTYPUTREF: tagINVOKEKIND = 8;
pub type tagINVOKEKIND = ::std::os::raw::c_int;
pub use self::tagINVOKEKIND as INVOKEKIND;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagFUNCDESC {
    pub memid: MEMBERID,
    pub lprgscode: *mut SCODE,
    pub lprgelemdescParam: *mut ELEMDESC,
    pub funckind: FUNCKIND,
    pub invkind: INVOKEKIND,
    pub callconv: CALLCONV,
    pub cParams: SHORT,
    pub cParamsOpt: SHORT,
    pub oVft: SHORT,
    pub cScodes: SHORT,
    pub elemdescFunc: ELEMDESC,
    pub wFuncFlags: WORD,
}
pub type FUNCDESC = tagFUNCDESC;
pub const tagVARKIND_VAR_PERINSTANCE: tagVARKIND = 0;
pub const tagVARKIND_VAR_STATIC: tagVARKIND = 1;
pub const tagVARKIND_VAR_CONST: tagVARKIND = 2;
pub const tagVARKIND_VAR_DISPATCH: tagVARKIND = 3;
pub type tagVARKIND = ::std::os::raw::c_int;
pub use self::tagVARKIND as VARKIND;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagVARDESC {
    pub memid: MEMBERID,
    pub lpstrSchema: LPOLESTR,
    pub __bindgen_anon_1: tagVARDESC__bindgen_ty_1,
    pub elemdescVar: ELEMDESC,
    pub wVarFlags: WORD,
    pub varkind: VARKIND,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagVARDESC__bindgen_ty_1 {
    pub oInst: ULONG,
    pub lpvarValue: *mut VARIANT,
}
pub type VARDESC = tagVARDESC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDispatch {
    pub _base: IUnknown,
}
pub const tagDESCKIND_DESCKIND_NONE: tagDESCKIND = 0;
pub const tagDESCKIND_DESCKIND_FUNCDESC: tagDESCKIND = 1;
pub const tagDESCKIND_DESCKIND_VARDESC: tagDESCKIND = 2;
pub const tagDESCKIND_DESCKIND_TYPECOMP: tagDESCKIND = 3;
pub const tagDESCKIND_DESCKIND_IMPLICITAPPOBJ: tagDESCKIND = 4;
pub const tagDESCKIND_DESCKIND_MAX: tagDESCKIND = 5;
pub type tagDESCKIND = ::std::os::raw::c_int;
pub use self::tagDESCKIND as DESCKIND;
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagBINDPTR {
    pub lpfuncdesc: *mut FUNCDESC,
    pub lpvardesc: *mut VARDESC,
    pub lptcomp: *mut ITypeComp,
}
pub type BINDPTR = tagBINDPTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeComp {
    pub _base: IUnknown,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeInfo {
    pub _base: IUnknown,
}
pub const tagSYSKIND_SYS_WIN16: tagSYSKIND = 0;
pub const tagSYSKIND_SYS_WIN32: tagSYSKIND = 1;
pub const tagSYSKIND_SYS_MAC: tagSYSKIND = 2;
pub const tagSYSKIND_SYS_WIN64: tagSYSKIND = 3;
pub type tagSYSKIND = ::std::os::raw::c_int;
pub use self::tagSYSKIND as SYSKIND;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTLIBATTR {
    pub guid: GUID,
    pub lcid: LCID,
    pub syskind: SYSKIND,
    pub wMajorVerNum: WORD,
    pub wMinorVerNum: WORD,
    pub wLibFlags: WORD,
}
pub type TLIBATTR = tagTLIBATTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ITypeLib {
    pub _base: IUnknown,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IRecordInfo {
    pub _base: IUnknown,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagVersionedStream {
    pub guidVersion: GUID,
    pub pStream: *mut IStream,
}
pub type LPVERSIONEDSTREAM = *mut tagVersionedStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAC {
    pub cElems: ULONG,
    pub pElems: *mut CHAR,
}
pub type CAC = tagCAC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAUB {
    pub cElems: ULONG,
    pub pElems: *mut UCHAR,
}
pub type CAUB = tagCAUB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAI {
    pub cElems: ULONG,
    pub pElems: *mut SHORT,
}
pub type CAI = tagCAI;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAUI {
    pub cElems: ULONG,
    pub pElems: *mut USHORT,
}
pub type CAUI = tagCAUI;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAL {
    pub cElems: ULONG,
    pub pElems: *mut LONG,
}
pub type CAL = tagCAL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAUL {
    pub cElems: ULONG,
    pub pElems: *mut ULONG,
}
pub type CAUL = tagCAUL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAFLT {
    pub cElems: ULONG,
    pub pElems: *mut FLOAT,
}
pub type CAFLT = tagCAFLT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCADBL {
    pub cElems: ULONG,
    pub pElems: *mut DOUBLE,
}
pub type CADBL = tagCADBL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCACY {
    pub cElems: ULONG,
    pub pElems: *mut CY,
}
pub type CACY = tagCACY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCADATE {
    pub cElems: ULONG,
    pub pElems: *mut DATE,
}
pub type CADATE = tagCADATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCABSTR {
    pub cElems: ULONG,
    pub pElems: *mut BSTR,
}
pub type CABSTR = tagCABSTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCABSTRBLOB {
    pub cElems: ULONG,
    pub pElems: *mut BSTRBLOB,
}
pub type CABSTRBLOB = tagCABSTRBLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCABOOL {
    pub cElems: ULONG,
    pub pElems: *mut VARIANT_BOOL,
}
pub type CABOOL = tagCABOOL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCASCODE {
    pub cElems: ULONG,
    pub pElems: *mut SCODE,
}
pub type CASCODE = tagCASCODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAPROPVARIANT {
    pub cElems: ULONG,
    pub pElems: *mut PROPVARIANT,
}
pub type CAPROPVARIANT = tagCAPROPVARIANT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAH {
    pub cElems: ULONG,
    pub pElems: *mut LARGE_INTEGER,
}
pub type CAH = tagCAH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAUH {
    pub cElems: ULONG,
    pub pElems: *mut ULARGE_INTEGER,
}
pub type CAUH = tagCAUH;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCALPSTR {
    pub cElems: ULONG,
    pub pElems: *mut LPSTR,
}
pub type CALPSTR = tagCALPSTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCALPWSTR {
    pub cElems: ULONG,
    pub pElems: *mut LPWSTR,
}
pub type CALPWSTR = tagCALPWSTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCAFILETIME {
    pub cElems: ULONG,
    pub pElems: *mut FILETIME,
}
pub type CAFILETIME = tagCAFILETIME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCACLIPDATA {
    pub cElems: ULONG,
    pub pElems: *mut CLIPDATA,
}
pub type CACLIPDATA = tagCACLIPDATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagCACLSID {
    pub cElems: ULONG,
    pub pElems: *mut CLSID,
}
pub type CACLSID = tagCACLSID;
pub type PROPVAR_PAD1 = WORD;
pub type PROPVAR_PAD2 = WORD;
pub type PROPVAR_PAD3 = WORD;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagPROPVARIANT {
    pub __bindgen_anon_1: tagPROPVARIANT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagPROPVARIANT__bindgen_ty_1 {
    pub __bindgen_anon_1: tagPROPVARIANT__bindgen_ty_1__bindgen_ty_1,
    pub decVal: DECIMAL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagPROPVARIANT__bindgen_ty_1__bindgen_ty_1 {
    pub vt: VARTYPE,
    pub wReserved1: PROPVAR_PAD1,
    pub wReserved2: PROPVAR_PAD2,
    pub wReserved3: PROPVAR_PAD3,
    pub __bindgen_anon_1: tagPROPVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagPROPVARIANT__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub cVal: CHAR,
    pub bVal: UCHAR,
    pub iVal: SHORT,
    pub uiVal: USHORT,
    pub lVal: LONG,
    pub ulVal: ULONG,
    pub intVal: INT,
    pub uintVal: UINT,
    pub hVal: LARGE_INTEGER,
    pub uhVal: ULARGE_INTEGER,
    pub fltVal: FLOAT,
    pub dblVal: DOUBLE,
    pub boolVal: VARIANT_BOOL,
    pub __OBSOLETE__VARIANT_BOOL: VARIANT_BOOL,
    pub scode: SCODE,
    pub cyVal: CY,
    pub date: DATE,
    pub filetime: FILETIME,
    pub puuid: *mut CLSID,
    pub pclipdata: *mut CLIPDATA,
    pub bstrVal: BSTR,
    pub bstrblobVal: BSTRBLOB,
    pub blob: BLOB,
    pub pszVal: LPSTR,
    pub pwszVal: LPWSTR,
    pub punkVal: *mut IUnknown,
    pub pdispVal: *mut IDispatch,
    pub pStream: *mut IStream,
    pub pStorage: *mut IStorage,
    pub pVersionedStream: LPVERSIONEDSTREAM,
    pub parray: LPSAFEARRAY,
    pub cac: CAC,
    pub caub: CAUB,
    pub cai: CAI,
    pub caui: CAUI,
    pub cal: CAL,
    pub caul: CAUL,
    pub cah: CAH,
    pub cauh: CAUH,
    pub caflt: CAFLT,
    pub cadbl: CADBL,
    pub cabool: CABOOL,
    pub cascode: CASCODE,
    pub cacy: CACY,
    pub cadate: CADATE,
    pub cafiletime: CAFILETIME,
    pub cauuid: CACLSID,
    pub caclipdata: CACLIPDATA,
    pub cabstr: CABSTR,
    pub cabstrblob: CABSTRBLOB,
    pub calpstr: CALPSTR,
    pub calpwstr: CALPWSTR,
    pub capropvar: CAPROPVARIANT,
    pub pcVal: *mut CHAR,
    pub pbVal: *mut UCHAR,
    pub piVal: *mut SHORT,
    pub puiVal: *mut USHORT,
    pub plVal: *mut LONG,
    pub pulVal: *mut ULONG,
    pub pintVal: *mut INT,
    pub puintVal: *mut UINT,
    pub pfltVal: *mut FLOAT,
    pub pdblVal: *mut DOUBLE,
    pub pboolVal: *mut VARIANT_BOOL,
    pub pdecVal: *mut DECIMAL,
    pub pscode: *mut SCODE,
    pub pcyVal: *mut CY,
    pub pdate: *mut DATE,
    pub pbstrVal: *mut BSTR,
    pub ppunkVal: *mut *mut IUnknown,
    pub ppdispVal: *mut *mut IDispatch,
    pub pparray: *mut LPSAFEARRAY,
    pub pvarVal: *mut PROPVARIANT,
}
extern "C" {
    pub fn PropStgNameToFmtId(oszName: LPOLESTR, pfmtid: *mut FMTID) -> HRESULT;
}
pub type LPPRINTHOOKPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> UINT_PTR,
>;
pub type LPSETUPHOOKPROC = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWND, arg2: UINT, arg3: WPARAM, arg4: LPARAM) -> UINT_PTR,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPDA {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hDevMode: HGLOBAL,
    pub hDevNames: HGLOBAL,
    pub hDC: HDC,
    pub Flags: DWORD,
    pub nFromPage: WORD,
    pub nToPage: WORD,
    pub nMinPage: WORD,
    pub nMaxPage: WORD,
    pub nCopies: WORD,
    pub hInstance: HINSTANCE,
    pub lCustData: LPARAM,
    pub lpfnPrintHook: LPPRINTHOOKPROC,
    pub lpfnSetupHook: LPSETUPHOOKPROC,
    pub lpPrintTemplateName: LPCSTR,
    pub lpSetupTemplateName: LPCSTR,
    pub hPrintTemplate: HGLOBAL,
    pub hSetupTemplate: HGLOBAL,
}
pub type LPPRINTDLGA = *mut tagPDA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPDW {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hDevMode: HGLOBAL,
    pub hDevNames: HGLOBAL,
    pub hDC: HDC,
    pub Flags: DWORD,
    pub nFromPage: WORD,
    pub nToPage: WORD,
    pub nMinPage: WORD,
    pub nMaxPage: WORD,
    pub nCopies: WORD,
    pub hInstance: HINSTANCE,
    pub lCustData: LPARAM,
    pub lpfnPrintHook: LPPRINTHOOKPROC,
    pub lpfnSetupHook: LPSETUPHOOKPROC,
    pub lpPrintTemplateName: LPCWSTR,
    pub lpSetupTemplateName: LPCWSTR,
    pub hPrintTemplate: HGLOBAL,
    pub hSetupTemplate: HGLOBAL,
}
pub type LPPRINTDLGW = *mut tagPDW;
extern "C" {
    pub fn PrintDlgA(pPD: LPPRINTDLGA) -> BOOL;
}
extern "C" {
    pub fn PrintDlgW(pPD: LPPRINTDLGW) -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPRINTPAGERANGE {
    pub nFromPage: DWORD,
    pub nToPage: DWORD,
}
pub type PRINTPAGERANGE = tagPRINTPAGERANGE;
pub type LPPRINTPAGERANGE = *mut PRINTPAGERANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPDEXA {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hDevMode: HGLOBAL,
    pub hDevNames: HGLOBAL,
    pub hDC: HDC,
    pub Flags: DWORD,
    pub Flags2: DWORD,
    pub ExclusionFlags: DWORD,
    pub nPageRanges: DWORD,
    pub nMaxPageRanges: DWORD,
    pub lpPageRanges: LPPRINTPAGERANGE,
    pub nMinPage: DWORD,
    pub nMaxPage: DWORD,
    pub nCopies: DWORD,
    pub hInstance: HINSTANCE,
    pub lpPrintTemplateName: LPCSTR,
    pub lpCallback: LPUNKNOWN,
    pub nPropertyPages: DWORD,
    pub lphPropertyPages: *mut HPROPSHEETPAGE,
    pub nStartPage: DWORD,
    pub dwResultAction: DWORD,
}
pub type LPPRINTDLGEXA = *mut tagPDEXA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPDEXW {
    pub lStructSize: DWORD,
    pub hwndOwner: HWND,
    pub hDevMode: HGLOBAL,
    pub hDevNames: HGLOBAL,
    pub hDC: HDC,
    pub Flags: DWORD,
    pub Flags2: DWORD,
    pub ExclusionFlags: DWORD,
    pub nPageRanges: DWORD,
    pub nMaxPageRanges: DWORD,
    pub lpPageRanges: LPPRINTPAGERANGE,
    pub nMinPage: DWORD,
    pub nMaxPage: DWORD,
    pub nCopies: DWORD,
    pub hInstance: HINSTANCE,
    pub lpPrintTemplateName: LPCWSTR,
    pub lpCallback: LPUNKNOWN,
    pub nPropertyPages: DWORD,
    pub lphPropertyPages: *mut HPROPSHEETPAGE,
    pub nStartPage: DWORD,
    pub dwResultAction: DWORD,
}
pub type LPPRINTDLGEXW = *mut tagPDEXW;
extern "C" {
    pub fn PrintDlgExA(pPD: LPPRINTDLGEXA) -> HRESULT;
}
extern "C" {
    pub fn PrintDlgExW(pPD: LPPRINTDLGEXW) -> HRESULT;
}
pub type PFN_SC_NOTIFY_CALLBACK = ::std::option::Option<unsafe extern "C" fn(pParameter: PVOID)>;
pub type csSDK_int8 = ::std::os::raw::c_schar;
pub type csSDK_int16 = ::std::os::raw::c_short;
pub type csSDK_int32 = ::std::os::raw::c_int;
pub type csSDK_int64 = ::std::os::raw::c_longlong;
pub type csSDK_uint8 = ::std::os::raw::c_uchar;
pub type csSDK_uint16 = ::std::os::raw::c_ushort;
pub type csSDK_uint32 = ::std::os::raw::c_uint;
pub type csSDK_uint64 = ::std::os::raw::c_ulonglong;
pub type csSDK_size_t = csSDK_uint64;
pub type PrMemoryPtr = *mut ::std::os::raw::c_char;
pub type PrMemoryHandle = *mut PrMemoryPtr;
pub type PrFourCC = csSDK_uint32;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct prRect {
    pub left: csSDK_int32,
    pub top: csSDK_int32,
    pub right: csSDK_int32,
    pub bottom: csSDK_int32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct prFPoint64 {
    pub x: f64,
    pub y: f64,
}
pub type prBool = csSDK_int32;
pub const kPrTrue: prBool = 1;
pub const kPrFalse: prBool = 0;
pub type prUTF8Char = csSDK_uint8;
pub type prWnd = HWND;
pub type prUTF16Char = u16;
pub type prInt64 = csSDK_int64;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKString {
    pub opaque: [csSDK_int64; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKGuid {
    pub opaque: [csSDK_int64; 2usize],
}
pub type PrSDKColorSpaceID = PrSDKGuid;
extern "C" {
    pub static kPrSDKColorSpaceID_Invalid: PrSDKColorSpaceID;
}
pub type PrSDKLUTID = PrSDKGuid;
extern "C" {
    pub static kPrSDKLUTID_Invalid: PrSDKLUTID;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PPix {
    pub bounds: prRect,
    pub rowbytes: csSDK_int32,
    pub bitsperpixel: csSDK_int32,
    pub pix: *mut ::std::os::raw::c_void,
    pub reserved: [*mut ::std::os::raw::c_void; 32usize],
}
pub type PPixHand = *mut *mut PPix;
pub type prFieldType = csSDK_int32;
pub type PrTimelineID = csSDK_int32;
pub type PrClipID = csSDK_int32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct prPluginID {
    pub mGUID: [::std::os::raw::c_char; 37usize],
}
pub const PrParamType_kPrParamType_Int8: PrParamType = 1;
pub const PrParamType_kPrParamType_Int16: PrParamType = 2;
pub const PrParamType_kPrParamType_Int32: PrParamType = 3;
pub const PrParamType_kPrParamType_Int64: PrParamType = 4;
pub const PrParamType_kPrParamType_Float32: PrParamType = 5;
pub const PrParamType_kPrParamType_Float64: PrParamType = 6;
pub const PrParamType_kPrParamType_Bool: PrParamType = 7;
pub const PrParamType_kPrParamType_Point: PrParamType = 8;
pub const PrParamType_kPrParamType_Guid: PrParamType = 9;
pub const PrParamType_kPrParamType_PrMemoryPtr: PrParamType = 10;
pub const PrParamType_kPrParamType_MaxSize: PrParamType = -1;
pub type PrParamType = ::std::os::raw::c_int;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct PrParam {
    pub mType: PrParamType,
    pub __bindgen_anon_1: PrParam__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union PrParam__bindgen_ty_1 {
    pub mInt8: csSDK_int8,
    pub mInt16: csSDK_int16,
    pub mInt32: csSDK_int32,
    pub mInt64: csSDK_int64,
    pub mFloat32: f32,
    pub mFloat64: f64,
    pub mBool: csSDK_uint8,
    pub mPoint: prFPoint64,
    pub mGuid: prPluginID,
    pub mMemoryPtr: PrMemoryPtr,
}
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRA_4444_8u: PrPixelFormat = 1634887522;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYA_4444_8u: PrPixelFormat = 1635349878;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYA_4444_8u_709: PrPixelFormat = 1096373590;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_ARGB_4444_8u: PrPixelFormat = 1650946657;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRX_4444_8u: PrPixelFormat = 2020763490;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYX_4444_8u: PrPixelFormat = 2021225846;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYX_4444_8u_709: PrPixelFormat = 930641270;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_XRGB_4444_8u: PrPixelFormat = 1650946680;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRP_4444_8u: PrPixelFormat = 1886545762;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYP_4444_8u: PrPixelFormat = 1887008118;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYP_4444_8u_709: PrPixelFormat = 930116982;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_PRGB_4444_8u: PrPixelFormat = 1650946672;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRA_4444_16u: PrPixelFormat = 1634887490;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYA_4444_16u: PrPixelFormat = 1635349846;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_ARGB_4444_16u: PrPixelFormat = 1650946625;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRX_4444_16u: PrPixelFormat = 2020763458;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_XRGB_4444_16u: PrPixelFormat = 1650946648;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRP_4444_16u: PrPixelFormat = 1886545730;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_PRGB_4444_16u: PrPixelFormat = 1650946640;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRA_4444_32f: PrPixelFormat = 1634879298;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYA_4444_32f: PrPixelFormat = 1635341654;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYA_4444_32f_709: PrPixelFormat = 1633244534;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_ARGB_4444_32f: PrPixelFormat = 1650938433;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRX_4444_32f: PrPixelFormat = 2020755266;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYX_4444_32f: PrPixelFormat = 2021217622;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYX_4444_32f_709: PrPixelFormat = 930633046;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_XRGB_4444_32f: PrPixelFormat = 1650938456;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRP_4444_32f: PrPixelFormat = 1886537538;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYP_4444_32f: PrPixelFormat = 1886999894;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_VUYP_4444_32f_709: PrPixelFormat = 930108758;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_PRGB_4444_32f: PrPixelFormat = 1650938448;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_RGB_444_10u: PrPixelFormat = 826427218;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_YUYV_422_8u_601: PrPixelFormat = 846820729;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_YUYV_422_8u_709: PrPixelFormat = 863597945;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_UYVY_422_8u_601: PrPixelFormat = 2037807477;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_UYVY_422_8u_709: PrPixelFormat = 930511221;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_V210_422_10u_601: PrPixelFormat = 808530550;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_V210_422_10u_709: PrPixelFormat = 825307766;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_UYVY_422_32f_601: PrPixelFormat = 2037799253;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_UYVY_422_32f_709: PrPixelFormat = 930502997;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRA_4444_32f_Linear: PrPixelFormat = 1281443650;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRP_4444_32f_Linear: PrPixelFormat = 1282426690;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_BGRX_4444_32f_Linear: PrPixelFormat = 1282950978;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_ARGB_4444_32f_Linear: PrPixelFormat = 1281839681;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_PRGB_4444_32f_Linear: PrPixelFormat = 1281839696;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_XRGB_4444_32f_Linear: PrPixelFormat = 1281839704;
#[doc = "\tCurrently supported types"]
pub const PrPixelFormat_PrPixelFormat_RGB_444_12u_PQ_709: PrPixelFormat = 928075840;
pub const PrPixelFormat_PrPixelFormat_RGB_444_12u_PQ_P3: PrPixelFormat = 1347506240;
pub const PrPixelFormat_PrPixelFormat_RGB_444_12u_PQ_2020: PrPixelFormat = 844189760;
pub const PrPixelFormat_PrPixelFormat_RGB_444_10u_HLG: PrPixelFormat = 827082816;
pub const PrPixelFormat_PrPixelFormat_RGB_444_12u_HLG: PrPixelFormat = 843860032;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u_601: PrPixelFormat =
    842102393;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u_601: PrPixelFormat =
    845772409;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u_601_FullRange:
    PrPixelFormat = 1714517625;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u_601_FullRange:
    PrPixelFormat = 1718187641;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u_709: PrPixelFormat =
    925988473;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u_709: PrPixelFormat =
    929658489;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u_709_FullRange:
    PrPixelFormat = 1177646713;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u_709_FullRange:
    PrPixelFormat = 1181316729;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_PLANAR_8u_601: PrPixelFormat =
    842102361;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_PLANAR_8u_601: PrPixelFormat =
    845772377;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_PLANAR_8u_601_FullRange:
    PrPixelFormat = 1714517593;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_PLANAR_8u_601_FullRange:
    PrPixelFormat = 1718187609;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_PLANAR_8u_709: PrPixelFormat =
    925988441;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_PLANAR_8u_709: PrPixelFormat =
    929658457;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_PLANAR_8u_709_FullRange:
    PrPixelFormat = 1177646681;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_PLANAR_8u_709_FullRange:
    PrPixelFormat = 1181316697;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_8u_601: PrPixelFormat =
    862549614;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_8u_601: PrPixelFormat =
    858879598;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_8u_601_FullRange:
    PrPixelFormat = 828995182;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_8u_601_FullRange:
    PrPixelFormat = 825325166;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_8u_709: PrPixelFormat =
    845772398;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_8u_709: PrPixelFormat =
    842102382;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_8u_709_FullRange:
    PrPixelFormat = 812217966;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_8u_709_FullRange:
    PrPixelFormat = 808547950;
pub const PrPixelFormat_PrPixelFormat_YVU_420_MPEG4_FIELD_PICTURE_BIPLANAR_8u_601: PrPixelFormat =
    862549582;
pub const PrPixelFormat_PrPixelFormat_YVU_420_MPEG4_FRAME_PICTURE_BIPLANAR_8u_601: PrPixelFormat =
    858879566;
pub const PrPixelFormat_PrPixelFormat_YVU_420_MPEG4_FIELD_PICTURE_BIPLANAR_8u_601_FullRange:
    PrPixelFormat = 828995150;
pub const PrPixelFormat_PrPixelFormat_YVU_420_MPEG4_FRAME_PICTURE_BIPLANAR_8u_601_FullRange:
    PrPixelFormat = 825325134;
pub const PrPixelFormat_PrPixelFormat_YVU_420_MPEG4_FIELD_PICTURE_BIPLANAR_8u_709: PrPixelFormat =
    845772366;
pub const PrPixelFormat_PrPixelFormat_YVU_420_MPEG4_FRAME_PICTURE_BIPLANAR_8u_709: PrPixelFormat =
    842102350;
pub const PrPixelFormat_PrPixelFormat_YVU_420_MPEG4_FIELD_PICTURE_BIPLANAR_8u_709_FullRange:
    PrPixelFormat = 812217934;
pub const PrPixelFormat_PrPixelFormat_YVU_420_MPEG4_FRAME_PICTURE_BIPLANAR_8u_709_FullRange:
    PrPixelFormat = 808547918;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_10u_as16u_709:
    PrPixelFormat = 812200048;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_10u_as16u_709:
    PrPixelFormat = 808530032;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_10u_as16u_709_FullRange : PrPixelFormat = 1718169712 ;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_10u_as16u_709_FullRange : PrPixelFormat = 1714499696 ;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_10u_as16u_2020:
    PrPixelFormat = 812200016;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_10u_as16u_2020:
    PrPixelFormat = 808530000;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_10u_as16u_2020_FullRange : PrPixelFormat = 1718169680 ;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_10u_as16u_2020_FullRange : PrPixelFormat = 1714499664 ;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_10u_as16u_2020_HDR:
    PrPixelFormat = 812207952;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_10u_as16u_2020_HDR:
    PrPixelFormat = 808537936;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_10u_as16u_2020_HDR_FullRange : PrPixelFormat = 1718177616 ;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_10u_as16u_2020_HDR_FullRange : PrPixelFormat = 1714507600 ;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_10u_as16u_2020_HDR_HLG : PrPixelFormat = 812410960 ;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_10u_as16u_2020_HDR_HLG : PrPixelFormat = 810305616 ;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FIELD_PICTURE_BIPLANAR_10u_as16u_2020_HDR_HLG_FullRange : PrPixelFormat = 1718380624 ;
pub const PrPixelFormat_PrPixelFormat_YUV_420_MPEG4_FRAME_PICTURE_BIPLANAR_10u_as16u_2020_HDR_HLG_FullRange : PrPixelFormat = 1716275280 ;
pub const PrPixelFormat_PrPixelFormat_NTSCDV25: PrPixelFormat = 846100068;
pub const PrPixelFormat_PrPixelFormat_PALDV25: PrPixelFormat = 846231140;
pub const PrPixelFormat_PrPixelFormat_NTSCDV50: PrPixelFormat = 896431716;
pub const PrPixelFormat_PrPixelFormat_PALDV50: PrPixelFormat = 896562788;
pub const PrPixelFormat_PrPixelFormat_NTSCDV100_720p: PrPixelFormat = 929986148;
pub const PrPixelFormat_PrPixelFormat_PALDV100_720p: PrPixelFormat = 930117220;
pub const PrPixelFormat_PrPixelFormat_NTSCDV100_1080i: PrPixelFormat = 829322852;
pub const PrPixelFormat_PrPixelFormat_PALDV100_1080i: PrPixelFormat = 829453924;
pub const PrPixelFormat_PrPixelFormat_Raw: PrPixelFormat = 2004312434;
pub const PrPixelFormat_PrPixelFormat_Invalid: PrPixelFormat = 1717854562;
pub const PrPixelFormat_PrPixelFormat_Any: PrPixelFormat = 0;
#[doc = "\tPremiere supported pixel formats for RenderFrame and PPixs"]
pub type PrPixelFormat = ::std::os::raw::c_int;
pub type plugGetClipVideoFunc = ::std::option::Option<
    unsafe extern "C" fn(
        frame: csSDK_int32,
        thePort: PPixHand,
        bounds: *mut prRect,
        flags: csSDK_int32,
        clipData: PrClipID,
    ) -> csSDK_int32,
>;
pub type plugGetWorkAreaFunc = ::std::option::Option<
    unsafe extern "C" fn(
        timelineData: PrTimelineID,
        workAreaStart: *mut csSDK_int32,
        workAreaEnd: *mut csSDK_int32,
    ) -> csSDK_int32,
>;
pub type plugGetCurrentTimebaseFunc = ::std::option::Option<
    unsafe extern "C" fn(
        timelineData: PrTimelineID,
        scale: *mut csSDK_uint32,
        sampleSize: *mut csSDK_int32,
    ),
>;
pub type plugGetCurrentPosFunc =
    ::std::option::Option<unsafe extern "C" fn(timelineData: PrTimelineID) -> csSDK_int32>;
pub type plugGetPreviewFrameExFunc = ::std::option::Option<
    unsafe extern "C" fn(
        inTimelineData: PrTimelineID,
        inFrame: csSDK_int32,
        outRenderedFrame: *mut PPixHand,
        inFrameRect: *const prRect,
        inRequestedPixelFormatArray: *mut PrPixelFormat,
        inRequestedPixelFormatArrayCount: csSDK_int32,
        inPixelAspectRatioNumerator: csSDK_uint32,
        inPixelAspectRatioDenominator: csSDK_uint32,
        inAlwaysRender: bool,
    ) -> csSDK_int32,
>;
pub type plugGetClipVideoBoundsFunc = ::std::option::Option<
    unsafe extern "C" fn(
        inClipData: PrClipID,
        outBounds: *mut prRect,
        outPixelAspectRatioNumerator: *mut csSDK_uint32,
        outPixelAspectRatioDenominator: *mut csSDK_uint32,
    ) -> csSDK_int32,
>;
pub type plugGetClipVideoExFunc = ::std::option::Option<
    unsafe extern "C" fn(
        inFrame: csSDK_int32,
        outRenderedFrame: *mut PPixHand,
        inFrameRect: *const prRect,
        inRequestedPixelFormatArray: *const PrPixelFormat,
        inRequestedPixelFormatArrayCount: csSDK_int32,
        inPixelAspectRatioNumerator: csSDK_uint32,
        inPixelAspectRatioDenominator: csSDK_uint32,
        inClipData: PrClipID,
    ) -> csSDK_int32,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PlugTimelineFuncs {
    pub unused2: *mut ::std::os::raw::c_void,
    pub unused3: *mut ::std::os::raw::c_void,
    pub getClipVideo: plugGetClipVideoFunc,
    pub unused1: *mut ::std::os::raw::c_void,
    pub unused8: *mut ::std::os::raw::c_void,
    pub unused9: *mut ::std::os::raw::c_void,
    pub unused10: *mut ::std::os::raw::c_void,
    pub getWorkArea: plugGetWorkAreaFunc,
    pub unused7: *mut ::std::os::raw::c_void,
    pub unused4: *mut ::std::os::raw::c_void,
    pub getCurrentTimebase: plugGetCurrentTimebaseFunc,
    pub getCurrentPos: plugGetCurrentPosFunc,
    pub unused5: *mut ::std::os::raw::c_void,
    pub unused6: *mut ::std::os::raw::c_void,
    pub getPreviewFrameEx: plugGetPreviewFrameExFunc,
    pub getClipVideoBounds: plugGetClipVideoBoundsFunc,
    pub getClipVideoEx: plugGetClipVideoExFunc,
}
pub type PlugTimelineFuncsPtr = *mut PlugTimelineFuncs;
pub type prSuiteError = csSDK_int32;
pub const suiteError_NoError: prSuiteError = 0;
pub const suiteError_Fail: prSuiteError = -2147483648;
pub const suiteError_InvalidParms: prSuiteError = -2147483647;
pub const suiteError_OutOfMemory: prSuiteError = -2147483646;
pub const suiteError_InvalidCall: prSuiteError = -2147483645;
pub const suiteError_NotImplemented: prSuiteError = -2147483644;
pub const suiteError_IDNotValid: prSuiteError = -2147483643;
pub const suiteError_RenderPending: prSuiteError = 65536;
pub const suiteError_RenderedFrameNotFound: prSuiteError = 65537;
pub const suiteError_RenderedFrameCanceled: prSuiteError = 65538;
pub const suiteError_RenderInvalidPixelFormat: prSuiteError = -2147418112;
pub const suiteError_RenderCompletionProcNotSet: prSuiteError = -2147418111;
pub const suiteError_TimeRoundedAudioRate: prSuiteError = 131072;
pub const suiteError_CompilerCompileAbort: prSuiteError = 196609;
pub const suiteError_CompilerCompileDone: prSuiteError = 196610;
pub const suiteError_CompilerOutputFormatAccept: prSuiteError = 196612;
pub const suiteError_CompilerOutputFormatDecline: prSuiteError = 196613;
pub const suiteError_CompilerRebuildCutList: prSuiteError = 196614;
pub const suiteError_CompilerIterateCompiler: prSuiteError = 196615;
pub const suiteError_CompilerIterateCompilerDone: prSuiteError = 196616;
pub const suiteError_CompilerInternalErrorSilent: prSuiteError = 196617;
pub const suiteError_CompilerIterateCompilerCacheable: prSuiteError = 196618;
pub const suiteError_CompilerBadFormatIndex: prSuiteError = -2147287040;
pub const suiteError_CompilerInternalError: prSuiteError = -2147287039;
pub const suiteError_CompilerOutOfDiskSpace: prSuiteError = -2147287038;
pub const suiteError_CompilerBufferFull: prSuiteError = -2147287037;
pub const suiteError_CompilerErrOther: prSuiteError = -2147287036;
pub const suiteError_CompilerErrMemory: prSuiteError = -2147287035;
pub const suiteError_CompilerErrFileNotFound: prSuiteError = -2147287034;
pub const suiteError_CompilerErrTooManyOpenFiles: prSuiteError = -2147287033;
pub const suiteError_CompilerErrPermErr: prSuiteError = -2147287032;
pub const suiteError_CompilerErrOpenErr: prSuiteError = -2147287031;
pub const suiteError_CompilerErrInvalidDrive: prSuiteError = -2147287030;
pub const suiteError_CompilerErrDupFile: prSuiteError = -2147287029;
pub const suiteError_CompilerErrIo: prSuiteError = -2147287028;
pub const suiteError_CompilerErrInUse: prSuiteError = -2147287027;
pub const suiteError_CompilerErrCodecBadInput: prSuiteError = -2147287026;
pub const suiteError_ExporterSuspended: prSuiteError = -2147287025;
pub const suiteError_ExporterNoMoreFrames: prSuiteError = -2147287024;
pub const suiteError_FileBufferTooSmall: prSuiteError = -2147221504;
pub const suiteError_FileNotImportableFileType: prSuiteError = -2147221503;
pub const suiteError_LegacyInvalidVideoRate: prSuiteError = -2147155968;
pub const suiteError_PlayModuleAudioInitFailure: prSuiteError = -2147090432;
pub const suiteError_PlayModuleAudioIllegalPlaySetting: prSuiteError = -2147090431;
pub const suiteError_PlayModuleAudioNotInitialized: prSuiteError = -2147090430;
pub const suiteError_PlayModuleAudioNotStarted: prSuiteError = -2147090429;
pub const suiteError_PlayModuleAudioIllegalAction: prSuiteError = -2147090428;
pub const suiteError_PlayModuleDeviceControlSuiteIllegalCallSequence: prSuiteError = -2147024896;
pub const suiteError_MediaAcceleratorSuitePathNotFound: prSuiteError = -2146959360;
pub const suiteError_MediaAcceleratorSuiteRegisterFailure: prSuiteError = -2146959359;
pub const suiteError_RepositoryReadFailed: prSuiteError = -2146893824;
pub const suiteError_RepositoryWriteFailed: prSuiteError = -2146893823;
pub const suiteError_NotActivated: prSuiteError = -2146893822;
pub const suiteError_DataNotPresent: prSuiteError = -2146893821;
pub const suiteError_ServerCommunicationFailed: prSuiteError = -2146893820;
pub const suiteError_Internal: prSuiteError = -2146893819;
pub const suiteError_StringNotFound: prSuiteError = -2146828288;
pub const suiteError_StringBufferTooSmall: prSuiteError = -2146828287;
pub const suiteError_NoKeyframeAfterInTime: prSuiteError = -2146762752;
pub const suiteError_NoMoreData: prSuiteError = 786432;
pub const suiteError_InstanceDestroyed: prSuiteError = -2146631680;
pub const PrRenderQuality_kPrRenderQuality_Max: PrRenderQuality = 4;
pub const PrRenderQuality_kPrRenderQuality_High: PrRenderQuality = 3;
pub const PrRenderQuality_kPrRenderQuality_Medium: PrRenderQuality = 2;
pub const PrRenderQuality_kPrRenderQuality_Low: PrRenderQuality = 1;
pub const PrRenderQuality_kPrRenderQuality_Draft: PrRenderQuality = 0;
pub const PrRenderQuality_kPrRenderQuality_Invalid: PrRenderQuality = -1;
pub const PrRenderQuality_kPrRenderQuality_ForceEnumSize: PrRenderQuality = -1;
#[doc = "\tRender qualities"]
pub type PrRenderQuality = ::std::os::raw::c_int;
pub const PrPlaybackQuality_kPrPlaybackQuality_Invalid: PrPlaybackQuality = 4;
pub const PrPlaybackQuality_kPrPlaybackQuality_High: PrPlaybackQuality = 3;
pub const PrPlaybackQuality_kPrPlaybackQuality_Draft: PrPlaybackQuality = 2;
pub const PrPlaybackQuality_kPrPlaybackQuality_Auto: PrPlaybackQuality = 1;
pub const PrPlaybackQuality_kPrPlaybackQuality_ForceEnumSize: PrPlaybackQuality = -1;
#[doc = " Playback qualities"]
pub type PrPlaybackQuality = ::std::os::raw::c_int;
pub const PrPlaybackFractionalResolution_kPrPlaybackFractionalResolution_Invalid:
    PrPlaybackFractionalResolution = 6;
pub const PrPlaybackFractionalResolution_kPrPlaybackFractionalResolution_Sixteenth:
    PrPlaybackFractionalResolution = 5;
pub const PrPlaybackFractionalResolution_kPrPlaybackFractionalResolution_Eighth:
    PrPlaybackFractionalResolution = 4;
pub const PrPlaybackFractionalResolution_kPrPlaybackFractionalResolution_Quarter:
    PrPlaybackFractionalResolution = 3;
pub const PrPlaybackFractionalResolution_kPrPlaybackFractionalResolution_Half:
    PrPlaybackFractionalResolution = 2;
pub const PrPlaybackFractionalResolution_kPrPlaybackFractionalResolution_Full:
    PrPlaybackFractionalResolution = 1;
pub const PrPlaybackFractionalResolution_kPrPlaybackFractionalResolution_ForceEnumSize:
    PrPlaybackFractionalResolution = -1;
#[doc = " Playback Fractional Resolutions"]
pub type PrPlaybackFractionalResolution = ::std::os::raw::c_int;
#[doc = "\tTime overview:\n\n\tPremiere uses a tick-based time counter that is stored in a signed\n\t64-bit integer. The current number of ticks per second must be retrieved\n\tusing the callback in this suite, but is guaranteed to be constant for\n\tthe duration of runtime."]
pub type PrTime = prInt64;
#[doc = "\tRatioTime is used where value that are not representable by ticks are needed."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrRatioTime {
    pub mValue: prInt64,
    pub mScale: prInt64,
}
pub const PrVideoFrameRates_kVideoFrameRate_24Drop: PrVideoFrameRates = 1;
pub const PrVideoFrameRates_kVideoFrameRate_24: PrVideoFrameRates = 2;
pub const PrVideoFrameRates_kVideoFrameRate_PAL: PrVideoFrameRates = 3;
pub const PrVideoFrameRates_kVideoFrameRate_NTSC: PrVideoFrameRates = 4;
pub const PrVideoFrameRates_kVideoFrameRate_30: PrVideoFrameRates = 5;
pub const PrVideoFrameRates_kVideoFrameRate_PAL_HD: PrVideoFrameRates = 6;
pub const PrVideoFrameRates_kVideoFrameRate_NTSC_HD: PrVideoFrameRates = 7;
pub const PrVideoFrameRates_kVideoFrameRate_60: PrVideoFrameRates = 8;
pub const PrVideoFrameRates_kVideoFrameRate_Max: PrVideoFrameRates = -1;
pub type PrVideoFrameRates = ::std::os::raw::c_int;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKTimeSuite {
    #[doc = "\tGet the current ticks per second. This is guaranteed to be constant for\n\tthe duration of runtime.\n\n\t@param\toutTickPerSec\ton return, the number of time ticks per second."]
    pub GetTicksPerSecond:
        ::std::option::Option<unsafe extern "C" fn(outTicksPerSec: *mut PrTime) -> prSuiteError>,
    #[doc = "\tGet the number of ticks in a video frame rate.\n\n\t@param\tinFrameRate\t\tan enum value for a video frame rate.\n\t@param\toutTicksPerFrame\ton return, the number of time ticks per frame."]
    pub GetTicksPerVideoFrame: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoFrameRate: PrVideoFrameRates,
            outTicksPerFrame: *mut PrTime,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the number of ticks in an audio sample rate.\n\n\t@param\tinSampleRate\tthe audio sample rate as a float.\n\t@param\toutTicksPerSample\ton return, the number of time ticks per sample.\n\t@return\t\t\t\t\tkPrTimeSuite_RoundedAudioRate is returned if the requested\n\t\t\t\t\t\t\taudio sample rate is not an even divisor of the base tick\n\t\t\t\t\t\t\tcount and therefore times in this rate will not be exact."]
    pub GetTicksPerAudioSample: ::std::option::Option<
        unsafe extern "C" fn(inSampleRate: f32, outTicksPerSample: *mut PrTime) -> prSuiteError,
    >,
}
pub type PrRenderCacheType = csSDK_int32;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ClipFrameFormat {
    pub inPixelFormat: PrPixelFormat,
    pub inWidth: csSDK_int32,
    pub inHeight: csSDK_int32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKClipRenderSuite {
    #[doc = "\tDoes this clip support the clip render suite functions?\n\n\t@param\tinClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\toutSupported\t\t\t\t\t\tIf true, the clip supports the ClipRenderSuite.\n\t@param\toutAsyncIOSupported\t\t\t\t\tIf true, the clip supports asynchronous IO.\n\t\t\t\t\t\t\t\t\t\t\t\tIf false, the clip does not directly support asynchronous IO,\n\t\t\t\t\t\t\t\t\t\t\t\thowever it is still legal to call InitiateAsyncRead.\n\t\t\t\t\t\t\t\t\t\t\t\tPass nil if you do not need this information."]
    pub SupportsClipRenderSuite: ::std::option::Option<
        unsafe extern "C" fn(
            inClipID: PrClipID,
            outSupported: *mut prBool,
            outAsyncIOSupported: *mut prBool,
        ) -> prSuiteError,
    >,
    #[doc = "\tGiven a specific clip, find out the number of pixel formats natively supported\n\tby this clip.\n\n\t@param\tinClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\toutNumPixelFormats\t\t\t\t\tThe number of pixel formats."]
    pub GetNumPixelFormats: ::std::option::Option<
        unsafe extern "C" fn(
            inClipID: PrClipID,
            outNumPixelFormats: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGiven a specific clip get a native pixel format. The pixel formats will be returned\n\tin index order based on preference. The maximum index can be determined by using\n\tGetNumPixelFormats().\n\n\t@param\tinClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\tinIndex\t\t\t\t\t\t\t\tThe pixel format index.\n\t@param\toutPixelFormat\t\t\t\t\t\tThe pixel format."]
    pub GetPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            inClipID: PrClipID,
            inIndex: csSDK_int32,
            outPixelFormat: *mut PrPixelFormat,
        ) -> prSuiteError,
    >,
    #[doc = "\tGiven a specific clip and pixel format, find out the number of preferred\n\tframe sizes for this clip. A preferred frame size is a size which represents\n\ta \"native\" size of the media.\n\n\t@param\tinClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\tinPixelFormat\t\t\t\t\t\tThe pixel format to query for preferrred sizes.\n\t@param\toutNumPreferredFrameSizes\t\t\tThe number of sizes for this clip and pixel format."]
    pub GetNumPreferredFrameSizes: ::std::option::Option<
        unsafe extern "C" fn(
            inClipID: PrClipID,
            inPixelFormat: PrPixelFormat,
            outNumPreferredFrameSizes: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGiven a specific clip and pixel format, get a preferred size. The sizes will be returned\n\tin index order based on preference. The maximum index can be determined by using\n\tGetNumPreferredFrameSizes().\n\n\t@param\tinClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\tinPixelFormat\t\t\t\t\t\tThe pixel format to query for preferrred sizes.\n\t@param\tinIndex\t\t\t\t\t\t\t\tThe preferred size index.\n\t@param\toutWidth\t\t\t\t\t\t\tThe width of the preferred size. 0 means any width.\n\t@param\toutHeight\t\t\t\t\t\t\tThe height of the preferred size. 0 means any height."]
    pub GetPreferredFrameSize: ::std::option::Option<
        unsafe extern "C" fn(
            inClipID: PrClipID,
            inPixelFormat: PrPixelFormat,
            inIndex: csSDK_int32,
            outWidth: *mut csSDK_int32,
            outHeight: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tInitiate an asynchronous read for the specified frame. Note that you cannot specify\n\ta specific frame format here. The clip will prefetch whatever data possible to\n\tfacilitate a faster decode, and return.\n\n\t@param\tinClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\tinFrameTime\t\t\t\t\t\t\tThe time of the video frame number.\n\t@param\tinFormat\t\t\t\t\t\t\tThe preferred format for the frame."]
    pub InitiateAsyncRead: ::std::option::Option<
        unsafe extern "C" fn(
            inClipID: PrClipID,
            inFrameTime: *const PrTime,
            inFormat: *mut ClipFrameFormat,
        ) -> prSuiteError,
    >,
    #[doc = "\tCancel an asynchronous read for the specified frame. Note that you cannot specify\n\ta specific frame format here.\n\n\t@param\tinClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\tinFrameTime\t\t\t\t\t\t\tThe time of the video frame number.\n\t@param\tinFormat\t\t\t\t\t\t\tThe preferred format for the frame."]
    pub CancelAsyncRead: ::std::option::Option<
        unsafe extern "C" fn(
            inClipID: PrClipID,
            inFrameTime: *const PrTime,
            inFormat: *mut ClipFrameFormat,
        ) -> prSuiteError,
    >,
    #[doc = "\tFind a frame of a specific format in the cache. This function will first look\n\tfor a match in the supplied list of formats. If it does not find one, it will\n\task the importer to decode one out of cached raw data. It will not access the\n\tdisk for new raw data, so it will fail if the required data is not in the cache.\n\n\t@param  inClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\tinFrameTime\t\t\t\t\t\t\tThe time of the video frame number.\n\t@param\tinFormats\t\t\t\t\t\t\tAn array of formats that would be acceptable.\n\t\t\t\t\t\t\t\t\t\t\t\tEach format must be a combination of\n\t\t\t\t\t\t\t\t\t\t\t\tsupported pixel formats and preferred frame\n\t\t\t\t\t\t\t\t\t\t\t\tsizes. May be NULL, in which case in format\n\t\t\t\t\t\t\t\t\t\t\t\tmay be returned.\n\t@param\tinNumFormats\t\t\t\t\t\tThe number of items in inFormats. May be 0.\n\t@param\tinSynchronous\t\t\t\t\t\tIf true, the function will render the file from disk if necessary\n\t@param\toutFrame\t\t\t\t\t\t\tThe found frame. May be NULL if it was not found."]
    pub FindFrame: ::std::option::Option<
        unsafe extern "C" fn(
            inClipID: PrClipID,
            inFrameTime: *const PrTime,
            inFormats: *mut ClipFrameFormat,
            inNumFormats: csSDK_int32,
            inSynchronous: bool,
            outFrame: *mut PPixHand,
        ) -> prSuiteError,
    >,
    #[doc = "\tWhat is the field type of this clip? Added in version 2.\n\n\t@param\tinClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\toutFieldType\t\t\t\t\t\tSee prFieldType in PrSDKTypes.h"]
    pub GetClipFieldType: ::std::option::Option<
        unsafe extern "C" fn(inClipID: PrClipID, outFieldType: *mut prFieldType) -> prSuiteError,
    >,
    #[doc = "\tGiven a specific clip, find out the number of custom pixel formats natively supported\n\tby this clip.\n\n\t@param\tinClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\toutNumPixelFormats\t\t\t\t\tThe number of pixel formats."]
    pub GetNumCustomPixelFormats: ::std::option::Option<
        unsafe extern "C" fn(
            inClipID: PrClipID,
            outNumPixelFormats: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGiven a specific clip get a native pixel format. The pixel formats will be returned\n\tin index order based on preference. The maximum index can be determined by using\n\tGetNumPixelFormats().\n\n\t@param\tinClipID\t\t\t\t\t\t\tThe ClipID of the clip.\n\t@param\tinIndex\t\t\t\t\t\t\t\tThe pixel format index.\n\t@param\toutPixelFormat\t\t\t\t\t\tThe pixel format."]
    pub GetCustomPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            inClipID: PrClipID,
            inIndex: csSDK_int32,
            outPixelFormat: *mut PrPixelFormat,
        ) -> prSuiteError,
    >,
}
#[doc = "!Indicates Data Group"]
pub const PrDSGroupChildType_kPrDSGroupType_GROUP: PrDSGroupChildType = 0;
#[doc = "!Indicates Dynamic Group"]
pub const PrDSGroupChildType_kPrDSGroupType_DYNAMIC_DATA: PrDSGroupChildType = 1;
#[doc = "!Indicates Static Group"]
pub const PrDSGroupChildType_kPrDSGroupType_STATIC_DATA: PrDSGroupChildType = 2;
#[doc = "!Indicates invalid entry"]
pub const PrDSGroupChildType_kPrDSGroupType_INVALID: PrDSGroupChildType = 3;
#[doc = "\tDefines data stream types"]
pub type PrDSGroupChildType = ::std::os::raw::c_int;
pub type plugNewPtrFunc =
    ::std::option::Option<unsafe extern "C" fn(size: csSDK_uint32) -> *mut ::std::os::raw::c_char>;
pub type plugSetPtrSizeFunc =
    ::std::option::Option<unsafe extern "C" fn(ptr: *mut PrMemoryPtr, newsize: csSDK_uint32)>;
pub type plugGetPtrSizeFunc =
    ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_char) -> csSDK_int32>;
pub type plugDisposePtrFunc =
    ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_char)>;
pub type plugNewHandleFunc = ::std::option::Option<
    unsafe extern "C" fn(size: csSDK_uint32) -> *mut *mut ::std::os::raw::c_char,
>;
pub type plugSetHandleSizeFunc = ::std::option::Option<
    unsafe extern "C" fn(h: PrMemoryHandle, newsize: csSDK_uint32) -> csSDK_int16,
>;
pub type plugGetHandleSizeFunc =
    ::std::option::Option<unsafe extern "C" fn(h: PrMemoryHandle) -> csSDK_int32>;
pub type plugDisposeHandleFunc = ::std::option::Option<unsafe extern "C" fn(h: PrMemoryHandle)>;
pub type plugNewPtrClearFunc =
    ::std::option::Option<unsafe extern "C" fn(size: csSDK_uint32) -> *mut ::std::os::raw::c_char>;
pub type plugNewHandleClearFunc = ::std::option::Option<
    unsafe extern "C" fn(size: csSDK_uint32) -> *mut *mut ::std::os::raw::c_char,
>;
pub type plugLockHandleFunc = ::std::option::Option<unsafe extern "C" fn(h: PrMemoryHandle)>;
pub type plugUnlockHandleFunc = ::std::option::Option<unsafe extern "C" fn(h: PrMemoryHandle)>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PlugMemoryFuncs {
    pub newPtr: plugNewPtrFunc,
    pub setPtrSize: plugSetPtrSizeFunc,
    pub getPtrSize: plugGetPtrSizeFunc,
    pub disposePtr: plugDisposePtrFunc,
    pub newHandle: plugNewHandleFunc,
    pub setHandleSize: plugSetHandleSizeFunc,
    pub getHandleSize: plugGetHandleSizeFunc,
    pub disposeHandle: plugDisposeHandleFunc,
    pub newPtrClear: plugNewPtrClearFunc,
    pub newHandleClear: plugNewHandleClearFunc,
    pub lockHandle: plugLockHandleFunc,
    pub unlockHandle: plugUnlockHandleFunc,
}
pub type PlugMemoryFuncsPtr = *mut PlugMemoryFuncs;
pub type plugUpdateAllWindowsFunc = ::std::option::Option<unsafe extern "C" fn()>;
pub type plugGetMainWindFunc =
    ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PlugWindowFuncs {
    pub updateAllWindows: plugUpdateAllWindowsFunc,
    pub getMainWnd: plugGetMainWindFunc,
}
pub type PlugWindowFuncsPtr = *mut PlugWindowFuncs;
pub type plugppixGetPixelsFunc =
    ::std::option::Option<unsafe extern "C" fn(pix: PPixHand) -> *mut ::std::os::raw::c_char>;
pub type plugppixGetBoundsFunc =
    ::std::option::Option<unsafe extern "C" fn(pix: PPixHand, bounds: *mut prRect)>;
pub type plugppixGetRowbytesFunc =
    ::std::option::Option<unsafe extern "C" fn(pix: PPixHand) -> ::std::os::raw::c_int>;
pub type plugppixNewFunc =
    ::std::option::Option<unsafe extern "C" fn(bounds: *mut prRect) -> PPixHand>;
pub type plugppixDisposeFunc = ::std::option::Option<unsafe extern "C" fn(ppix: PPixHand)>;
pub type plugppixLockFunc = ::std::option::Option<unsafe extern "C" fn(pix: PPixHand)>;
pub type plugppixUnlockFunc = ::std::option::Option<unsafe extern "C" fn(pix: PPixHand)>;
pub type plugppixGetPixelAspectRatioFunc = ::std::option::Option<
    unsafe extern "C" fn(
        pix: PPixHand,
        num: *mut csSDK_uint32,
        den: *mut csSDK_uint32,
    ) -> ::std::os::raw::c_int,
>;
pub type plugppixGetAlphaBounds =
    ::std::option::Option<unsafe extern "C" fn(pix: PPixHand, alphaBounds: *mut prRect)>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PlugppixFuncs {
    pub ppixGetPixels: plugppixGetPixelsFunc,
    pub ppixGetBounds: plugppixGetBoundsFunc,
    pub ppixGetRowbytes: plugppixGetRowbytesFunc,
    pub ppixNew: plugppixNewFunc,
    pub ppixDispose: plugppixDisposeFunc,
    pub ppixLockPixels: plugppixLockFunc,
    pub ppixUnlockPixels: plugppixUnlockFunc,
    pub ppixGetPixelAspectRatio: plugppixGetPixelAspectRatioFunc,
    pub ppixGetAlphaBounds: plugppixGetAlphaBounds,
}
pub type PlugppixFuncsPtr = *mut PlugppixFuncs;
pub type SPBoolean = ::std::os::raw::c_int;
pub type SPErr = ::std::os::raw::c_int;
#[doc = " @ingroup Suites\nThis suite provides basic memory management for PICA (the Adobe plug-in manager)\nand defines the basic functions for acquiring and releasing other suites.\n\nA suite consists of a list of function pointers. The application, or a\nplug-in that loads a suite, provides valid pointers when the suite is\nacquired. When a suite is not available, the pointers are set to the\naddress of the \\c #Undefined() function.\n\nDo not attempt to acquire a suite (other than the \\c #SPBlocksSuite)\nin response to a PICA access (\\c #kSPAccessCaller) or property\n(\\c #kSPPropertiesCaller) message. Most suites are unavailable\nduring these load and unload operations.\n\nYou can acquire all the suites you will need when your plug-in is first\nloaded, as long as you release them before your plug-in is unloaded.\nAt shutdown, however, it is most efficient to acquire only those\nsuites explicitly needed to shut down; for example, to free memory\nand save preferences.\n\nThe \\c SPBasicSuite itself is a part of the message data passed\nto your plug-in with any call. To access it from the message data structure:\n@code\nSPBasicSuite sBasic = message->d.basic;\nsBasic->function( )\n@endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPBasicSuite {
    #[doc = " Acquires a function suite. Loads the suite if necessary,\nand increments its reference count. For example:\n@code\nSPErr error;\nSPBasicSuite *sBasic = message->d.basic;\nAIRandomSuite *sRandom;\nsBasic->AcquireSuite( kAIRandomSuite, kAIRandomVersion, &sRandom );\n@endcode\n@param name The suite name.\n@param version The suite version number.\n@param suite [out] A buffer in which to return the suite pointer.\n@see \\c #SPSuitesSuite::AcquireSuite()"]
    pub AcquireSuite: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            version: ::std::os::raw::c_int,
            suite: *mut *const ::std::os::raw::c_void,
        ) -> SPErr,
    >,
    #[doc = " Decrements the reference count of a suite and unloads it when the\nreference count reaches 0.\n@param name The suite name.\n@param version The suite version number."]
    pub ReleaseSuite: ::std::option::Option<
        unsafe extern "C" fn(
            name: *const ::std::os::raw::c_char,
            version: ::std::os::raw::c_int,
        ) -> SPErr,
    >,
    #[doc = " Compares two strings for equality.\n@param token1 The first null-terminated string.\n@param token2 The second null-terminated string.\n@return True if the strings are the same, false otherwise."]
    pub IsEqual: ::std::option::Option<
        unsafe extern "C" fn(
            token1: *const ::std::os::raw::c_char,
            token2: *const ::std::os::raw::c_char,
        ) -> SPBoolean,
    >,
    #[doc = " Allocates a block of memory.\n@param size The number of bytes.\n@param block [out] A buffer in which to return the block pointer.\n@see \\c #SPBlocksSuite::AllocateBlock()"]
    pub AllocateBlock: ::std::option::Option<
        unsafe extern "C" fn(size: usize, block: *mut *mut ::std::os::raw::c_void) -> SPErr,
    >,
    #[doc = " Frees a block of memory allocated with \\c #AllocateBlock().\n@param block The block pointer.\n@see \\c #SPBlocksSuite::FreeBlock()"]
    pub FreeBlock:
        ::std::option::Option<unsafe extern "C" fn(block: *mut ::std::os::raw::c_void) -> SPErr>,
    #[doc = " Reallocates a block previously allocated with \\c #AllocateBlock().\nIncreases the size without changing the location, if possible.\n@param block The block pointer.\n@param newSize The new number of bytes.\n@param newblock [out] A buffer in which to return the new block pointer.\n@see \\c #SPBlocksSuite::ReallocateBlock()"]
    pub ReallocateBlock: ::std::option::Option<
        unsafe extern "C" fn(
            block: *mut ::std::os::raw::c_void,
            newSize: usize,
            newblock: *mut *mut ::std::os::raw::c_void,
        ) -> SPErr,
    >,
    #[doc = " A function pointer for unloaded suites. This is a protective measure\nagainst other plug-ins that may mistakenly use the suite after they have\nreleased it.\n\nA plug-in that exports a suite should unload the suite's procedure pointers\nwhen it is unloaded, and restore them when the plug-in is reloaded.\n\\li On unload, replace the suite's procedure pointers\nwith the address of this function.\n\\li On reload, restore the suite's procedure\npointers with the updated addresses of their functions.\n\nFor example:\n@code\nSPErr UnloadSuite( MySuite *mySuite, SPAccessMessage *message ) {\nmySuite->functionA = (void *) message->d.basic->Undefined;\nmySuite->functionB = (void *) message->d.basic->Undefined;\n}\n\nSPErr ReloadSuite( MySuite *mySuite, SPAccessMessage *message ) {\nmySuite->functionA = functionA;\nmySuite->functionB = functionB;\n}\n@endcode"]
    pub Undefined: ::std::option::Option<unsafe extern "C" fn() -> SPErr>,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct prTimebaseRec {
    pub duration: csSDK_int32,
    pub scale: csSDK_int32,
    pub sampleSize: csSDK_int32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct prFileSpec {
    pub volID: ::std::os::raw::c_int,
    pub parID: ::std::os::raw::c_int,
    pub name: [::std::os::raw::c_char; 256usize],
}
pub type plugGetSerialNumberFunc =
    ::std::option::Option<unsafe extern "C" fn(result: *mut ::std::os::raw::c_char)>;
pub type plugGetFileTimebaseFunc = ::std::option::Option<
    unsafe extern "C" fn(
        filespec: *mut prFileSpec,
        audioOnly: csSDK_int32,
        result: *mut prTimebaseRec,
    ) -> csSDK_int32,
>;
pub type plugGetFileVideoFunc = ::std::option::Option<
    unsafe extern "C" fn(
        filespec: *mut prFileSpec,
        frame: csSDK_int32,
        thePort: PPixHand,
        bounds: *mut prRect,
        flags: csSDK_int32,
    ) -> csSDK_int32,
>;
pub type plugGetFileAudioSecondFunc = ::std::option::Option<
    unsafe extern "C" fn(
        filespec: *mut prFileSpec,
        num: csSDK_int32,
        buffer: *mut ::std::os::raw::c_char,
        flags: ::std::os::raw::c_short,
        audrate: csSDK_int32,
        speed: ::std::os::raw::c_short,
    ) -> csSDK_int32,
>;
pub type plugGetFileVideoBoundsFunc = ::std::option::Option<
    unsafe extern "C" fn(filespec: *mut prFileSpec, bounds: *mut prRect) -> csSDK_int32,
>;
pub type plugGetSPBasicSuiteFunc =
    ::std::option::Option<unsafe extern "C" fn() -> *mut SPBasicSuite>;
pub type plugGetFileExtStringFunc = ::std::option::Option<
    unsafe extern "C" fn(
        fileTypes: csSDK_uint32,
        inBuffer: *mut ::std::os::raw::c_char,
        inBufferSize: csSDK_uint32,
    ) -> csSDK_int32,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PlugUtilFuncs {
    pub unused1: *mut ::std::os::raw::c_void,
    pub getSerialNumber: plugGetSerialNumberFunc,
    pub getFileTimebase: plugGetFileTimebaseFunc,
    pub getFileVideo: plugGetFileVideoFunc,
    pub getFileAudioSecond: plugGetFileAudioSecondFunc,
    pub unused2: *mut ::std::os::raw::c_void,
    pub getFileVideoBounds: plugGetFileVideoBoundsFunc,
    pub getSPBasicSuite: plugGetSPBasicSuiteFunc,
    pub getFileExtString: plugGetFileExtStringFunc,
}
pub type PlugUtilFuncsPtr = *mut PlugUtilFuncs;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct piSuites {
    pub piInterfaceVer: ::std::os::raw::c_int,
    pub memFuncs: PlugMemoryFuncsPtr,
    pub windFuncs: PlugWindowFuncsPtr,
    pub ppixFuncs: PlugppixFuncsPtr,
    pub utilFuncs: PlugUtilFuncsPtr,
    pub timelineFuncs: PlugTimelineFuncsPtr,
}
pub type piSuitesPtr = *mut piSuites;
pub type Print2TapeProcPtr = ::std::option::Option<
    unsafe extern "C" fn(
        deviceHand: PrMemoryHandle,
        selector: ::std::os::raw::c_long,
    ) -> csSDK_int32,
>;
pub const PrDeviceSelector_dsInit: PrDeviceSelector = 0;
pub const PrDeviceSelector_dsSetup: PrDeviceSelector = 1;
pub const PrDeviceSelector_dsExecute: PrDeviceSelector = 2;
pub const PrDeviceSelector_dsCleanup: PrDeviceSelector = 3;
pub const PrDeviceSelector_dsRestart: PrDeviceSelector = 4;
pub const PrDeviceSelector_dsQuiet: PrDeviceSelector = 5;
pub const PrDeviceSelector_dsHasOptions: PrDeviceSelector = 6;
pub const PrDeviceSelector_dsSelector_Size: PrDeviceSelector = -1;
#[doc = "\tSelectors"]
pub type PrDeviceSelector = ::std::os::raw::c_int;
pub const PrTransitionReturnValue_esNoErr: PrTransitionReturnValue = 0;
pub const PrTransitionReturnValue_esBadFormatIndex: PrTransitionReturnValue = 1;
pub const PrTransitionReturnValue_esDoNotCacheOnLoad: PrTransitionReturnValue = 2;
pub const PrTransitionReturnValue_esUnsupported: PrTransitionReturnValue = -100;
pub const PrTransitionReturnValue_esErr_Size: PrTransitionReturnValue = -1;
#[doc = "\tError Definitions"]
pub type PrTransitionReturnValue = ::std::os::raw::c_int;
pub const PrFilterReturnValue_fsNoErr: PrFilterReturnValue = 0;
pub const PrFilterReturnValue_fsBadFormatIndex: PrFilterReturnValue = 1;
pub const PrFilterReturnValue_fsDoNotCacheOnLoad: PrFilterReturnValue = 2;
pub const PrFilterReturnValue_fsHasNoSetupDialog: PrFilterReturnValue = 3;
pub const PrFilterReturnValue_fsUnsupported: PrFilterReturnValue = -100;
pub const PrFilterReturnValue_fsErr_Size: PrFilterReturnValue = -1;
pub type PrFilterReturnValue = ::std::os::raw::c_int;
pub const PrTransitionSelector_esExecute: PrTransitionSelector = 0;
pub const PrTransitionSelector_esSetup: PrTransitionSelector = 1;
pub const PrTransitionSelector_esUnused1: PrTransitionSelector = 2;
pub const PrTransitionSelector_esUnused2: PrTransitionSelector = 3;
pub const PrTransitionSelector_esUnused3: PrTransitionSelector = 4;
pub const PrTransitionSelector_esDisposeData: PrTransitionSelector = 5;
pub const PrTransitionSelector_esCanHandlePAR: PrTransitionSelector = 6;
pub const PrTransitionSelector_esGetPixelFormatsSupported: PrTransitionSelector = 7;
pub const PrTransitionSelector_esCacheOnLoad: PrTransitionSelector = 8;
pub const PrTransitionSelector_esSelector_Size: PrTransitionSelector = -1;
#[doc = "\tSelectors"]
pub type PrTransitionSelector = ::std::os::raw::c_int;
pub const PrFilterSelector_fsExecute: PrFilterSelector = 0;
pub const PrFilterSelector_fsSetup: PrFilterSelector = 1;
pub const PrFilterSelector_fsAbout: PrFilterSelector = 2;
pub const PrFilterSelector_fsDisposeData: PrFilterSelector = 3;
pub const PrFilterSelector_fsCanHandlePAR: PrFilterSelector = 4;
pub const PrFilterSelector_fsInitSpec: PrFilterSelector = 5;
pub const PrFilterSelector_fsGetPixelFormatsSupported: PrFilterSelector = 6;
pub const PrFilterSelector_fsCacheOnLoad: PrFilterSelector = 7;
pub const PrFilterSelector_fsHasSetupDialog: PrFilterSelector = 8;
pub const PrFilterSelector_fsSelector_Size: PrFilterSelector = -1;
pub type PrFilterSelector = ::std::os::raw::c_int;
#[doc = "\tError overview:\n\n\tPlugins are allowed to send errors, warning, and information to 3 different\n\tcallbacks which will be handled by Premiere. For each, the plugin passes a string\n\tand a context ID from their plugin type (for instance, a CompilerID from the a\n\tcompiler). Then the plugin returns an error code defined in the appropriate\n\tplugin type header which will tell Premiere that there is an error with description\n\twaiting. Currently, Premiere concatenates all strings that it receives of each type\n\tuntil they can be displayed."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKErrorSuite1 {
    #[doc = "\tSet the plugin error string for Premiere.\n\n\t@param\tinErrorString\tA NULL terminated string for the error. Premiere will\n\t\t\t\t\t\t\tcopy this string, so the caller can delete it after\n\t\t\t\t\t\t\tthe function returns.\n\t@param\tinContextID\t\tThe context ID passed to the plugin."]
    pub SetErrorString: ::std::option::Option<
        unsafe extern "C" fn(
            inErrorString: *const ::std::os::raw::c_char,
            inContextID: csSDK_uint32,
        ) -> prSuiteError,
    >,
    #[doc = "\tSet the plugin error string for Premiere.\n\n\t@param\tinWarningString\tA NULL terminated string for the warning. Premiere will\n\t\t\t\t\t\t\tcopy this string, so the caller can delete it after\n\t\t\t\t\t\t\tthe function returns.\n\t@param\tinContextID\t\tThe context ID passed to the plugin."]
    pub SetWarningString: ::std::option::Option<
        unsafe extern "C" fn(
            inWarningString: *const ::std::os::raw::c_char,
            inContextID: csSDK_uint32,
        ) -> prSuiteError,
    >,
    #[doc = "\tSet the plugin error string for Premiere.\n\n\t@param\tinInfoString\tA NULL terminated string for the info. Premiere will\n\t\t\t\t\t\t\tcopy this string, so the caller can delete it after\n\t\t\t\t\t\t\tthe function returns.\n\t@param\tinContextID\t\tThe context ID passed to the plugin."]
    pub SetInfoString: ::std::option::Option<
        unsafe extern "C" fn(
            inInfoString: *const ::std::os::raw::c_char,
            inContextID: csSDK_uint32,
        ) -> prSuiteError,
    >,
}
#[doc = "\tVersion 2 changes:\n\tThe suite has been streamlined for this release.  In addition, the\n\tstring has been broken into two parts, a title and a description.  This\n\tseparation works well with the new Events Window."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKErrorSuite2 {
    pub SetEventString: ::std::option::Option<
        unsafe extern "C" fn(
            eventType: csSDK_uint32,
            eventTitle: *const ::std::os::raw::c_char,
            eventDescription: *const ::std::os::raw::c_char,
        ) -> prSuiteError,
    >,
}
pub const PrSDKErrorSuite2_kEventTypeInformational: PrSDKErrorSuite2__bindgen_ty_1 = 1;
pub const PrSDKErrorSuite2_kEventTypeWarning: PrSDKErrorSuite2__bindgen_ty_1 = 2;
pub const PrSDKErrorSuite2_kEventTypeError: PrSDKErrorSuite2__bindgen_ty_1 = 3;
pub type PrSDKErrorSuite2__bindgen_ty_1 = ::std::os::raw::c_int;
#[doc = "\tVersion 3 changes:\n\tAdd UTF16 string support"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKErrorSuite3 {
    pub SetEventStringUnicode: ::std::option::Option<
        unsafe extern "C" fn(
            eventType: csSDK_uint32,
            eventTitle: *mut prUTF16Char,
            eventDescription: *mut prUTF16Char,
        ) -> prSuiteError,
    >,
}
pub const PrSDKErrorSuite3_kEventTypeInformational: PrSDKErrorSuite3__bindgen_ty_1 = 1;
pub const PrSDKErrorSuite3_kEventTypeWarning: PrSDKErrorSuite3__bindgen_ty_1 = 2;
pub const PrSDKErrorSuite3_kEventTypeError: PrSDKErrorSuite3__bindgen_ty_1 = 3;
pub const PrSDKErrorSuite3_kEventType_Mask: PrSDKErrorSuite3__bindgen_ty_1 = 255;
pub const PrSDKErrorSuite3_kEventFlag_DecodeError: PrSDKErrorSuite3__bindgen_ty_1 = 256;
pub const PrSDKErrorSuite3_kEventFlag_SubstitutedFrame: PrSDKErrorSuite3__bindgen_ty_1 = 512;
pub const PrSDKErrorSuite3_kEventFlag_ImportOperation: PrSDKErrorSuite3__bindgen_ty_1 = 1024;
pub type PrSDKErrorSuite3__bindgen_ty_1 = ::std::os::raw::c_int;
#[doc = "\tVersion 3 changes:\n\tAdd UTF16 string support"]
pub type PrSDKErrorSuite = PrSDKErrorSuite3;
pub const PrGPUDeviceFramework_PrGPUDeviceFramework_CUDA: PrGPUDeviceFramework = 0;
pub const PrGPUDeviceFramework_PrGPUDeviceFramework_OpenCL: PrGPUDeviceFramework = 1;
pub const PrGPUDeviceFramework_PrGPUDeviceFramework_Metal: PrGPUDeviceFramework = 2;
pub type PrGPUDeviceFramework = ::std::os::raw::c_int;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrGPUDeviceInfo {
    pub outDeviceFramework: PrGPUDeviceFramework,
    pub outMeetsMinimumRequirementsForAcceleration: prBool,
    pub outPlatformHandle: *mut ::std::os::raw::c_void,
    pub outDeviceHandle: *mut ::std::os::raw::c_void,
    pub outContextHandle: *mut ::std::os::raw::c_void,
    pub outCommandQueueHandle: *mut ::std::os::raw::c_void,
    pub outOffscreenOpenGLContextHandle: *mut ::std::os::raw::c_void,
    pub outOffscreenOpenGLDeviceHandle: *mut ::std::os::raw::c_void,
}
#[doc = "\tAccess CUDA or OpenCL devices.\n\t\tAll CUDA usage is through the CUDA device API."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKGPUDeviceSuite {
    #[doc = "\tDevice enumeration"]
    pub GetDeviceCount: ::std::option::Option<
        unsafe extern "C" fn(outDeviceCount: *mut csSDK_uint32) -> prSuiteError,
    >,
    pub GetDeviceInfo: ::std::option::Option<
        unsafe extern "C" fn(
            inSuiteVersion: csSDK_uint32,
            inDeviceIndex: csSDK_uint32,
            outDeviceInfo: *mut PrGPUDeviceInfo,
        ) -> prSuiteError,
    >,
    #[doc = "\tAcquire/release exclusive access to inDeviceIndex. All calls below this point generally require access be held.\n\tFor full GPU plugins (those that use a separate entry point for GPU rendering) exclusive access is always held.\n\tThese calls do not need to be made in that case.\n\t\tFor CUDA calls cuCtxPushCurrent/cuCtxPopCurrent on the current thread to manage the devices context."]
    pub AcquireExclusiveDeviceAccess:
        ::std::option::Option<unsafe extern "C" fn(inDeviceIndex: csSDK_uint32) -> prSuiteError>,
    pub ReleaseExclusiveDeviceAccess:
        ::std::option::Option<unsafe extern "C" fn(inDeviceIndex: csSDK_uint32) -> prSuiteError>,
    #[doc = "\tAll device memory must be allocated through this suite.\n\t\tPurge should be called only in emergency situations when working with GPU memory\n\t\t\tthat cannot be allocated through this suite (eg OpenGL memory).\n\t\tReturned pointer value represents memory allocated through cuMemAlloc or clCreateBuffer."]
    pub AllocateDeviceMemory: ::std::option::Option<
        unsafe extern "C" fn(
            inDeviceIndex: csSDK_uint32,
            inSizeInBytes: usize,
            outMemory: *mut *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    pub FreeDeviceMemory: ::std::option::Option<
        unsafe extern "C" fn(
            inDeviceIndex: csSDK_uint32,
            inMemory: *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    pub PurgeDeviceMemory: ::std::option::Option<
        unsafe extern "C" fn(
            inDeviceIndex: csSDK_uint32,
            inRequestedBytesToPurge: usize,
            outBytesPurged: *mut usize,
        ) -> prSuiteError,
    >,
    #[doc = "\tAll host (pinned) memory must be allocated through this suite.\n\t\tPurge should be called only in emergency situations when working with GPU memory\n\t\t\tthat cannot be allocated through this suite (eg OpenGL memory).\n\t\tReturned pointer value represents memory allocated through cuMemHostAlloc or malloc."]
    pub AllocateHostMemory: ::std::option::Option<
        unsafe extern "C" fn(
            inDeviceIndex: csSDK_uint32,
            inSizeInBytes: usize,
            outMemory: *mut *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    pub FreeHostMemory: ::std::option::Option<
        unsafe extern "C" fn(
            inDeviceIndex: csSDK_uint32,
            inMemory: *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    pub PurgeHostMemory: ::std::option::Option<
        unsafe extern "C" fn(
            inDeviceIndex: csSDK_uint32,
            inRequestedBytesToPurge: usize,
            outBytesPurged: *mut usize,
        ) -> prSuiteError,
    >,
    #[doc = "\tInformation on a GPU ppix. The following ppix functions may also be used:\n\t\t-PrSDKPPixSuite::Dispose\n\t\t-PrSDKPPixSuite::GetBounds\n\t\t-PrSDKPPixSuite::GetRowBytes\n\t\t-PrSDKPPixSuite::GetPixelAspectRatio\n\t\t-PrSDKPPixSuite::GetPixelFormat\n\t\t-PrSDKPPix2Suite::GetFieldOrder"]
    pub CreateGPUPPix: ::std::option::Option<
        unsafe extern "C" fn(
            inDeviceIndex: csSDK_uint32,
            inPixelFormat: PrPixelFormat,
            inWidth: ::std::os::raw::c_int,
            inHeight: ::std::os::raw::c_int,
            inPARNumerator: ::std::os::raw::c_int,
            inPARDenominator: ::std::os::raw::c_int,
            inFieldType: prFieldType,
            outPPixHand: *mut PPixHand,
        ) -> prSuiteError,
    >,
    pub GetGPUPPixData: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixHand: PPixHand,
            outData: *mut *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    pub GetGPUPPixDeviceIndex: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixHand: PPixHand,
            outDeviceIndex: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
    pub GetGPUPPixSize: ::std::option::Option<
        unsafe extern "C" fn(inPPixHand: PPixHand, outSize: *mut usize) -> prSuiteError,
    >,
}
pub const PrAudioSampleType_kPrAudioSampleType_8BitInt: PrAudioSampleType = 1;
pub const PrAudioSampleType_kPrAudioSampleType_8BitTwosInt: PrAudioSampleType = 2;
pub const PrAudioSampleType_kPrAudioSampleType_16BitInt: PrAudioSampleType = 3;
pub const PrAudioSampleType_kPrAudioSampleType_24BitInt: PrAudioSampleType = 4;
pub const PrAudioSampleType_kPrAudioSampleType_32BitInt: PrAudioSampleType = 5;
pub const PrAudioSampleType_kPrAudioSampleType_32BitFloat: PrAudioSampleType = 6;
pub const PrAudioSampleType_kPrAudioSampleType_64BitFloat: PrAudioSampleType = 7;
pub const PrAudioSampleType_kPrAudioSampleType_16BitIntBigEndian: PrAudioSampleType = 8;
pub const PrAudioSampleType_kPrAudioSampleType_24BitIntBigEndian: PrAudioSampleType = 9;
pub const PrAudioSampleType_kPrAudioSampleType_32BitIntBigEndian: PrAudioSampleType = 10;
pub const PrAudioSampleType_kPrAudioSampleType_32BitFloatBigEndian: PrAudioSampleType = 11;
pub const PrAudioSampleType_kPrAudioSampleType_Compressed: PrAudioSampleType = 12;
pub const PrAudioSampleType_kPrAudioSampleType_Packed: PrAudioSampleType = 13;
pub const PrAudioSampleType_kPrAudioSampleType_Other: PrAudioSampleType = 14;
pub const PrAudioSampleType_kPrAudioSampleType_Any: PrAudioSampleType = 15;
pub const PrAudioSampleType_kPrAudioSampleType_AudioPeakData: PrAudioSampleType = 16;
pub const PrAudioSampleType_kPrAudioSampleType_Max: PrAudioSampleType = -1;
#[doc = "\tAudio overview:\n\n\tAll audio calls to and from Premiere use arrays of buffers of 32-bit\n\tfloats to pass audio. Therefore all audio is not interleaved by channel.\n\tSo stereo audio looks like this:\n\n\tfloat* audio[2];\n\n\twhere audio[0] is the address of a buffer N samples long and audio[1]\n\tis the address of a second buffer N samples long. audio[0] contains\n\tthe left channel and audio[1] contains the right channel. N is called\n\tthe number of \"sample frames\" in the buffer. N will be the same no matter\n\thow many channels of audio are present in the buffer.\n\n\tBecause we use 32-bit floats for each audio sample, we can represent\n\tvalues above 0 dB during mixing. 0 dB corresponds to +/- 1.0 in the floating\n\tpoint. For symmetry in the int <--> float conversions, it is recommended\n\tyou use the utility functions below.  For example if you want to convert\n\ta single float to a 16-bit signed int, use ConvertAndInterleaveTo16BitInteger()\n\twith 1 channel and one sample frame.\n\n\tSince floats are the only audio format ever passed, there is no variable\n\tsample type or bit depth. However, when going back and forth to storage\n\tformats, it is necessary to give the user an indication of the sample\n\ttype in the storage. For this reason, the SDK includes AudioSampleType\n\twhich defines a variety of possible formats. Note that these are ONLY\n\tUSED FOR USER INTERFACE!\n\n\tIn general, any audio sample rate is supported. For this reason, we use\n\ta floating point number to represent audio sample rates. However, not all\n\trates will evenly divide into our time ticks per second, so for more\n\tunusual rates there will be quantization errors possible using PrTime.\n\n\tThe host currently supports 4 audio channels types: mono, stereo, 5.1 and 32 channels.\n\tStereo channel ordering is {kPrAudioChannelLabel_FrontLeft, kPrAudioChannelLabel_FrontRight}.\n\t5.1 channels ordering is\n\t\t{kPrAudioChannelLabel_FrontLeft,\t\t// L\n\t\t kPrAudioChannelLabel_FrontRight,\t\t// R\n\t\t kPrAudioChannelLabel_FrontCenter,\t\t// C\n\t\t kPrAudioChannelLabel_LowFrequency,\t\t// LFE\n\t\t kPrAudioChannelLabel_BackLeft,\t\t\t// Ls\n\t\t kPrAudioChannelLabel_BackRight}.\t\t// Rs\n\n\t32 channel ordering is all {kPrAudioChannelLabel_Discrete}"]
pub type PrAudioSampleType = ::std::os::raw::c_int;
pub const PrAudioChannelType_kPrAudioChannelType_Mono: PrAudioChannelType = 1;
pub const PrAudioChannelType_kPrAudioChannelType_Stereo: PrAudioChannelType = 2;
pub const PrAudioChannelType_kPrAudioChannelType_51: PrAudioChannelType = 3;
pub const PrAudioChannelType_kPrAudioChannelType_MaxChannel: PrAudioChannelType = 4;
pub const PrAudioChannelType_kPrAudioChannelType_Max: PrAudioChannelType = -1;
pub type PrAudioChannelType = ::std::os::raw::c_int;
pub const PrAudioDataType_kPrAudioDataType_Float32: PrAudioDataType = 1;
pub const PrAudioDataType_kPrAudioDataType_Int32: PrAudioDataType = 2;
pub const PrAudioDataType_kPrAudioDataType_PeakAudio: PrAudioDataType = 3;
#[doc = "\tThis is not the sample type of the underlying audio - this is the sample type\n\tthat is returned in the calls that support variable audio types. If the type is not\n\texplicitly called out as variable, then it is Float32."]
pub type PrAudioDataType = ::std::os::raw::c_int;
pub type PrAudioSample = prInt64;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_Discrete: PrAudioChannelLabel = 0;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_FrontLeft: PrAudioChannelLabel = 100;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_FrontRight: PrAudioChannelLabel = 101;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_FrontCenter: PrAudioChannelLabel = 102;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_LowFrequency: PrAudioChannelLabel = 103;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_BackLeft: PrAudioChannelLabel = 104;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_BackRight: PrAudioChannelLabel = 105;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_BackCenter: PrAudioChannelLabel = 106;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_FrontLeftOfCenter: PrAudioChannelLabel = 107;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_FrontRightOfCenter: PrAudioChannelLabel = 108;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_SideLeft: PrAudioChannelLabel = 109;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_SideRight: PrAudioChannelLabel = 110;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_TopCenter: PrAudioChannelLabel = 111;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_TopFrontLeft: PrAudioChannelLabel = 112;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_TopFrontRight: PrAudioChannelLabel = 113;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_TopFrontCenter: PrAudioChannelLabel = 114;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_TopBackLeft: PrAudioChannelLabel = 115;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_TopBackRight: PrAudioChannelLabel = 116;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_TopBackCenter: PrAudioChannelLabel = 117;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_FrontLeftWide: PrAudioChannelLabel = 118;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_FrontRightWide: PrAudioChannelLabel = 119;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_LeftHeight: PrAudioChannelLabel = 127;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_RightHeight: PrAudioChannelLabel = 128;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_RearSurroundLeft: PrAudioChannelLabel = 129;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_RearSurroundRight: PrAudioChannelLabel = 130;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_LFE2: PrAudioChannelLabel = 131;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_LeftTotal: PrAudioChannelLabel = 132;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_RightTotal: PrAudioChannelLabel = 133;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_Ambisonic_W: PrAudioChannelLabel = 134;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_Ambisonic_X: PrAudioChannelLabel = 135;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_Ambisonic_Y: PrAudioChannelLabel = 136;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_Ambisonic_Z: PrAudioChannelLabel = 137;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_BottomFrontLeft: PrAudioChannelLabel = 138;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_BottomFrontCenter: PrAudioChannelLabel = 139;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_BottomFrontRight: PrAudioChannelLabel = 140;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_ProximityLeft: PrAudioChannelLabel = 141;
pub const PrAudioChannelLabel_kPrAudioChannelLabel_ProximityRight: PrAudioChannelLabel = 142;
pub type PrAudioChannelLabel = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKAudioSuite {
    #[doc = "\tThese are a variety of audio buffer conversion routines to convert an array\n\tof floating point buffers into interleaved audio of a specific type.\n\n\t@param\tinSource\t\tAn array of float buffers holding audio.\n\t@param\tinDestination\tA single buffer to hold the converted, interleaved audio.\n\t\t\t\t\t\t\tinDestination must be at least inNumChannels * sizeof(destinationFormat) *\n\t\t\t\t\t\t\tinNumSampleFrames bytes long.\n\t@param\tinNumChannels\tThe number of channels in inSource.\n\t@param\tinNumSampleFrames\tThe number of samples in each buffer in inSource."]
    pub ConvertAndInterleaveTo8BitInteger: ::std::option::Option<
        unsafe extern "C" fn(
            inSource: *mut *mut f32,
            inDestination: *mut ::std::os::raw::c_char,
            inNumChannels: ::std::os::raw::c_uint,
            inNumSampleFrames: ::std::os::raw::c_uint,
        ) -> prSuiteError,
    >,
    pub ConvertAndInterleaveTo16BitInteger: ::std::option::Option<
        unsafe extern "C" fn(
            inSource: *mut *mut f32,
            inDestination: *mut ::std::os::raw::c_short,
            inNumChannels: ::std::os::raw::c_uint,
            inNumSampleFrames: ::std::os::raw::c_uint,
        ) -> prSuiteError,
    >,
    pub ConvertAndInterleaveTo24BitInteger: ::std::option::Option<
        unsafe extern "C" fn(
            inSource: *mut *mut f32,
            inDestination: *mut ::std::os::raw::c_char,
            inNumChannels: ::std::os::raw::c_uint,
            inNumSampleFrames: ::std::os::raw::c_uint,
        ) -> prSuiteError,
    >,
    pub ConvertAndInterleaveTo32BitInteger: ::std::option::Option<
        unsafe extern "C" fn(
            inSource: *mut *mut f32,
            inDestination: *mut csSDK_int32,
            inNumChannels: ::std::os::raw::c_uint,
            inNumSampleFrames: ::std::os::raw::c_uint,
        ) -> prSuiteError,
    >,
    #[doc = "\tThese routines provide the reverse of the routines above, converting and\n\tuninterleaving a single buffer in a specified type.\n\n\t@param\tinSource\t\tA single buffer holding the orignal, interleaved audio.\n\t@param\tinDestination\tAn array of float buffers holding audio. There must be inNumChannels\n\t\t\t\t\t\t\tbuffers allocated in the array, and each must be at least\n\t\t\t\t\t\t\tinNumSampleFrames * sizeof(float) bytes long.\n\t@param\tinNumChannels\tThe number of channels in inSource.\n\t@param\tinNumSampleFrames\tThe number of samples in each buffer in inSource."]
    pub UninterleaveAndConvertFrom8BitInteger: ::std::option::Option<
        unsafe extern "C" fn(
            inSource: *mut ::std::os::raw::c_char,
            inDestination: *mut *mut f32,
            inNumChannels: ::std::os::raw::c_uint,
            inNumSampleFrames: ::std::os::raw::c_uint,
        ) -> prSuiteError,
    >,
    pub UninterleaveAndConvertFrom16BitInteger: ::std::option::Option<
        unsafe extern "C" fn(
            inSource: *mut ::std::os::raw::c_short,
            inDestination: *mut *mut f32,
            inNumChannels: ::std::os::raw::c_uint,
            inNumSampleFrames: ::std::os::raw::c_uint,
        ) -> prSuiteError,
    >,
    pub UninterleaveAndConvertFrom24BitInteger: ::std::option::Option<
        unsafe extern "C" fn(
            inSource: *mut ::std::os::raw::c_char,
            inDestination: *mut *mut f32,
            inNumChannels: ::std::os::raw::c_uint,
            inNumSampleFrames: ::std::os::raw::c_uint,
        ) -> prSuiteError,
    >,
    pub UninterleaveAndConvertFrom32BitInteger: ::std::option::Option<
        unsafe extern "C" fn(
            inSource: *mut csSDK_int32,
            inDestination: *mut *mut f32,
            inNumChannels: ::std::os::raw::c_uint,
            inNumSampleFrames: ::std::os::raw::c_uint,
        ) -> prSuiteError,
    >,
}
pub const PrActivationEvent_PrActivationEvent_Unspecified: PrActivationEvent = 0;
pub const PrActivationEvent_PrActivationEvent_RecorderActivated: PrActivationEvent = 1;
pub const PrActivationEvent_PrActivationEvent_PlayerActivated: PrActivationEvent = 2;
pub const PrActivationEvent_PrActivationEvent_ApplicationLostFocus: PrActivationEvent = 3;
pub const PrActivationEvent_PrActivationEvent_ForceSize: PrActivationEvent = -1;
#[doc = "\tPrActivationEvent - Describes the event that caused activation/deactivation to occur"]
pub type PrActivationEvent = ::std::os::raw::c_int;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_Undefined:
    PrRenderCaptionStreamFormat = 0;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_Open:
    PrRenderCaptionStreamFormat = 1;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_OP_42:
    PrRenderCaptionStreamFormat = 10;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_OP_47:
    PrRenderCaptionStreamFormat = 11;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_608_CC1:
    PrRenderCaptionStreamFormat = 20;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_608_CC2:
    PrRenderCaptionStreamFormat = 21;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_608_CC3:
    PrRenderCaptionStreamFormat = 22;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_608_CC4:
    PrRenderCaptionStreamFormat = 23;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_608_Text1:
    PrRenderCaptionStreamFormat = 24;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_608_Text2:
    PrRenderCaptionStreamFormat = 25;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_608_Text3:
    PrRenderCaptionStreamFormat = 26;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_608_Text4:
    PrRenderCaptionStreamFormat = 27;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_608_XDS:
    PrRenderCaptionStreamFormat = 28;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_708_Service1:
    PrRenderCaptionStreamFormat = 40;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_708_Service2:
    PrRenderCaptionStreamFormat = 41;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_708_Service3:
    PrRenderCaptionStreamFormat = 42;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_708_Service4:
    PrRenderCaptionStreamFormat = 43;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_708_Service5:
    PrRenderCaptionStreamFormat = 44;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_708_Service6:
    PrRenderCaptionStreamFormat = 45;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_Teletext_Level1:
    PrRenderCaptionStreamFormat = 50;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_Teletext_Level2:
    PrRenderCaptionStreamFormat = 51;
pub const PrRenderCaptionStreamFormat_kPrRenderCaptionStreamFormat_Open_Subtitling:
    PrRenderCaptionStreamFormat = 52;
#[doc = "\tDefines the Caption Stream format to render"]
pub type PrRenderCaptionStreamFormat = ::std::os::raw::c_int;
pub type PlayModuleDeviceID = csSDK_int32;
pub const kPrDeviceControlResult_Success: prSuiteError = 0;
pub const kPrDeviceControlResult_GeneralError: prSuiteError = -1;
pub const kPrDeviceControlResult_IllegalCallSequence: prSuiteError = -2;
#[doc = "\tPlaymod Device Control overview:\n\n\tThis suite is provided so that play modules can control a hardware\n\tdevice during \"Export To Tape.\" The necessary DeviceControlID will only\n\tbe passed down when a transmit is requested. The player must then call\n\tall of the methods in this suite, in the order in which they are\n\tlisted."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKPlayModuleDeviceControlSuite {
    #[doc = "\tTell the device to seek to the appropriate location.\n\n\t@return\t\t\t\t\tkPrDeviceControlResult_Success or kPrDeviceControlResult_IllegalCallSequence."]
    pub Seek:
        ::std::option::Option<unsafe extern "C" fn(inDeviceID: PlayModuleDeviceID) -> prSuiteError>,
    #[doc = "\tTell the device to prepare to record.\n\n\t@return\t\t\t\t\tkPrDeviceControlResult_Success or kPrDeviceControlResult_IllegalCallSequence."]
    pub Arm:
        ::std::option::Option<unsafe extern "C" fn(inDeviceID: PlayModuleDeviceID) -> prSuiteError>,
    #[doc = "\tTell the device to start recording.\n\n\t@return\t\t\t\t\tkPrDeviceControlResult_Success or kPrDeviceControlResult_IllegalCallSequence."]
    pub Record:
        ::std::option::Option<unsafe extern "C" fn(inDeviceID: PlayModuleDeviceID) -> prSuiteError>,
    #[doc = "\tTell the device to stop recording. This also cleans up the device control\n\tobject, so it is not available after this call.\n\n\t@return\t\t\t\t\tkPrDeviceControlResult_Success or kPrDeviceControlResult_IllegalCallSequence."]
    pub Stop:
        ::std::option::Option<unsafe extern "C" fn(inDeviceID: PlayModuleDeviceID) -> prSuiteError>,
}
pub const PrIVProjectionType_kPrIVProjectionType_None: PrIVProjectionType = 0;
pub const PrIVProjectionType_kPrIVProjectionType_Equirectangular: PrIVProjectionType = 1;
#[doc = "\tDefines how the VR image is projected into a 2D frame."]
pub type PrIVProjectionType = ::std::os::raw::c_int;
pub const PrIVFrameLayout_kPrIVFrameLayout_Monoscopic: PrIVFrameLayout = 0;
pub const PrIVFrameLayout_kPrIVFrameLayout_StereoscopicOverUnder: PrIVFrameLayout = 1;
pub const PrIVFrameLayout_kPrIVFrameLayout_StereoscopicSideBySide: PrIVFrameLayout = 2;
#[doc = "\tDefines if the VR image contains a stereoscopic pair, and if so, what type of pair."]
pub type PrIVFrameLayout = ::std::os::raw::c_int;
pub const PrIVStereoscopicEye_kPrIVStereoscopicEye_Left: PrIVStereoscopicEye = 0;
pub const PrIVStereoscopicEye_kPrIVStereoscopicEye_Right: PrIVStereoscopicEye = 1;
pub const PrIVStereoscopicEye_kPrIVStereoscopicEye_Anaglyph: PrIVStereoscopicEye = 2;
#[doc = "\tDefines which eye to view when given a VR image with a stereoscopic pair."]
pub type PrIVStereoscopicEye = ::std::os::raw::c_int;
pub const PrIVAmbisonicsMonitoringType_kPrIVAmbisonicsMonitoringType_Off:
    PrIVAmbisonicsMonitoringType = 0;
pub const PrIVAmbisonicsMonitoringType_kPrIVAmbisonicsMonitoringType_Binaural:
    PrIVAmbisonicsMonitoringType = 1;
#[doc = "\tDefines how ambisonics audio is to be monitored."]
pub type PrIVAmbisonicsMonitoringType = ::std::os::raw::c_int;
pub type kPrIVViewRange = csSDK_int32;
pub type kPrIVViewAngle = f32;
#[doc = " Field of View represents the degrees of view of what the application displays when the desktop's VR View is enabled.\n Captured View represents the degrees of view of what the video frame actually contains."]
pub const kPrIVMinFieldOfView: kPrIVViewRange = 60;
pub const kPrIVMaxFieldOfView: kPrIVViewRange = 180;
#[doc = " These FOV values roughly approximate an average view when compared\n to a HTC Vive or Oculus Rift."]
pub const kPrIVDefaultFieldOfHorizontalView: kPrIVViewRange = 108;
pub const kPrIVDefaultFieldOfVerticalView: kPrIVViewRange = 108;
pub const kPrIVMinCapturedHorizontalView: kPrIVViewRange = 60;
pub const kPrIVMaxCapturedHorizontalView: kPrIVViewRange = 360;
pub const kPrIVDefaultCapturedHorizontalView: kPrIVViewRange = 360;
pub const kPrIVMinCapturedVerticalView: kPrIVViewRange = 60;
pub const kPrIVMaxCapturedVerticalView: kPrIVViewRange = 180;
pub const kPrIVDefaultCapturedVerticalView: kPrIVViewRange = 180;
#[doc = "\tID for a head-related impulse response when monitoring with PrIVAmbisonicsMonitoring_Binaural."]
pub const kPrIVAmbisonicsHRIRLength: usize = 256;
pub type PrIVAmbisonicsHRIR = [prUTF8Char; 256usize];
pub const PrPlaymodReturnValue_playmod_ErrNone: PrPlaymodReturnValue = 0;
pub const PrPlaymodReturnValue_playmod_ErrBadFile: PrPlaymodReturnValue = 1;
pub const PrPlaymodReturnValue_playmod_ErrDriver: PrPlaymodReturnValue = 2;
pub const PrPlaymodReturnValue_playmod_ErrNotPreferred: PrPlaymodReturnValue = 3;
pub const PrPlaymodReturnValue_playmod_BadFormatIndex: PrPlaymodReturnValue = 4;
pub const PrPlaymodReturnValue_playmod_DeclinePlay: PrPlaymodReturnValue = 5;
pub const PrPlaymodReturnValue_playmod_ListWrongType: PrPlaymodReturnValue = 6;
pub const PrPlaymodReturnValue_playmod_ListBadSpeed: PrPlaymodReturnValue = 7;
pub const PrPlaymodReturnValue_playmod_CantAddSegment: PrPlaymodReturnValue = 8;
pub const PrPlaymodReturnValue_playmod_Unsupported: PrPlaymodReturnValue = 9;
pub const PrPlaymodReturnValue_playmod_AudioOverload: PrPlaymodReturnValue = 10;
pub const PrPlaymodReturnValue_playmod_OutOfRange: PrPlaymodReturnValue = 11;
pub const PrPlaymodReturnValue_playmod_CannotRender: PrPlaymodReturnValue = 12;
pub const PrPlaymodReturnValue_playmod_RebuildCutlist: PrPlaymodReturnValue = 13;
pub const PrPlaymodReturnValue_playmod_CannotShiftLayer: PrPlaymodReturnValue = 14;
pub const PrPlaymodReturnValue_playmod_UnsupportedPlaybackSpeed: PrPlaymodReturnValue = 16;
pub const PrPlaymodReturnValue_playmod_BroadcastPrefs: PrPlaymodReturnValue = 17;
pub const PrPlaymodReturnValue_playmod_CannotRecord: PrPlaymodReturnValue = 18;
pub const PrPlaymodReturnValue_playmod_RenderAndPutFrame: PrPlaymodReturnValue = 19;
pub const PrPlaymodReturnValue_pmIsCacheable: PrPlaymodReturnValue = 400;
pub const PrPlaymodReturnValue_playmod_ErrorForceSize: PrPlaymodReturnValue = -1;
#[doc = "\tError Definitions"]
pub type PrPlaymodReturnValue = ::std::os::raw::c_int;
#[doc = "\tType Definitions"]
pub type PrPlayID = csSDK_int32;
pub const pmFieldDisplay_pmFieldDisplay_ShowFirstField: pmFieldDisplay = 0;
pub const pmFieldDisplay_pmFieldDisplay_ShowSecondField: pmFieldDisplay = 1;
pub const pmFieldDisplay_pmFieldDisplay_ShowBothFields: pmFieldDisplay = 2;
pub const pmFieldDisplay_pmFieldDisplay_ForceSize: pmFieldDisplay = -1;
pub type pmFieldDisplay = ::std::os::raw::c_int;
pub const PrPlaymodSelector_playmod_Startup: PrPlaymodSelector = 1;
pub const PrPlaymodSelector_playmod_Shutdown: PrPlaymodSelector = 2;
pub const PrPlaymodSelector_playmod_Open: PrPlaymodSelector = 3;
pub const PrPlaymodSelector_playmod_GetInfo: PrPlaymodSelector = 4;
pub const PrPlaymodSelector_playmod_SetDisp: PrPlaymodSelector = 5;
pub const PrPlaymodSelector_playmod_Update: PrPlaymodSelector = 6;
pub const PrPlaymodSelector_playmod_Stop: PrPlaymodSelector = 10;
pub const PrPlaymodSelector_playmod_PlayIdle: PrPlaymodSelector = 11;
pub const PrPlaymodSelector_playmod_Close: PrPlaymodSelector = 12;
pub const PrPlaymodSelector_playmod_GetIndFormat: PrPlaymodSelector = 14;
pub const PrPlaymodSelector_playmod_NewList: PrPlaymodSelector = 21;
pub const PrPlaymodSelector_playmod_GetFilePrefs: PrPlaymodSelector = 34;
pub const PrPlaymodSelector_playmod_UpdateMarkers: PrPlaymodSelector = 45;
pub const PrPlaymodSelector_playmod_SetFilePrefs: PrPlaymodSelector = 46;
pub const PrPlaymodSelector_playmod_PutFrame: PrPlaymodSelector = 49;
pub const PrPlaymodSelector_playmod_SetQuality: PrPlaymodSelector = 53;
pub const PrPlaymodSelector_playmod_SetPlaybackSpeed: PrPlaymodSelector = 54;
pub const PrPlaymodSelector_playmod_Play: PrPlaymodSelector = 55;
pub const PrPlaymodSelector_playmod_SetPos: PrPlaymodSelector = 56;
pub const PrPlaymodSelector_playmod_GetPos: PrPlaymodSelector = 57;
pub const PrPlaymodSelector_playmod_Step: PrPlaymodSelector = 59;
pub const PrPlaymodSelector_playmod_Preroll: PrPlaymodSelector = 60;
pub const PrPlaymodSelector_playmod_AdornSafeAreas: PrPlaymodSelector = 61;
pub const PrPlaymodSelector_playmod_Activate: PrPlaymodSelector = 62;
pub const PrPlaymodSelector_playmod_EnterScrub: PrPlaymodSelector = 63;
pub const PrPlaymodSelector_playmod_LeaveScrub: PrPlaymodSelector = 64;
pub const PrPlaymodSelector_playmod_SetView: PrPlaymodSelector = 65;
pub const PrPlaymodSelector_playmod_SetDisplayMode: PrPlaymodSelector = 66;
pub const PrPlaymodSelector_playmod_PutFrameRequest: PrPlaymodSelector = 67;
pub const PrPlaymodSelector_playmod_SetVideoDisplayType: PrPlaymodSelector = 69;
pub const PrPlaymodSelector_playmod_DisplayMoving: PrPlaymodSelector = 70;
pub const PrPlaymodSelector_playmod_DisplayChanged: PrPlaymodSelector = 71;
pub const PrPlaymodSelector_playmod_GetAudioInfo: PrPlaymodSelector = 74;
pub const PrPlaymodSelector_playmod_GetAudioChannelInfo: PrPlaymodSelector = 75;
pub const PrPlaymodSelector_playmod_PushPlayerSettings: PrPlaymodSelector = 76;
pub const PrPlaymodSelector_playmod_EnableDynamicPlayback: PrPlaymodSelector = 77;
pub const PrPlaymodSelector_playmod_AllowSetPositionDuringPlayback: PrPlaymodSelector = 78;
pub const PrPlaymodSelector_playmod_VideoSequenceHasChanged: PrPlaymodSelector = 79;
pub const PrPlaymodSelector_playmod_GetRTStatusForTime: PrPlaymodSelector = 80;
pub const PrPlaymodSelector_playmod_SetUseFractionalResolution: PrPlaymodSelector = 81;
pub const PrPlaymodSelector_playmod_SetFractionalResolution: PrPlaymodSelector = 82;
pub const PrPlaymodSelector_playmod_PutTemporaryTimeline: PrPlaymodSelector = 83;
pub const PrPlaymodSelector_playmod_SetDisplayStateProperties: PrPlaymodSelector = 84;
pub const PrPlaymodSelector_playmod_AudioOutputMappingUpdate: PrPlaymodSelector = 85;
pub const PrPlaymodSelector_playmod_SetDest: PrPlaymodSelector = 86;
pub const PrPlaymodSelector_playmod_SetBackgroundColor: PrPlaymodSelector = 87;
pub const PrPlaymodSelector_playmod_GetVRSupported: PrPlaymodSelector = 88;
pub const PrPlaymodSelector_playmod_SetVRConfiguration: PrPlaymodSelector = 89;
pub const PrPlaymodSelector_playmod_GetVRConfiguration: PrPlaymodSelector = 90;
pub const PrPlaymodSelector_playmod_SetVREnabled: PrPlaymodSelector = 91;
pub const PrPlaymodSelector_playmod_GetVREnabled: PrPlaymodSelector = 92;
pub const PrPlaymodSelector_playmod_SetVRView: PrPlaymodSelector = 93;
pub const PrPlaymodSelector_playmod_GetVRView: PrPlaymodSelector = 94;
pub const PrPlaymodSelector_playmod_CalculateVRDisplayDimensions: PrPlaymodSelector = 95;
pub const PrPlaymodSelector_playmod_SetDisplayStateProperties2: PrPlaymodSelector = 96;
pub const PrPlaymodSelector_playmod_SelectorsForceSize: PrPlaymodSelector = -1;
#[doc = "\tSelectors"]
pub type PrPlaymodSelector = ::std::os::raw::c_int;
#[doc = "\tInformation returned from a plugin"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrGPUFilterInfo {
    pub outInterfaceVersion: csSDK_uint32,
    pub outMatchName: PrSDKString,
}
#[doc = "\tA filter instance represents an effect applied to a track item with a fixed set of parameters.\n\tChanged parameters will create a new instance."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrGPUFilterInstance {
    pub piSuites: piSuitesPtr,
    pub inDeviceIndex: csSDK_uint32,
    pub inTimelineID: PrTimelineID,
    pub inNodeID: csSDK_int32,
    pub ioPrivatePluginData: *mut ::std::os::raw::c_void,
    pub outIsRealtime: prBool,
}
#[doc = "\tInformation about a frame render"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrGPUFilterRenderParams {
    pub inClipTime: PrTime,
    pub inSequenceTime: PrTime,
    pub inQuality: PrRenderQuality,
    pub inDownsampleFactorX: f32,
    pub inDownsampleFactorY: f32,
    pub inRenderWidth: csSDK_uint32,
    pub inRenderHeight: csSDK_uint32,
    pub inRenderPARNum: csSDK_uint32,
    pub inRenderPARDen: csSDK_uint32,
    pub inRenderFieldType: prFieldType,
    pub inRenderTicksPerFrame: PrTime,
    pub inRenderField: pmFieldDisplay,
}
pub const PrGPUFilterFrameDependencyType_PrGPUDependency_InputFrame:
    PrGPUFilterFrameDependencyType = 1;
pub const PrGPUFilterFrameDependencyType_PrGPUDependency_Precompute:
    PrGPUFilterFrameDependencyType = 2;
pub const PrGPUFilterFrameDependencyType_PrGPUDependency_FieldSeparation:
    PrGPUFilterFrameDependencyType = 4;
pub const PrGPUFilterFrameDependencyType_PrGPUDependency_TransitionInputFrame:
    PrGPUFilterFrameDependencyType = 8;
#[doc = "\tSpecify dependencies to satisfy a render"]
pub type PrGPUFilterFrameDependencyType = ::std::os::raw::c_int;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrGPUFilterFrameDependency {
    pub outDependencyType: PrGPUFilterFrameDependencyType,
    pub outTrackID: csSDK_int32,
    pub outSequenceTime: PrTime,
    pub outPrecomputePixelFormat: PrPixelFormat,
    pub outPrecomputeFrameWidth: csSDK_uint32,
    pub outPrecomputeFrameHeight: csSDK_uint32,
    pub outPrecomputeFramePARNumerator: csSDK_uint32,
    pub outPrecomputeFramePARDenominator: csSDK_uint32,
    pub outPrecomputeFrameFieldType: prFieldType,
    pub outPrecomputeCustomDataSize: csSDK_size_t,
    pub outNeedsFieldSeparation: prBool,
    pub outReadIncomingTransition: prBool,
}
#[doc = "\tGPU Filter callbacks."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrGPUFilter {
    #[doc = "\tCreates a GPU filter instance representing an effect or transition on a\n\ttrack item. Returning an error from CreateInstance will cause this node\n\tto be rendered in software for the current set of parameters. Separate\n\tinstances may be called concurrently."]
    pub CreateInstance: ::std::option::Option<
        unsafe extern "C" fn(ioInstanceData: *mut PrGPUFilterInstance) -> prSuiteError,
    >,
    pub DisposeInstance: ::std::option::Option<
        unsafe extern "C" fn(ioInstanceData: *mut PrGPUFilterInstance) -> prSuiteError,
    >,
    #[doc = "\tReturn dependency information about a render, or nothing if\n\tonly the current frame is required."]
    pub GetFrameDependencies: ::std::option::Option<
        unsafe extern "C" fn(
            inInstanceData: *mut PrGPUFilterInstance,
            inRenderParams: *const PrGPUFilterRenderParams,
            ioQueryIndex: *mut csSDK_int32,
            outFrameDependencies: *mut PrGPUFilterFrameDependency,
        ) -> prSuiteError,
    >,
    #[doc = "\tPrecompute a result into preallocated uninitialized host (pinned) memory.\n\tWill only be called if PrGPUDependency_Precompute was returned from GetFrameDependencies.\n\tPrecomputation may be called ahead of render time. Results will be\n\tuploaded to the GPU by the host. If outPrecomputePixelFormat is not custom,\n\tframes will be converted to the GPU pixel format."]
    pub Precompute: ::std::option::Option<
        unsafe extern "C" fn(
            inInstanceData: *mut PrGPUFilterInstance,
            inRenderParams: *const PrGPUFilterRenderParams,
            inIndex: csSDK_int32,
            inFrame: PPixHand,
        ) -> prSuiteError,
    >,
    #[doc = "\tRender into an allocated outFrame allocated with PrSDKGPUDeviceSuite or operate\n\tin place. Result must be in the same pixel format as the input. For effects, frame 0\n\twill always be the frame at the current time, other input frames will be in the same order as\n\treturned from GetFrameDependencies. For transitions frame 0 will be the incoming frame and\n\tframe 1 the outgoing frame. Transitions may not have other frame dependencies."]
    pub Render: ::std::option::Option<
        unsafe extern "C" fn(
            inInstanceData: *mut PrGPUFilterInstance,
            inRenderParams: *const PrGPUFilterRenderParams,
            inFrames: *const PPixHand,
            inFrameCount: csSDK_size_t,
            outFrame: *mut PPixHand,
        ) -> prSuiteError,
    >,
}
pub type PrGPUFilterEntry = ::std::option::Option<
    unsafe extern "C" fn(
        inHostInterfaceVersion: csSDK_uint32,
        ioIndex: *mut csSDK_int32,
        inStartup: prBool,
        piSuites: piSuitesPtr,
        outFilter: *mut PrGPUFilter,
        outFilterInfo: *mut PrGPUFilterInfo,
    ) -> prSuiteError,
>;
#[doc = "\tAccess to common GPU image processing algorithms"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct PrSDKGPUImageProcessingSuite {
    #[doc = "\tConvert between formats on the GPU\n\t\tOne of inSrcPixelFormat or inDestPixelFormat must be a host format,\n\tthe other must be either PrPixelFormat_GPU_BGRA_4444_16f or PrPixelFormat_GPU_BGRA_4444_32f"]
    pub PixelFormatConvert: ::std::option::Option<
        unsafe extern "C" fn(
            inDeviceIndex: csSDK_uint32,
            inSrc: *const ::std::os::raw::c_void,
            inSrcRowBytes: csSDK_int32,
            inSrcPixelFormat: PrPixelFormat,
            inDest: *mut ::std::os::raw::c_void,
            inDestRowBytes: csSDK_int32,
            inDestPixelFormat: PrPixelFormat,
            inWidth: csSDK_uint32,
            inHeight: csSDK_uint32,
            inQuality: PrRenderQuality,
        ) -> prSuiteError,
    >,
    #[doc = "\tScale a frame on the GPU\n\t\tinPixelFormat must be PrPixelFormat_GPU_BGRA_4444_16f or PrPixelFormat_GPU_BGRA_4444_32f"]
    pub Scale: ::std::option::Option<
        unsafe extern "C" fn(
            inDeviceIndex: csSDK_uint32,
            inSrc: *const ::std::os::raw::c_void,
            inSrcRowBytes: csSDK_int32,
            inSrcWidth: csSDK_uint32,
            inSrcHeight: csSDK_uint32,
            inDest: *mut ::std::os::raw::c_void,
            inDestRowBytes: csSDK_int32,
            inDestWidth: csSDK_uint32,
            inDestHeight: csSDK_uint32,
            inPixelFormat: PrPixelFormat,
            inScaleX: f32,
            inScaleY: f32,
            inQuality: PrRenderQuality,
        ) -> prSuiteError,
    >,
    #[doc = "\tGaussian blur on the GPU\n\t\tinPixelFormat must be PrPixelFormat_GPU_BGRA_4444_16f or PrPixelFormat_GPU_BGRA_4444_32f"]
    pub GaussianBlur: ::std::option::Option<
        unsafe extern "C" fn(
            inDeviceIndex: csSDK_uint32,
            inSrc: *const ::std::os::raw::c_void,
            inSrcRowBytes: csSDK_int32,
            inSrcWidth: csSDK_uint32,
            inSrcHeight: csSDK_uint32,
            inDest: *mut ::std::os::raw::c_void,
            inDestRowBytes: csSDK_int32,
            inDestWidth: csSDK_uint32,
            inDestHeight: csSDK_uint32,
            inPixelFormat: PrPixelFormat,
            inSigmaX: f32,
            inSigmaY: f32,
            inRepeatEdgePixels: prBool,
            inBlurHorizontally: prBool,
            inBlurVertically: prBool,
            inQuality: PrRenderQuality,
        ) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKMemoryManagerSuiteV1 {
    #[doc = "\tSet the memory reserve size in bytes for the plugin with the specified ID.\n\n\t@param\tinPluginID\t\t\tThe ID of the plugin.\n\t@param\tinSize\t\t\t\tThe size in bytes to reserve."]
    pub ReserveMemory: ::std::option::Option<
        unsafe extern "C" fn(inPluginID: csSDK_uint32, inSize: csSDK_uint32) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKMemoryManagerSuiteV2 {
    #[doc = "\tSet the memory reserve size in bytes for the plugin with the specified ID.\n\n\t@param\tinPluginID\t\t\tThe ID of the plugin.\n\t@param\tinSize\t\t\t\tThe size in bytes to reserve."]
    pub ReserveMemory: ::std::option::Option<
        unsafe extern "C" fn(inPluginID: csSDK_uint32, inSize: csSDK_uint32) -> prSuiteError,
    >,
    pub NewPtrClear:
        ::std::option::Option<unsafe extern "C" fn(byteCount: csSDK_uint32) -> PrMemoryPtr>,
    pub NewPtr: ::std::option::Option<unsafe extern "C" fn(byteCount: csSDK_uint32) -> PrMemoryPtr>,
    pub GetPtrSize: ::std::option::Option<unsafe extern "C" fn(p: PrMemoryPtr) -> csSDK_uint32>,
    pub SetPtrSize:
        ::std::option::Option<unsafe extern "C" fn(p: *mut PrMemoryPtr, newSize: csSDK_uint32)>,
    pub NewHandle:
        ::std::option::Option<unsafe extern "C" fn(byteCount: csSDK_uint32) -> PrMemoryHandle>,
    pub NewHandleClear:
        ::std::option::Option<unsafe extern "C" fn(byteCount: csSDK_uint32) -> PrMemoryHandle>,
    pub PrDisposePtr: ::std::option::Option<unsafe extern "C" fn(p: PrMemoryPtr)>,
    pub DisposeHandle: ::std::option::Option<unsafe extern "C" fn(h: PrMemoryHandle)>,
    pub SetHandleSize: ::std::option::Option<
        unsafe extern "C" fn(h: PrMemoryHandle, newSize: csSDK_uint32) -> ::std::os::raw::c_short,
    >,
    pub GetHandleSize:
        ::std::option::Option<unsafe extern "C" fn(h: PrMemoryHandle) -> csSDK_uint32>,
    pub HUnlock: ::std::option::Option<unsafe extern "C" fn(h: PrMemoryHandle)>,
    pub HLock: ::std::option::Option<unsafe extern "C" fn(h: PrMemoryHandle)>,
}
pub type PrSDKMemoryManagerSuite_PurgeMemoryFunction = ::std::option::Option<
    unsafe extern "C" fn(inPurgeMemoryData: *mut ::std::os::raw::c_void, inMemoryID: csSDK_uint32),
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKMemoryManagerSuite {
    #[doc = "\tSet the memory reserve size in bytes for the plugin with the specified ID.\n\n\t@param\tinPluginID\t\t\tThe ID of the plugin.\n\t@param\tinSize\t\t\t\tThe size in bytes to reserve."]
    pub ReserveMemory: ::std::option::Option<
        unsafe extern "C" fn(inPluginID: csSDK_uint32, inSize: csSDK_uint32) -> prSuiteError,
    >,
    #[doc = "\tGet the current size of the media cache in this process.\n\n\t@param\toutMemoryManagerSize\tThe size of the memory manager in bytes."]
    pub GetMemoryManagerSize: ::std::option::Option<
        unsafe extern "C" fn(outMemoryManagerSize: *mut csSDK_uint64) -> prSuiteError,
    >,
    #[doc = "\tAdd a block of memory to management. This block should not be something entered\n\tin any of the suite cache, and it must be purgeable. The purge function you pass in\n\tmay be called on any thread.\n\n\t@param\tinSize\t\t\t\tThe size in bytes of the item in question.\n\t@param\tinPurgeFunction\t\tThe function pointer that will be called to purge the item.\n\t@param\tinPurgeMemoryData\tThe data object passed back in the purge callback.\n\t@param\toutID\t\t\t\tThe id the host will use for this item."]
    pub AddBlock: ::std::option::Option<
        unsafe extern "C" fn(
            inSize: csSDK_size_t,
            inPurgeFunction: PrSDKMemoryManagerSuite_PurgeMemoryFunction,
            inPurgeMemoryData: *mut ::std::os::raw::c_void,
            outID: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
    #[doc = "\tEach time you use a block of memory, you should call this function. This pushes its\n\tpriority up in the cache, making a purge less likely.\n\n\t@param\tinID\t\t\t\tThe id of the block to touch."]
    pub TouchBlock: ::std::option::Option<unsafe extern "C" fn(inID: csSDK_uint32) -> prSuiteError>,
    #[doc = "\tYou can manually expire an item from the cache with this function. Note that the purge function\n\ton the item will not be called.\n\n\t@param\tinID\t\t\t\tThe id of the block to touch."]
    pub RemoveBlock:
        ::std::option::Option<unsafe extern "C" fn(inID: csSDK_uint32) -> prSuiteError>,
    pub NewPtrClear:
        ::std::option::Option<unsafe extern "C" fn(byteCount: csSDK_uint32) -> PrMemoryPtr>,
    pub NewPtr: ::std::option::Option<unsafe extern "C" fn(byteCount: csSDK_uint32) -> PrMemoryPtr>,
    pub GetPtrSize: ::std::option::Option<unsafe extern "C" fn(p: PrMemoryPtr) -> csSDK_uint32>,
    pub SetPtrSize:
        ::std::option::Option<unsafe extern "C" fn(p: *mut PrMemoryPtr, newSize: csSDK_uint32)>,
    pub NewHandle:
        ::std::option::Option<unsafe extern "C" fn(byteCount: csSDK_uint32) -> PrMemoryHandle>,
    pub NewHandleClear:
        ::std::option::Option<unsafe extern "C" fn(byteCount: csSDK_uint32) -> PrMemoryHandle>,
    pub PrDisposePtr: ::std::option::Option<unsafe extern "C" fn(p: PrMemoryPtr)>,
    pub DisposeHandle: ::std::option::Option<unsafe extern "C" fn(h: PrMemoryHandle)>,
    pub SetHandleSize: ::std::option::Option<
        unsafe extern "C" fn(h: PrMemoryHandle, newSize: csSDK_uint32) -> ::std::os::raw::c_short,
    >,
    pub GetHandleSize:
        ::std::option::Option<unsafe extern "C" fn(h: PrMemoryHandle) -> csSDK_uint32>,
    pub AdjustReservedMemorySize: ::std::option::Option<
        unsafe extern "C" fn(inPluginID: csSDK_uint32, inSize: csSDK_int64) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKPixelFormatSuite {
    #[doc = "\tRetrieves the minimum i.e. \"black\" value for a give pixel type.\n\n\t[NOTE]\tpixel types like YUY2, YUYV actually contain a group of two pixels to specify a color\n\t\t\tcompletely, so the data size returned in this case will be 4 bytes (rather than 2)\n\n\t@param\t\tpixelFormat\t\t\t\tthe Premiere pixel format whose black level you want\n\t@param\t\tpixelData\t\t\t\ta void pointer to data large enough to hold the pixel value (see note above)\n\n\t@returns\tsuiteError_NoError : successful retreival of black value\n\t@returns\tsuiteError_Fail :"]
    pub GetBlackForPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            pixelFormat: PrPixelFormat,
            pixelData: *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    #[doc = "\tRetrieves the maximum i.e. \"white\" value for a give pixel type.\n\n\t[NOTE]\tpixel types like YUY2, YUYV actually contain a group of two pixels to specify a color\n\t\t\tcompletely, so the data size returned in this case will be 4 bytes (rather than 2)\n\n\t@param\t\tpixelFormat\t\t\t\tthe Premiere pixel format whose white level you want\n\t@param\t\tpixelData\t\t\t\ta void pointer to data large enough to hold the pixel value (see note above)\n\n\t@returns\tsuiteError_NoError : successful retreival of white value\n\t@returns\tsuiteError_Fail :"]
    pub GetWhiteForPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            pixelFormat: PrPixelFormat,
            pixelData: *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    #[doc = "\tConverts an alpha, red, green, blue specification into a pixel value for a give pixel type.\n\n\t[NOTE]\tpixel types like YUY2, YUYV actually contain a group of two pixels to specify a color\n\t\t\tcompletely, so the data size returned in this case will be 4 bytes (rather than 2)\n\n\t@param\t\tpixelFormat\t\t\t\tthe Premiere pixel format whose white level you want\n\t@param\t\talpha\t\t\t\t\talpha value (0.0 - 1.0)\n\t@param\t\tred\t\t\t\t\t\tred value (0.0 - 1.0)\n\t@param\t\tgreen\t\t\t\t\tgreen value (0.0 - 1.0)\n\t@param\t\tblue\t\t\t\t\tblue value (0.0 - 1.0)\n\t@param\t\tpixelData\t\t\t\ta void pointer to data large enough to hold the pixel value (see note above)\n\n\t@returns\tsuiteError_NoError : successful conversion of color value\n\t@returns\tsuiteError_Fail :"]
    pub ConvertColorToPixelFormattedData: ::std::option::Option<
        unsafe extern "C" fn(
            pixelFormat: PrPixelFormat,
            alpha: f32,
            red: f32,
            green: f32,
            blue: f32,
            pixelData: *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
}
pub const PrPPixBufferAccess_PrPPixBufferAccess_ReadOnly: PrPPixBufferAccess = 0;
pub const PrPPixBufferAccess_PrPPixBufferAccess_WriteOnly: PrPPixBufferAccess = 1;
pub const PrPPixBufferAccess_PrPPixBufferAccess_ReadWrite: PrPPixBufferAccess = 2;
pub const PrPPixBufferAccess_PrPPixBufferAccess_ForceEnumSize: PrPPixBufferAccess = -1;
pub type PrPPixBufferAccess = ::std::os::raw::c_int;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKPPixSuite {
    #[doc = "\tThis will free this ppix. The ppix is no longer valid after this function is called.\n\n\t@param\tinPPixHand\t\t\t\tThe ppix handle you want to dispose."]
    pub Dispose: ::std::option::Option<unsafe extern "C" fn(inPPixHand: PPixHand) -> prSuiteError>,
    #[doc = "\tThis will return a pointer to the pixel buffer.\n\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to operate on.\n\t@param\tinRequestedAccess\tRequested pixel access. Most PPixs do not support write access modes.\n\t@param\toutPixelAddress\t\tThe output pixel buffer address. May be NULL if the requested pixel access is not supported."]
    pub GetPixels: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixHand: PPixHand,
            inRequestedAccess: PrPPixBufferAccess,
            outPixelAddress: *mut *mut ::std::os::raw::c_char,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will return the bounding rect.\n\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to operate on.\n\t@param\toutBoundingRect\t\tThe address of a bounding rect to be filled in."]
    pub GetBounds: ::std::option::Option<
        unsafe extern "C" fn(inPPixHand: PPixHand, inoutBoundingRect: *mut prRect) -> prSuiteError,
    >,
    #[doc = "\tThis will return the row bytes of the ppix.\n\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to operate on.\n\t@param\toutRowBytes\t\t\tReturns how many bytes must be added to the pixel buffer address to get to the next line.\n\t\t\t\t\t\t\t\tMay be negative."]
    pub GetRowBytes: ::std::option::Option<
        unsafe extern "C" fn(inPPixHand: PPixHand, outRowBytes: *mut csSDK_int32) -> prSuiteError,
    >,
    #[doc = "\tThis will return the pixel aspect ratio of this ppix.\n\n\t@param\tinPPixHand\t\t\t\t\t\tThe ppix handle you want to operate on.\n\t@param\toutPixelAspectRatioNumerator\tReturns the numerator of the pixel aspect ratio.\n\t@param\toutPixelAspectRatioDenominator\tReturns the denominator of the pixel aspect ratio."]
    pub GetPixelAspectRatio: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixHand: PPixHand,
            outPixelAspectRatioNumerator: *mut csSDK_uint32,
            outPixelAspectRatioDenominator: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will return the pixel format of this ppix.\n\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to operate on.\n\t@param\toutPixelFormat\t\tReturns the pixel format of this ppix."]
    pub GetPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixHand: PPixHand,
            outPixelFormat: *mut PrPixelFormat,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will return the unique key for this ppix.\n\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to operate on.\n\t@param\toutKeyBuffer\t\tReturns the pixel format of this ppix.\n\n\t[TODO] Fill in returned error codes.\n\t@returns Error if the buffer size is too small (call GetUniqueKeySize() to get the correct size).\n\t@returns Error if the key is not available.\n\t@returns Success if the key data was filled in."]
    pub GetUniqueKey: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixHand: PPixHand,
            inoutKeyBuffer: *mut ::std::os::raw::c_uchar,
            inKeyBufferSize: usize,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will return the unique key size.\n\tThis will not change for the entire run of the application.\n\n\t@param\toutKeyBufferSize\tReturns the size of the ppix unique key."]
    pub GetUniqueKeySize:
        ::std::option::Option<unsafe extern "C" fn(outKeyBufferSize: *mut usize) -> prSuiteError>,
    #[doc = "\tThis will return the render time for this ppix.\n\n\t@param\tinPPixHand\t\t\t\tThe ppix handle you want to operate on.\n\t@param\toutRenderMilliseconds\tReturns the render time in milliseconds. If the frame was cached, this time will be 0."]
    pub GetRenderTime: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixHand: PPixHand,
            outRenderMilliseconds: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKPPix2Suite {
    #[doc = "\tThis will return the total size of the ppix in bytes.\n\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to operate on.\n\t@param\toutSize\t\t\t\tThe size of the ppix in bytes."]
    pub GetSize: ::std::option::Option<
        unsafe extern "C" fn(inPPixHand: PPixHand, outSize: *mut usize) -> prSuiteError,
    >,
    #[doc = "\t[Added in CS4]\n\tThis will return the planar buffers and rowbytes for a PPixHand\n\tif the contained pixels are in a planar format, such as\n\tPrPixelFormat_YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u_601\n\tPrPixelFormat_YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u_601\n\tPrPixelFormat_YUV_420_MPEG2_FRAME_PICTURE_PLANAR_8u_709\n\tPrPixelFormat_YUV_420_MPEG2_FIELD_PICTURE_PLANAR_8u_709\n\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to operate on.\n\t@param\tinRequestedAccess\tWill return an error if the source is read-only and the request is for write or read/write.\n\n\t@param\tout_xxx_PixelAddress\tThe output (Y, U, or V) pixel buffer address. May be NULL if the requested access is not supported.\n\t@param\tout_xxx_RowBytes\t\tReturns how many bytes must be added to the pixel buffer address to get to the next line.\n\t\t\t\t\t\t\t\t\tMay be negative."]
    pub GetYUV420PlanarBuffers: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixHand: PPixHand,
            inRequestedAccess: PrPPixBufferAccess,
            out_Y_PixelAddress: *mut *mut ::std::os::raw::c_char,
            out_Y_RowBytes: *mut csSDK_uint32,
            out_U_PixelAddress: *mut *mut ::std::os::raw::c_char,
            out_U_RowBytes: *mut csSDK_uint32,
            out_V_PixelAddress: *mut *mut ::std::os::raw::c_char,
            out_V_RowBytes: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
    pub GetOrigin: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixHand: PPixHand,
            outOriginX: *mut csSDK_int32,
            outOriginY: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    pub GetFieldOrder: ::std::option::Option<
        unsafe extern "C" fn(inPPixHand: PPixHand, outFieldType: *mut prFieldType) -> prSuiteError,
    >,
}
#[doc = "\tThis struct defines a specific frame format that is being requested\n\tfromt the importer. Any member can be 0, which means that any value\n\tis an acceptable match. For instance, the host might ask for a specific\n\twidth and height, but pass 0 as the pixel format, meaning it can accept\n\tany pixel format."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct imFrameFormat {
    pub inFrameWidth: csSDK_int32,
    pub inFrameHeight: csSDK_int32,
    pub inPixelFormat: PrPixelFormat,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKPPixCacheSuite {
    #[doc = "\tThis will add the ppix to the frame cache for this importer instance and stream.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to add.\n\t@param\tinFrameNumber\t\tThe frame number of the ppix.\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length"]
    pub AddFrameToCache: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inPPixHand: PPixHand,
            inFrameNumber: csSDK_int32,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will retrieve a ppix from the frame cache for this importer instance and stream.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinFrameNumber\t\tThe frame number of the ppix requested.\n\t@param\toutPPixHand\t\t\tA pointer to a ppix handle to hold the retrieved frame.\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length"]
    pub GetFrameFromCache: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inFrameNumber: csSDK_int32,
            inNumFormats: csSDK_int32,
            inFormats: *mut imFrameFormat,
            outPPixHand: *mut PPixHand,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will add the ppix to the raw cache for this importer instance.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinPPixHand\t\t\tThe raw ppix handle you want to add.\n\t@param\tinKey\t\t\t\tThe key to use for this raw ppix. If an entry with this key already\n\t\t\t\t\t\t\t\texists, this call will fail."]
    pub AddRawPPixToCache: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inPPixHand: PPixHand,
            inKey: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will retrieve a ppix from the frame cache for this importer instance.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinKey\t\t\t\tThe key to identify this raw ppix.\n\t@param\toutPPixHand\t\t\tA pointer to a ppix handle to hold the retrieved frame."]
    pub GetRawPPixFromCache: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inKey: csSDK_int32,
            outPPixHand: *mut PPixHand,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis function allows you to cache a PPix using a GUID as an identifier.\n\n\t@param\tinPPixIdentifier\tThe ID of the PPix, used to identify this particular set of pixels.\n\t\t\t\t\t\t\t\tThe GUID can be anything, but must be unique.\n\t@param\tinPPix\t\t\t\tThe Pixels to put in the cache. If a frame with this id is already in the cache,\n\t\t\t\t\t\t\t\tthen this PPix will be ignored. You still have ownership over the PPix.\n\t\t\t\t\t\t\t\tYou may want to get the PPix from the cache after this, in case your frame is redundant."]
    pub AddNamedPPixToCache: ::std::option::Option<
        unsafe extern "C" fn(inPPixIdentifier: *const prPluginID, inPPix: PPixHand) -> prSuiteError,
    >,
    #[doc = "\tThis function retrieves a named PPix from the cache.\n\n\t@param\tinPPixIdentifier\tThe ID of the PPix.\n\t@param\toutPPixHand\t\t\tThe PPix, if it's available. If it's not in the cache, this will be NULL.\n\t\t\t\t\t\t\t\tYou are responsible for calling PPixDispose on this PPix, like any other."]
    pub GetNamedPPixFromCache: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixIdentifier: *const prPluginID,
            outPPixHand: *mut PPixHand,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis function registers a dependency on a PPix. If a frame with that identifier is in the cache now,\n\tor ends up in the cache soon, then it will not be flushed from the cache while there are outstanding\n\tdependencies. You are responsible for call the Unregister function - if you don't then this is the\n\tsame as a memory leak of a PPix.\n\n\t@param\tinPPixIdentifier\tThe ID of the PPix you want held in the cache."]
    pub RegisterDependencyOnNamedPPix: ::std::option::Option<
        unsafe extern "C" fn(inPPixIdentifier: *const prPluginID) -> prSuiteError,
    >,
    #[doc = "\tThis function unregisters a dependency on a named PPix. This must be called for every successful call of\n\tRegisterDependencyOnNamedPPix\n\n\t@param inPPixIdentifier\t\tThe ID of the PPix you no longer need in the cache."]
    pub UnregisterDependencyOnNamedPPix: ::std::option::Option<
        unsafe extern "C" fn(inPPixIdentifier: *const prPluginID) -> prSuiteError,
    >,
    #[doc = "  This function attempts to flush a frame from the cache. If the frame has a registered dependency, then the\n  frame will remain available until the dependency count hits zero.\n\n\t@param inPPixIdentifier\t\tThe ID of the PPix you want forcibly removed from the cache."]
    pub ExpireNamedPPixFromCache: ::std::option::Option<
        unsafe extern "C" fn(inPPixIdentifier: *const prPluginID) -> prSuiteError,
    >,
    #[doc = "  This function attempts to flush all ppixes from the cache."]
    pub ExpireAllPPixesFromCache: ::std::option::Option<unsafe extern "C" fn() -> prSuiteError>,
    #[doc = "\tThis will add the ppix to the frame cache for this importer instance and stream.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to add.\n\t@param\tinFrameNumber\t\tThe frame number of the ppix.\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length\n\t@param\tinColorProfileName\tThe name of the selected color profile. This is only worth providing if your\n\t\t\t\t\t\t\t\tImporter supports color management, and has more than one possible profile.\n\t\t\t\t\t\t\t\tOtherwise we will default to the single profile provided.\n\t@param\tinColorProfileData\tThis is completely optional. We will use the color profile data provided\n\t\t\t\t\t\t\t\tthrough the imGetIndColorProfile selector. In some future version we will\n\t\t\t\t\t\t\t\tallow Importers to support arbitrary profiles, at which point this param will\n\t\t\t\t\t\t\t\tbe useful."]
    pub AddFrameToCacheWithColorProfile: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inPPixHand: PPixHand,
            inFrameNumber: csSDK_int32,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
            inColorProfileName: *mut PrSDKString,
            inColorProfileData: *mut ::std::os::raw::c_void,
            inColorProfileDataLength: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will retrieve a ppix from the frame cache for this importer instance and stream.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinFrameNumber\t\tThe frame number of the ppix requested.\n\t@param\toutPPixHand\t\t\tA pointer to a ppix handle to hold the retrieved frame.\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length\n\t@param\tinColorProfileName\tThe name of the selected color profile. This is only worth providing if your\n\t\t\t\t\t\t\t\tImporter supports color management, and has more than one possible profile.\n\t\t\t\t\t\t\t\tOtherwise we will default to the single profile provided.\n\t@param\tinColorProfileData\tThis is completely optional. We will use the color profile data provided\n\t\t\t\t\t\t\t\tthrough the imGetIndColorProfile selector. In some future version we will\n\t\t\t\t\t\t\t\tallow Importers to support arbitrary profiles, at which point this param will\n\t\t\t\t\t\t\t\tbe useful."]
    pub GetFrameFromCacheWithColorProfile: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inFrameNumber: csSDK_int32,
            inNumFormats: csSDK_int32,
            inFormats: *mut imFrameFormat,
            outPPixHand: *mut PPixHand,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
            inColorProfileName: *mut PrSDKString,
            inColorProfileData: *mut ::std::os::raw::c_void,
            inColorProfileDataSize: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will add the ppix to the frame cache for this importer instance and stream.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to add.\n\t@param\tinFrameNumber\t\tThe frame number of the ppix.\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length\n\t@param\tinColorProfileName\tThe name of the selected color profile. This is only worth providing if your\n\t\t\t\t\t\t\t\tImporter supports color management, and has more than one possible profile.\n\t\t\t\t\t\t\t\tOtherwise we will default to the single profile provided.\n\t@param\tinColorProfileData\tThis is completely optional. We will use the color profile data provided\n\t\t\t\t\t\t\t\tthrough the imGetIndColorProfile selector. In some future version we will\n\t\t\t\t\t\t\t\tallow Importers to support arbitrary profiles, at which point this param will\n\t\t\t\t\t\t\t\tbe useful."]
    pub AddFrameToCacheWithColorProfile2: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inPPixHand: PPixHand,
            inFrameNumber: csSDK_int32,
            inQuality: PrRenderQuality,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
            inColorProfileName: *mut PrSDKString,
            inColorProfileData: *mut ::std::os::raw::c_void,
            inColorProfileDataLength: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will retrieve a ppix from the frame cache for this importer instance and stream.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinFrameNumber\t\tThe frame number of the ppix requested.\n\t@param\toutPPixHand\t\t\tA pointer to a ppix handle to hold the retrieved frame.\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length\n\t@param\tinColorProfileName\tThe name of the selected color profile. This is only worth providing if your\n\t\t\t\t\t\t\t\tImporter supports color management, and has more than one possible profile.\n\t\t\t\t\t\t\t\tOtherwise we will default to the single profile provided.\n\t@param\tinColorProfileData\tThis is completely optional. We will use the color profile data provided\n\t\t\t\t\t\t\t\tthrough the imGetIndColorProfile selector. In some future version we will\n\t\t\t\t\t\t\t\tallow Importers to support arbitrary profiles, at which point this param will\n\t\t\t\t\t\t\t\tbe useful."]
    pub GetFrameFromCacheWithColorProfile2: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inFrameNumber: csSDK_int32,
            inNumFormats: csSDK_int32,
            inFormats: *mut imFrameFormat,
            outPPixHand: *mut PPixHand,
            inQuality: PrRenderQuality,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
            inColorProfileName: *mut PrSDKString,
            inColorProfileData: *mut ::std::os::raw::c_void,
            inColorProfileDataSize: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will add the ppix to the frame cache for this importer instance and stream.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to add.\n\t@param\tinFrameNumber\t\tThe frame number of the ppix.\n\t@param\tinQuality\t\t\tThe quality level with which to render the frame\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length\n\t@param\tinPrColorSpaceID\tcolor space for the frame to be cached; this is an opaque token passed to the importer by the host that importer is expected to use in color management APIs"]
    pub AddFrameToCacheWithColorSpace: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inPPixHand: PPixHand,
            inFrameNumber: csSDK_int32,
            inQuality: PrRenderQuality,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
            inPrColorSpaceID: *mut PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will retrieve a ppix from the frame cache for this importer instance and stream.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinFrameNumber\t\tThe frame number of the ppix requested.\n @param\tinNumFormats\t\tThe number of frame formats\n\t@param\tinFormats\t\t\tThe array of frame formats\n\t@param\toutPPixHand\t\t\tA pointer to a ppix handle to hold the retrieved frame.\n\t@param\tinQuality\t\t\tThe quality level with which to render the frame\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length\n\t@param\tinPrColorSpaceID\tcolor space to be used as part of identifier to retrieve a frame from cache; this is an opaque token passed to the importer by the host that importer is expected to use in color management APIs"]
    pub GetFrameFromCacheWithColorSpace: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inFrameNumber: csSDK_int32,
            inNumFormats: csSDK_int32,
            inFormats: *mut imFrameFormat,
            outPPixHand: *mut PPixHand,
            inQuality: PrRenderQuality,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
            inPrColorSpaceID: *mut PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis function registers a dependency on a PPix. If a frame with these settings is in the cache now,\n\tor ends up in the cache soon, then it will not be flushed from the cache while there are outstanding\n\tdependencies. You are responsible for calling the UnregisterDependencyOnNamedPPix function with the\n  returned identifier - if you don't then this is the same as a memory leak of a PPix.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinFrameNumber\t\tThe frame number of the ppix.\n\t@param\toutPPixIdentifier\tThe pointer to the ppix Identifer obtained for the frame\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length"]
    pub RegisterDependencyOnFrame: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inFrameNumber: csSDK_int32,
            inNumFormats: csSDK_int32,
            inFormats: *mut imFrameFormat,
            outPPixIdentifier: *mut prPluginID,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis function registers a dependency on a PPix. If a frame with these settings is in the cache now,\n\tor ends up in the cache soon, then it will not be flushed from the cache while there are outstanding\n\tdependencies. You are responsible for calling the UnregisterDependencyOnNamedPPix function with the\n  returned identifier - if you don't then this is the same as a memory leak of a PPix.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinFrameNumber\t\tThe frame number of the ppix.\n\t@param\toutPPixIdentifier\tThe pointer to the ppix Identifer obtained for the frame\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length\n\t@param\tinColorProfileName\tThe name of the selected color profile. This is only worth providing if your\n\t\t\t\t\t\t\t\tImporter supports color management, and has more than one possible profile.\n\t\t\t\t\t\t\t\tOtherwise we will default to the single profile provided.\n\t@param\tinColorProfileData\tThis is completely optional. We will use the color profile data provided\n\t\t\t\t\t\t\t\tthrough the imGetIndColorProfile selector. In some future version we will\n\t\t\t\t\t\t\t\tallow Importers to support arbitrary profiles, at which point this param will\n\t\t\t\t\t\t\t\tbe useful."]
    pub RegisterDependencyOnFrameWithColorProfile: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inFrameNumber: csSDK_int32,
            inNumFormats: csSDK_int32,
            inFormats: *mut imFrameFormat,
            outPPixIdentifier: *mut prPluginID,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
            inColorProfileName: *mut PrSDKString,
            inColorProfileData: *mut ::std::os::raw::c_void,
            inColorProfileDataSize: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis function registers a dependency on a PPix. If a frame with these settings is in the cache now,\n\tor ends up in the cache soon, then it will not be flushed from the cache while there are outstanding\n\tdependencies. You are responsible for calling the UnregisterDependencyOnNamedPPix function with the\n  returned identifier - if you don't then this is the same as a memory leak of a PPix.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinFrameNumber\t\tThe frame number of the ppix.\n\t@param\toutPPixIdentifier\tThe pointer to the ppix Identifer obtained for the frame\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length\n\t@param\tinColorProfileName\tThe name of the selected color profile. This is only worth providing if your\n\t\t\t\t\t\t\t\tImporter supports color management, and has more than one possible profile.\n\t\t\t\t\t\t\t\tOtherwise we will default to the single profile provided.\n\t@param\tinColorProfileData\tThis is completely optional. We will use the color profile data provided\n\t\t\t\t\t\t\t\tthrough the imGetIndColorProfile selector. In some future version we will\n\t\t\t\t\t\t\t\tallow Importers to support arbitrary profiles, at which point this param will\n\t\t\t\t\t\t\t\tbe useful."]
    pub RegisterDependencyOnFrameWithColorProfile2: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inFrameNumber: csSDK_int32,
            inNumFormats: csSDK_int32,
            inFormats: *mut imFrameFormat,
            inQuality: PrRenderQuality,
            outPPixIdentifier: *mut prPluginID,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
            inColorProfileName: *mut PrSDKString,
            inColorProfileData: *mut ::std::os::raw::c_void,
            inColorProfileDataSize: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis function registers a dependency on a PPix. If a frame with these settings is in the cache now,\n\tor ends up in the cache soon, then it will not be flushed from the cache while there are outstanding\n\tdependencies. You are responsible for calling the UnregisterDependencyOnNamedPPix function with the\n  returned identifier - if you don't then this is the same as a memory leak of a PPix.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinFrameNumber\t\tThe frame number of the ppix.\n \t@param\tinNumFormats\t\tThe number of frame formats\n\t@param\tinFormats\t\t\tThe array of frame formats\n\t@param\tinQuality\t\t\tThe quality level with which to render the frame\n\t@param\toutPPixIdentifier\tThe pointer to the ppix Identifer obtained for the frame\n\t@param\tinPreferences\t\tCurrent importer preferences, can be NULL for no preferences\n\t@param\tinPreferencesLength\tCurrent importer preferences length\n\t@param\tinPrColorSpaceID\tcolor space to be used as part of identifier to retrieve a frame from cache; this is an opaque token passed to the importer by the host that importer is expected to use in color management APIs"]
    pub RegisterDependencyOnFrameWithColorSpace: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inFrameNumber: csSDK_int32,
            inNumFormats: csSDK_int32,
            inFormats: *mut imFrameFormat,
            inQuality: PrRenderQuality,
            outPPixIdentifier: *mut prPluginID,
            inPreferences: *mut ::std::os::raw::c_void,
            inPreferencesLength: csSDK_int32,
            inPrColorSpaceID: *mut PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKPPixCacheSuite1 {
    #[doc = "\tThis will add the ppix to the frame cache for this importer instance and stream.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinPPixHand\t\t\tThe ppix handle you want to add.\n\t@param\tinFrameNumber\t\tThe frame number of the ppix."]
    pub AddFrameToCache: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inPPixHand: PPixHand,
            inFrameNumber: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will retrieve a ppix from the frame cache for this importer instance and stream.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinStreamIndex\t\tThe index of this stream\n\t@param\tinFrameNumber\t\tThe frame number of the ppix requested.\n\t@param\toutPPixHand\t\t\tA pointer to a ppix handle to hold the retrieved frame."]
    pub GetFrameFromCache: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inStreamIndex: csSDK_int32,
            inFrameNumber: csSDK_int32,
            inNumFormats: csSDK_int32,
            inFormats: *mut imFrameFormat,
            outPPixHand: *mut PPixHand,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will add the ppix to the raw cache for this importer instance.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinPPixHand\t\t\tThe raw ppix handle you want to add.\n\t@param\tinKey\t\t\t\tThe key to use for this raw ppix. If an entry with this key already\n\t\t\t\t\t\t\t\texists, this call will fail."]
    pub AddRawPPixToCache: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inPPixHand: PPixHand,
            inKey: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will retrieve a ppix from the frame cache for this importer instance.\n\n\t@param\tinImporterID\t\tThe ID of this importer instance (passed down in imGetInfo8).\n\t@param\tinKey\t\t\t\tThe key to identify this raw ppix.\n\t@param\toutPPixHand\t\t\tA pointer to a ppix handle to hold the retrieved frame."]
    pub GetRawPPixFromCache: ::std::option::Option<
        unsafe extern "C" fn(
            inImporterID: csSDK_uint32,
            inKey: csSDK_int32,
            outPPixHand: *mut PPixHand,
        ) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKPPixCreator2Suite {
    #[doc = "\tThis will create a new ppix.\n\n\t@param\toutPPixHand\t\t\t\t\t\tThe new ppix handle if the create was successfull. NULL otherwise.\n\t@param\tinRequestedAccess\t\t\t\tRequested pixel access. ReadOnly is not allowed (doesn't make sense).\n\t@param\tinPixelFormat\t\t\t\t\tThe pixel format of this ppix.\n\t@param\tinWidth\t\t\t\t\t\t\tThe horizontal size of the ppix.\n\t@param\tinHeight\t\t\t\t\t\tThe vertical size of the ppix.\n\t@param\tinUseFields\t\t\t\t\t\tIf true, the ppix is a field.\n\t@param\tinFieldNumber\t\t\t\t\tIf inUseFields is true, this specifies first field (0) or second (1)\n\t@param\tinPARNumerator\t\t\t\t\tThe pixel aspect ratio numerator for the ppix.\n\t@param\tinPARDenominator\t\t\t\tThe pixel aspect ratio denominator for the ppix."]
    pub CreatePPix: ::std::option::Option<
        unsafe extern "C" fn(
            outPPixHand: *mut PPixHand,
            inRequestedAccess: PrPPixBufferAccess,
            inPixelFormat: PrPixelFormat,
            inWidth: ::std::os::raw::c_int,
            inHeight: ::std::os::raw::c_int,
            inUseFields: bool,
            inFieldNumber: ::std::os::raw::c_int,
            inPARNumerator: ::std::os::raw::c_int,
            inPARDenominator: ::std::os::raw::c_int,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will create a new raw ppix.\n\n\t@param\toutPPixHand\t\t\t\t\t\tThe new ppix handle if the create was successfull. NULL otherwise.\n\t@param\tinRequestedAccess\t\t\t\tRequested pixel access. ReadOnly is not allowed (doesn't make sense).\n\t@param\tinSize\t\t\t\t\t\t\tThe size of the ppix in bytes.\n\t@param\tinAlignment\t\t\t\t\t\tThe alignment of the beginning of the ppix in bytes."]
    pub CreateRawPPix: ::std::option::Option<
        unsafe extern "C" fn(
            outPPixHand: *mut PPixHand,
            inRequestedAccess: PrPPixBufferAccess,
            inSize: ::std::os::raw::c_int,
            inAlignment: ::std::os::raw::c_int,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will create a new ppix in a custom pixel format.\n\n\t@param\toutPPixHand\t\t\t\t\t\tThe new ppix handle if the create was successfull. NULL otherwise.\n\t@param\tinRequestedAccess\t\t\t\tRequested pixel access. ReadOnly is not allowed (doesn't make sense).\n\t@param\tinPixelFormat\t\t\t\t\tThe pixel format of this ppix.\n\t@param\tinWidth\t\t\t\t\t\t\tThe horizontal size of the ppix.\n\t@param\tinHeight\t\t\t\t\t\tThe vertical size of the ppix.\n\t@param\tinPARNumerator\t\t\t\t\tThe pixel aspect ratio numerator for the ppix.\n\t@param\tinPARDenominator\t\t\t\tThe pixel aspect ratio denominator for the ppix.\n\t@param\tinDataBufferSize\t\t\t\tThe number of bytes requested, not including the header."]
    pub CreateCustomPPix: ::std::option::Option<
        unsafe extern "C" fn(
            outPPixHand: *mut PPixHand,
            inRequestedAccess: PrPPixBufferAccess,
            inPixelFormat: PrPixelFormat,
            inWidth: ::std::os::raw::c_int,
            inHeight: ::std::os::raw::c_int,
            inPARNumerator: ::std::os::raw::c_int,
            inPARDenominator: ::std::os::raw::c_int,
            inDataBufferSize: ::std::os::raw::c_int,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will create a new ppix properly aligned for reading from disk.\n\n\t@param\toutPPixHand\t\t\t\t\t\t\t\t\tThe new ppix handle if the create was successfull. NULL otherwise.\n\t@param\tinPixelFormat\t\t\t\t\t\t\t\tThe pixel format of this ppix.\n\t@param\tinWidth\t\t\t\t\t\t\t\t\t\tThe horizontal size of the ppix.\n\t@param\tinHeight\t\t\t\t\t\t\t\t\tThe vertical size of the ppix.\n\t@param\tinPARNumerator\t\t\t\t\t\t\t\tThe pixel aspect ratio numerator for the ppix.\n\t@param\tinPARDenominator\t\t\t\t\t\t\tThe pixel aspect ratio denominator for the ppix.\n\t@param\tinMemoryAlignment\t\t\t\t\t\t\tThe alignment of memory required for the start of the first sector.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tIf this value is zero, then we will align to the sector size.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tThis value must be a multiple of the pixel size or bad things will happen.\n\t@param\tinSectorSize\t\t\t\t\t\t\t\tThe size of a sector on disk. The required amount of memory will be padded\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tup to a multiple of the sector size. If this is zero, then there will be no padding.\n\t@param\tinOffsetToPixelDataFromFirstSectorStart\t\tThe number of bytes between the start of the first sector and the start\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tof the pixel data. The resulting pixel start location must be aligned to\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthe pixel size."]
    pub CreateDiskAlignedPPix: ::std::option::Option<
        unsafe extern "C" fn(
            outPPixHand: *mut PPixHand,
            inPixelFormat: PrPixelFormat,
            inWidth: ::std::os::raw::c_int,
            inHeight: ::std::os::raw::c_int,
            inPARNumerator: ::std::os::raw::c_int,
            inPARDenominator: ::std::os::raw::c_int,
            inMemoryAlignment: ::std::os::raw::c_int,
            inSectorSize: ::std::os::raw::c_int,
            inOffsetToPixelDataFromFirstSectorStart: ::std::os::raw::c_int,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will create a new ppix.\n\n\t@param\toutPPixHand\t\t\t\t\t\tThe new ppix handle if the create was successfull. NULL otherwise.\n\t@param\tinRequestedAccess\t\t\t\tRequested pixel access. ReadOnly is not allowed (doesn't make sense).\n\t@param\tinPixelFormat\t\t\t\t\tThe pixel format of this ppix.\n\t@param\tinWidth\t\t\t\t\t\t\tThe horizontal size of the ppix.\n\t@param\tinHeight\t\t\t\t\t\tThe vertical size of the ppix.\n\t@param\tinUseFields\t\t\t\t\t\tIf true, the ppix is a field.\n\t@param\tinFieldNumber\t\t\t\t\tIf inUseFields is true, this specifies first field (0) or second (1)\n\t@param\tinPARNumerator\t\t\t\t\tThe pixel aspect ratio numerator for the ppix.\n\t@param\tinPARDenominator\t\t\t\tThe pixel aspect ratio denominator for the ppix.\n\t@param \tinColorSpaceID\t\t\t\t\topaque color space identifier; new video frame will be tagged with this color space"]
    pub CreateColorManagedPPix: ::std::option::Option<
        unsafe extern "C" fn(
            outPPixHand: *mut PPixHand,
            inRequestedAccess: PrPPixBufferAccess,
            inPixelFormat: PrPixelFormat,
            inWidth: ::std::os::raw::c_int,
            inHeight: ::std::os::raw::c_int,
            inUseFields: bool,
            inFieldNumber: ::std::os::raw::c_int,
            inPARNumerator: ::std::os::raw::c_int,
            inPARDenominator: ::std::os::raw::c_int,
            inColorSpaceID: PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will create a new ppix in a custom pixel format.\n\n\t@param\toutPPixHand\t\t\t\t\t\tThe new ppix handle if the create was successfull. NULL otherwise.\n\t@param\tinRequestedAccess\t\t\t\tRequested pixel access. ReadOnly is not allowed (doesn't make sense).\n\t@param\tinPixelFormat\t\t\t\t\tThe pixel format of this ppix.\n\t@param\tinWidth\t\t\t\t\t\t\tThe horizontal size of the ppix.\n\t@param\tinHeight\t\t\t\t\t\tThe vertical size of the ppix.\n\t@param\tinPARNumerator\t\t\t\t\tThe pixel aspect ratio numerator for the ppix.\n\t@param\tinPARDenominator\t\t\t\tThe pixel aspect ratio denominator for the ppix.\n\t@param\tinDataBufferSize\t\t\t\tThe number of bytes requested, not including the header.\n\t@param \tinColorSpaceID\t\t\t\t\topaque color space identifier; new video frame will be tagged with this color space"]
    pub CreateColorManagedCustomPPix: ::std::option::Option<
        unsafe extern "C" fn(
            outPPixHand: *mut PPixHand,
            inRequestedAccess: PrPPixBufferAccess,
            inPixelFormat: PrPixelFormat,
            inWidth: ::std::os::raw::c_int,
            inHeight: ::std::os::raw::c_int,
            inPARNumerator: ::std::os::raw::c_int,
            inPARDenominator: ::std::os::raw::c_int,
            inDataBufferSize: ::std::os::raw::c_int,
            inColorSpaceID: PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will create a new ppix properly aligned for reading from disk.\n\n\t@param\toutPPixHand\t\t\t\t\t\t\t\t\tThe new ppix handle if the create was successfull. NULL otherwise.\n\t@param\tinPixelFormat\t\t\t\t\t\t\t\tThe pixel format of this ppix.\n\t@param\tinWidth\t\t\t\t\t\t\t\t\t\tThe horizontal size of the ppix.\n\t@param\tinHeight\t\t\t\t\t\t\t\t\tThe vertical size of the ppix.\n\t@param\tinPARNumerator\t\t\t\t\t\t\t\tThe pixel aspect ratio numerator for the ppix.\n\t@param\tinPARDenominator\t\t\t\t\t\t\tThe pixel aspect ratio denominator for the ppix.\n\t@param\tinMemoryAlignment\t\t\t\t\t\t\tThe alignment of memory required for the start of the first sector.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tIf this value is zero, then we will align to the sector size.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tThis value must be a multiple of the pixel size or bad things will happen.\n\t@param\tinSectorSize\t\t\t\t\t\t\t\tThe size of a sector on disk. The required amount of memory will be padded\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tup to a multiple of the sector size. If this is zero, then there will be no padding.\n\t@param\tinOffsetToPixelDataFromFirstSectorStart\t\tThe number of bytes between the start of the first sector and the start\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tof the pixel data. The resulting pixel start location must be aligned to\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthe pixel size.\n\t@param \tinColorSpaceID\t\t\t\t\t\t\t\topaque color space identifier; new video frame will be tagged with this color space"]
    pub CreateColorManagedDiskAlignedPPix: ::std::option::Option<
        unsafe extern "C" fn(
            outPPixHand: *mut PPixHand,
            inPixelFormat: PrPixelFormat,
            inWidth: ::std::os::raw::c_int,
            inHeight: ::std::os::raw::c_int,
            inPARNumerator: ::std::os::raw::c_int,
            inPARDenominator: ::std::os::raw::c_int,
            inMemoryAlignment: ::std::os::raw::c_int,
            inSectorSize: ::std::os::raw::c_int,
            inOffsetToPixelDataFromFirstSectorStart: ::std::os::raw::c_int,
            inColorSpaceID: PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKPPixCreatorSuite {
    #[doc = "\tThis will create a new ppix.\n\n\t@param\toutPPixHand\t\t\t\t\t\tThe new ppix handle if the create was successfull. NULL otherwise.\n\t@param\tinRequestedAccess\t\t\t\tRequested pixel access. ReadOnly is not allowed (doesn't make sense).\n\t@param\tinPixelFormat\t\t\t\t\tThe pixel format of this ppix."]
    pub CreatePPix: ::std::option::Option<
        unsafe extern "C" fn(
            outPPixHand: *mut PPixHand,
            inRequestedAccess: PrPPixBufferAccess,
            inPixelFormat: PrPixelFormat,
            inBoundingRect: *const prRect,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will clone an existing ppix. It will ref-count the ppix if only read-access is requested and\n\t\tthe ppix to copy from is read-only as well, otherwise it will create a new one and copy.\n\n\t@param\tinPPixToClone\t\t\t\t\tThe ppix to clone from.\n\t@param\toutPPixHand\t\t\t\t\t\tThe new ppix handle if the create was successfull. NULL otherwise.\n\t@param\tinRequestedAccess\t\t\t\tRequested pixel access on the new ppix. (Only PrPPixBufferAccess_ReadOnly is allowed right now)."]
    pub ClonePPix: ::std::option::Option<
        unsafe extern "C" fn(
            inPPixToClone: PPixHand,
            outPPixHand: *mut PPixHand,
            inRequestedAccess: PrPPixBufferAccess,
        ) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSceneTimebaseRec {
    pub scale: csSDK_uint32,
    pub sampleSize: csSDK_int32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSceneRecord {
    pub startTime: csSDK_int32,
    pub duration: csSDK_int32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrSceneMetaDataRec {
    pub timeBase: PrSceneTimebaseRec,
    pub scenes: [PrSceneRecord; 1usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKSequenceInfoSuite {
    #[doc = "\tGet the video frame size of the sequence.\n\n\t@param\tinTimelineID\tthe timeline instance data\n\t@param\toutFrameRect\ton return, the size of the sequence video frame."]
    pub GetFrameRect: ::std::option::Option<
        unsafe extern "C" fn(inTimelineID: PrTimelineID, outFrameRect: *mut prRect) -> prSuiteError,
    >,
    #[doc = "\tGet the aspect ratio of the sequence.\n\n\t@param\tinTimelineID\tthe timeline instance data\n\t@param\toutNumerator\ton return, the aspect ratio numerator.\n\t@param\toutDenominator\ton return, the aspect ratio denominator."]
    pub GetPixelAspectRatio: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineID: PrTimelineID,
            outNumerator: *mut csSDK_uint32,
            outDenominator: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the framerate of the sequence.\n\n\t@param\tinTimelineID\t\tthe timeline instance data\n\t@param\toutTicksPerFrame\tthe framerate in ticks."]
    pub GetFrameRate: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineID: PrTimelineID,
            outTicksPerFrame: *mut PrTime,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the field type of the sequence.\n\n\t@param\tinTimelineID\t\tthe timeline instance data\n\t@param\toutFieldType\t\tthe field type."]
    pub GetFieldType: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineID: PrTimelineID,
            outFieldType: *mut prFieldType,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the zero point of the sequence.\n\n\t@param\tinTimelineID\t\tthe timeline instance data\n\t@param\toutTicksPerFrame\tstart time of the sequence."]
    pub GetZeroPoint: ::std::option::Option<
        unsafe extern "C" fn(inTimelineID: PrTimelineID, outTime: *mut PrTime) -> prSuiteError,
    >,
    #[doc = "\tReturns if the sequence timecode is drop or non drop.\n\n\t@param\tinTimelineID\t\tthe timeline instance data\n\t@param\toutDropFrame\t\tif the sequence timecode is dropframe"]
    pub GetTimecodeDropFrame: ::std::option::Option<
        unsafe extern "C" fn(inTimelineID: PrTimelineID, outDropFrame: *mut prBool) -> prSuiteError,
    >,
    #[doc = "\tReturns if the sequence has the proxy flag set.\n\n\t@param\tinTimelineID\t\tthe timeline instance data\n\t@param\toutProxyFlag\t\tif the sequence is in proxy mode"]
    pub GetProxyFlag: ::std::option::Option<
        unsafe extern "C" fn(inTimelineID: PrTimelineID, outDropFrame: *mut prBool) -> prSuiteError,
    >,
    #[doc = "\tReturns the VR Video settings of the specified sequence.\n\n\t@param\tinTimelineID\t\t\t\tThe timeline instance data.\n\t@param\toutProjectionType\t\t\tThe type of projection the specified sequence is using.\n\t@param\toutFrameLayout\t\t\t\tThe type of frame layout the specified sequence is using.\n\t@param\toutHorizontalCapturedView\tHow many degrees of horizontal view is captured in the video stream (up to 360).\n\t@param\toutVerticalCapturedView\t\tHow many degrees of vertical view is captured in the video stream (up to 180)."]
    pub GetImmersiveVideoVRConfiguration: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineID: PrTimelineID,
            outProjectionType: *mut PrIVProjectionType,
            outFrameLayout: *mut PrIVFrameLayout,
            outHorizontalCapturedView: *mut csSDK_uint32,
            outVerticalCapturedView: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
    #[doc = " Returns the identifier of the sequence working color space\n\n\t@param\tinTimelineID\t\t\t\tThe timeline instance data.\n\t@param\toutPrWorkingColorSpaceID\tPrSDKColorSpaceID with working color space identifier\n"]
    pub GetWorkingColorSpace: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineID: PrTimelineID,
            outPrWorkingColorSpaceID: *mut PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the HDR graphics white luminance value of the sequence in nits.\n\n\t@param\tinTimelineID\tthe timeline instance data\n\t@param\toutGraphicsWhiteLuminance\ton return, HDR graphics white luminance value of the sequence in nits."]
    pub GetGraphicsWhiteLuminance: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineID: PrTimelineID,
            outGraphicsWhiteLuminance: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
}
pub type PrSDKStreamLabel = *const ::std::os::raw::c_char;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SequenceRender_FrameInfoRec {
    pub repeatCount: csSDK_int32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SequenceRender_GetFrameReturnRec {
    pub asyncCompletionData: *mut ::std::os::raw::c_void,
    pub returnVal: csSDK_int32,
    pub repeatCount: csSDK_int32,
    pub onMarker: csSDK_int32,
    pub outFrame: PPixHand,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SequenceRender_ParamsRec {
    pub inRequestedPixelFormatArray: *const PrPixelFormat,
    pub inRequestedPixelFormatArrayCount: csSDK_int32,
    pub inWidth: csSDK_int32,
    pub inHeight: csSDK_int32,
    pub inPixelAspectRatioNumerator: csSDK_int32,
    pub inPixelAspectRatioDenominator: csSDK_int32,
    pub inRenderQuality: PrRenderQuality,
    pub inFieldType: prFieldType,
    pub inDeinterlace: csSDK_int32,
    pub inDeinterlaceQuality: PrRenderQuality,
    pub inCompositeOnBlack: csSDK_int32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SequenceRender_ParamsRecExt {
    pub inRequestedPixelFormatArray: *const PrPixelFormat,
    pub inRequestedPixelFormatArrayCount: csSDK_int32,
    pub inWidth: csSDK_int32,
    pub inHeight: csSDK_int32,
    pub inPixelAspectRatioNumerator: csSDK_int32,
    pub inPixelAspectRatioDenominator: csSDK_int32,
    pub inRenderQuality: PrRenderQuality,
    pub inFieldType: prFieldType,
    pub inDeinterlace: csSDK_int32,
    pub inDeinterlaceQuality: PrRenderQuality,
    pub inCompositeOnBlack: csSDK_int32,
    pub inPrSDKColorSpaceID: PrSDKColorSpaceID,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SequenceRender_ParamsRecExt2 {
    pub inRequestedPixelFormatArray: *const PrPixelFormat,
    pub inRequestedPixelFormatArrayCount: csSDK_int32,
    pub inWidth: csSDK_int32,
    pub inHeight: csSDK_int32,
    pub inPixelAspectRatioNumerator: csSDK_int32,
    pub inPixelAspectRatioDenominator: csSDK_int32,
    pub inRenderQuality: PrRenderQuality,
    pub inFieldType: prFieldType,
    pub inDeinterlace: csSDK_int32,
    pub inDeinterlaceQuality: PrRenderQuality,
    pub inCompositeOnBlack: csSDK_int32,
    pub inPrSDKColorSpaceID: PrSDKColorSpaceID,
    pub inPrSDKLUTID: PrSDKLUTID,
}
pub type PrSDKSequenceAsyncRenderCompletionProc = ::std::option::Option<
    unsafe extern "C" fn(
        inVideoRenderID: csSDK_uint32,
        inCallbackRef: *mut ::std::os::raw::c_void,
        inTime: PrTime,
        inRenderedFrame: PPixHand,
        inGetFrameReturn: *mut SequenceRender_GetFrameReturnRec,
    ),
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKSequenceRenderSuite {
    pub MakeVideoRenderer: ::std::option::Option<
        unsafe extern "C" fn(
            pluginID: csSDK_uint32,
            outVideoRenderID: *mut csSDK_uint32,
            inFrameRate: PrTime,
        ) -> prSuiteError,
    >,
    pub ReleaseVideoRenderer: ::std::option::Option<
        unsafe extern "C" fn(pluginID: csSDK_uint32, inVideoRenderID: csSDK_uint32) -> prSuiteError,
    >,
    pub RenderVideoFrame: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            inRenderParams: *mut SequenceRender_ParamsRec,
            inCacheFlags: PrRenderCacheType,
            getFrameReturn: *mut SequenceRender_GetFrameReturnRec,
        ) -> prSuiteError,
    >,
    pub QueueAsyncVideoFrameRender: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            outRequestID: *mut csSDK_uint32,
            inRenderParams: *mut SequenceRender_ParamsRec,
            inCacheFlags: PrRenderCacheType,
            inAsyncCompletionData: *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    pub SetAsyncRenderCompletionProc: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            asyncGetFrameCallback: PrSDKSequenceAsyncRenderCompletionProc,
            callbackRef: *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    pub GetFrameInfo: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            outFrameInfo: *mut SequenceRender_FrameInfoRec,
        ) -> prSuiteError,
    >,
    #[doc = "\tPre-fetches the media needed to render this frame.\n\tThis is a hint to the importers to begin reading media needed to render this video frame.\n\n\t@param\tinFrame\t\t\t\t\t\t\t\tThe video frame number."]
    pub PrefetchMedia: ::std::option::Option<
        unsafe extern "C" fn(inVideoRenderID: csSDK_uint32, inFrame: PrTime) -> prSuiteError,
    >,
    #[doc = "\tPre-fetches the media needed to render this frame, using all of the parameters used to render the frame.\n\tThis is a hint to the importers to begin reading media needed to render this video frame.\n\n\t@param\tinFrameTime\t\t\t\t\t\t\tThe time of the video frame number.\n\n\t@param\tinRequestedPixelFormatArray\t\t\tAn array of PrPixelFormats that list your format preferences in order.\n\t\t\t\t\t\t\t\t\t\t\t\tThis list must end with PrPixelFormat_BGRA_4444_8u.\n\t@param\tinRequestedPixelFormatArrayCount\tNumber of formats in the format array\n\t@param\tinFrameRect\t\t\t\t\t\t\tVideo frame size\n\t@param\tinPixelAspectRatioNumerator\t\t\tThe numerator for the pixel aspect ratio.\n\t@param\tinPixelAspectRatioDenominator\t\tThe denominator for the pixel aspect ratio.\n\t@param\tinRenderQuality\t\t\t\t\t\tThe render quality of this frame."]
    pub PrefetchMediaWithRenderParameters: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            inRenderParams: *mut SequenceRender_ParamsRec,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will cancel all media pre-fetches that are still outstanding."]
    pub CancelAllOutstandingMediaPrefetches:
        ::std::option::Option<unsafe extern "C" fn(inVideoRenderID: csSDK_uint32) -> prSuiteError>,
    #[doc = "\tIs all the prefetched media ready?"]
    pub IsPrefetchedMediaReady: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            outMediaReady: *mut prBool,
        ) -> prSuiteError,
    >,
    pub MakeVideoRendererForTimeline: ::std::option::Option<
        unsafe extern "C" fn(
            inTimeline: PrTimelineID,
            outVideoRendererID: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
    pub MakeVideoRendererForTimelineWithFrameRate: ::std::option::Option<
        unsafe extern "C" fn(
            inTimeline: PrTimelineID,
            inFrameRate: PrTime,
            outVideoRendererID: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
    pub ReleaseVideoRendererForTimeline: ::std::option::Option<
        unsafe extern "C" fn(inVideoRendererID: csSDK_uint32) -> prSuiteError,
    >,
    pub RenderVideoFrameAndConformToPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            inRenderParams: *mut SequenceRender_ParamsRec,
            inCacheFlags: PrRenderCacheType,
            inConformToFormat: PrPixelFormat,
            getFrameReturn: *mut SequenceRender_GetFrameReturnRec,
        ) -> prSuiteError,
    >,
    pub MakeVideoRendererForTimelineWithStreamLabel: ::std::option::Option<
        unsafe extern "C" fn(
            inTimeline: PrTimelineID,
            inStreamLabel: PrSDKStreamLabel,
            outVideoRendererID: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
    pub RenderColorManagedVideoFrame: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            inRenderParamsExt: *mut SequenceRender_ParamsRecExt,
            inCacheFlags: PrRenderCacheType,
            getFrameReturn: *mut SequenceRender_GetFrameReturnRec,
        ) -> prSuiteError,
    >,
    pub QueueAsyncColorManagedVideoFrameRender: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            outRequestID: *mut csSDK_uint32,
            inRenderParamsExt: *mut SequenceRender_ParamsRecExt,
            inCacheFlags: PrRenderCacheType,
            inAsyncCompletionData: *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    pub PrefetchColorManagedMedia: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inFrame: PrTime,
            inPrSDKColorSpaceID: PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
    pub PrefetchColorManagedMediaWithRenderParameters: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            inRenderParamsExt: *mut SequenceRender_ParamsRecExt,
        ) -> prSuiteError,
    >,
    pub RenderColorManagedVideoFrameAndConformToPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            inRenderParamsExt: *mut SequenceRender_ParamsRecExt,
            inCacheFlags: PrRenderCacheType,
            inConformToFormat: PrPixelFormat,
            getFrameReturn: *mut SequenceRender_GetFrameReturnRec,
        ) -> prSuiteError,
    >,
    pub RenderColorManagedVideoFrame2: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            inRenderParamsExt2: *mut SequenceRender_ParamsRecExt2,
            inCacheFlags: PrRenderCacheType,
            outGetFrameReturn: *mut SequenceRender_GetFrameReturnRec,
        ) -> prSuiteError,
    >,
    pub QueueAsyncColorManagedVideoFrameRender2: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            outRequestID: *mut csSDK_uint32,
            inRenderParamsExt2: *mut SequenceRender_ParamsRecExt2,
            inCacheFlags: PrRenderCacheType,
            inAsyncCompletionData: *mut ::std::os::raw::c_void,
        ) -> prSuiteError,
    >,
    pub PrefetchColorManagedMediaWithRenderParameters2: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            inRenderParamsExt2: *mut SequenceRender_ParamsRecExt2,
        ) -> prSuiteError,
    >,
    pub RenderColorManagedVideoFrameAndConformToPixelFormat2: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoRenderID: csSDK_uint32,
            inTime: PrTime,
            inRenderParamsExt2: *mut SequenceRender_ParamsRecExt2,
            inCacheFlags: PrRenderCacheType,
            inConformToFormat: PrPixelFormat,
            outGetFrameReturn: *mut SequenceRender_GetFrameReturnRec,
        ) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrClipSegmentInfo {
    pub mClipID: csSDK_int32,
    pub mSegmentStartTime: csSDK_int64,
    pub mSegmentEndTime: csSDK_int64,
    pub mSegmentOffset: csSDK_int64,
    pub mClipStartTime: csSDK_int64,
    pub mClipEndTime: csSDK_int64,
    pub mClipPath: PrSDKString,
    pub mMediaStartTime: csSDK_int64,
    pub mMediaEndTime: csSDK_int64,
}
pub type SegmentInfoCallback = ::std::option::Option<
    unsafe extern "C" fn(
        inCallbackData: *mut ::std::os::raw::c_void,
        inClipSegmentInfo: *mut PrClipSegmentInfo,
    ),
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKSmartRenderingSuite {
    pub BuildSmartRenderSegmentList: ::std::option::Option<
        unsafe extern "C" fn(
            inCallbackFunc: SegmentInfoCallback,
            inCallbackData: *mut ::std::os::raw::c_void,
            inSegmentsID: csSDK_int32,
            inTimeBase: PrTime,
            inPixelFormat: PrPixelFormat,
        ) -> prSuiteError,
    >,
    pub BuildSmartRenderSegmentListNoPreviewFiles: ::std::option::Option<
        unsafe extern "C" fn(
            inCallbackFunc: SegmentInfoCallback,
            inCallbackData: *mut ::std::os::raw::c_void,
            inSegmentsID: csSDK_int32,
            inTimeBase: PrTime,
            inPixelFormat: PrPixelFormat,
        ) -> prSuiteError,
    >,
    pub BuildAncillaryDataSegmentMap: ::std::option::Option<
        unsafe extern "C" fn(
            inCallbackFunc: SegmentInfoCallback,
            inCallbackData: *mut ::std::os::raw::c_void,
            inVideoSegmentsID: csSDK_int32,
            inTimeBase: PrTime,
            inPixelFormat: PrPixelFormat,
        ) -> prSuiteError,
    >,
    pub BuildColorManagedSmartRenderSegmentList: ::std::option::Option<
        unsafe extern "C" fn(
            inCallbackFunc: SegmentInfoCallback,
            inCallbackData: *mut ::std::os::raw::c_void,
            inSegmentsID: csSDK_int32,
            inTimeBase: PrTime,
            inPixelFormat: PrPixelFormat,
            inColorSpaceID: PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
    pub BuildColorManagedSmartRenderSegmentListNoPreviewFiles: ::std::option::Option<
        unsafe extern "C" fn(
            inCallbackFunc: SegmentInfoCallback,
            inCallbackData: *mut ::std::os::raw::c_void,
            inSegmentsID: csSDK_int32,
            inTimeBase: PrTime,
            inPixelFormat: PrPixelFormat,
            inColorSpaceID: PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKStringSuite {
    #[doc = "\tThis will dispose of an SDKString. It is OK to pass in an empty string.\n\n\t@param\tinSDKString\t\t\t\tthe string to dispose of\n\n\t@return suiteError_StringNotFound\tthis string has not been allocated, or may have already been disposed\n\t@return suiteError_InvalidParms\t\tone of the params is invalid"]
    pub DisposeString: ::std::option::Option<
        unsafe extern "C" fn(inSDKString: *const PrSDKString) -> prSuiteError,
    >,
    #[doc = "\tThis will allocate an SDKString from a passed in null terminated string.\n\n\t@param\tinUTF8String\t\t\tnull terminated UTF8 string to copy into the SDK string\n\t@param\tioSDKString\t\t\t\tthis passed in SDK string will receive the new allocated string\n\t\t\t\t\t\t\t\t\t\t- you must dispose of this sdk string\n\n\t@return suiteError_StringNotFound\tthis string has not been allocated, or may have already been disposed\n\t@return suiteError_InvalidParms\t\tone of the params is invalid"]
    pub AllocateFromUTF8: ::std::option::Option<
        unsafe extern "C" fn(
            inUTF8String: *const prUTF8Char,
            outSDKString: *mut PrSDKString,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will copy an SDKString into a UTF8 null terminated string if ioUTF8StringBufferByteCount reports enough bytes in\n\t\tthe string buffer to copy. If there are not enough bytes - suiteError_StringBufferTooSmall will be returned\n\t\tand ioUTF8StringBufferByteCount will contain the number of bytes needed to hold the string.\n\n\t@param\toutUTF8StringBuffer\t\t\t\t\tBuffer where UTF8 string will be stored\n\t@param\tioUTF8StringBufferSizeInElements\tPass in the size, in elements, of outUTF8StringStorage. Returns the number of elements copied.  Includes terminating 0.\n\n\t@return suiteError_InvalidParms\t\t\tOne of the params is invalid\n\t@return suiteError_StringBufferTooSmall\tThe passed in string buffer is too small. ioUTF8StringBufferByteCount will contain the number of bytes needed to copy this string.\n\t@return suiteError_NoError\t\t\t\tThe string has been copied. ioUTF8StringBufferByteCount contains the number of bytes copied."]
    pub CopyToUTF8String: ::std::option::Option<
        unsafe extern "C" fn(
            inSDKString: *const PrSDKString,
            outUTF8StringBuffer: *mut prUTF8Char,
            ioUTF8StringBufferSizeInElements: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will allocate an SDKString from a passed in null terminated string.\n\n\t@param\tinUTF16String\t\t\tnull terminated UTF16 string to copy into the SDK string\n\t@param\tioSDKString\t\t\t\tthis passed in SDK string will receive the new allocated string\n\t\t\t\t\t\t\t\t\t\t- you must dispose of this sdk string\n\n\t@return suiteError_StringNotFound\tthis string has not been allocated, or may have already been disposed\n\t@return suiteError_InvalidParms\t\tone of the params is invalid"]
    pub AllocateFromUTF16: ::std::option::Option<
        unsafe extern "C" fn(
            inUTF16String: *const prUTF16Char,
            outSDKString: *mut PrSDKString,
        ) -> prSuiteError,
    >,
    #[doc = "\tThis will copy an SDKString into a UTF16 null terminated string if ioUTF16StringBufferByteCount reports enough bytes in\n\t\tthe string buffer to copy. If there are not enough bytes - suiteError_StringBufferTooSmall will be returned\n\t\tand ioUTF16StringBufferByteCount will contain the number of bytes needed to hold the string.\n\n\t@param\toutUTF16StringBuffer\t\t\t\tBuffer where UTF16 string will be stored\n\t@param\tioUTF16StringBufferSizeInElements\tPass in the size, in elements, of outUTF16StringStorage. Returns the number of elements copied.  Includes terminating 0.\n\n\t@return suiteError_InvalidParms\t\t\tOne of the params is invalid\n\t@return suiteError_StringBufferTooSmall\tThe passed in string buffer is too small. ioUTF16StringBufferByteCount will contain the number of bytes needed to copy this string.\n\t@return suiteError_NoError\t\t\t\tThe string has been copied. ioUTF16StringBufferByteCount contains the number of bytes copied."]
    pub CopyToUTF16String: ::std::option::Option<
        unsafe extern "C" fn(
            inSDKString: *const PrSDKString,
            outUTF16StringBuffer: *mut prUTF16Char,
            ioUTF16StringBufferSizeInElements: *mut csSDK_uint32,
        ) -> prSuiteError,
    >,
}
pub type ThreadedWorkCallback =
    ::std::option::Option<unsafe extern "C" fn(inInstanceData: *mut ::std::os::raw::c_void)>;
pub type ThreadedWorkCallbackVersion3 = ::std::option::Option<
    unsafe extern "C" fn(
        inInstanceData: *mut ::std::os::raw::c_void,
        inPluginID: csSDK_int32,
        inStatus: prSuiteError,
    ),
>;
pub type ThreadedWorkRegistration = *mut ::std::os::raw::c_void;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKThreadedWorkSuiteVersion2 {
    pub RegisterForThreadedWork: ::std::option::Option<
        unsafe extern "C" fn(
            inCallback: ThreadedWorkCallback,
            inInstanceData: *mut ::std::os::raw::c_void,
            outRegistrationData: *mut ThreadedWorkRegistration,
        ) -> prSuiteError,
    >,
    pub QueueThreadedWork: ::std::option::Option<
        unsafe extern "C" fn(inRegistrationData: ThreadedWorkRegistration) -> prSuiteError,
    >,
    pub UnregisterForThreadedWork: ::std::option::Option<
        unsafe extern "C" fn(inRegistrationData: ThreadedWorkRegistration) -> prSuiteError,
    >,
    pub RegisterForSingleThreadedWork: ::std::option::Option<
        unsafe extern "C" fn(
            inCallback: ThreadedWorkCallback,
            inInstanceData: *mut ::std::os::raw::c_void,
            outRegistrationData: *mut ThreadedWorkRegistration,
        ) -> prSuiteError,
    >,
}
#[doc = "\tThe following typedef is provided for short-term backwards compatibility only.\n\tClients should prefer the explicit versioned struct name."]
pub type PrSDKThreadedWorkSuite = PrSDKThreadedWorkSuiteVersion2;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKThreadedWorkSuiteVersion3 {
    pub RegisterForThreadedWork: ::std::option::Option<
        unsafe extern "C" fn(
            inCallback: ThreadedWorkCallbackVersion3,
            inInstanceData: *mut ::std::os::raw::c_void,
            outRegistrationData: *mut ThreadedWorkRegistration,
        ) -> prSuiteError,
    >,
    pub QueueThreadedWork: ::std::option::Option<
        unsafe extern "C" fn(
            inRegistrationData: ThreadedWorkRegistration,
            inPluginID: csSDK_int32,
        ) -> prSuiteError,
    >,
    pub UnregisterForThreadedWork: ::std::option::Option<
        unsafe extern "C" fn(inRegistrationData: ThreadedWorkRegistration) -> prSuiteError,
    >,
    pub RegisterForSingleThreadedWork: ::std::option::Option<
        unsafe extern "C" fn(
            inCallback: ThreadedWorkCallbackVersion3,
            inInstanceData: *mut ::std::os::raw::c_void,
            outRegistrationData: *mut ThreadedWorkRegistration,
        ) -> prSuiteError,
    >,
}
pub const PrNodeInfoFlag_kPrNodeInfoFlag_IsCompletelyOpaque: PrNodeInfoFlag = 1;
pub const PrNodeInfoFlag_kPrNodeInfoFlag_IsCompletelyTransparent: PrNodeInfoFlag = 2;
pub const PrNodeInfoFlag_kPrNodeInfoFlag_DoesNotDependOnSequenceTime: PrNodeInfoFlag = 4;
pub const PrNodeInfoFlag_kPrNodeInfoFlag_NodeDoesNotDependOnSegmentTime: PrNodeInfoFlag = 8;
pub const PrNodeInfoFlag_kPrNodeInfoFlag_NodeDoesNotDependOnClipInOutTime: PrNodeInfoFlag = 16;
pub const PrNodeInfoFlag_kPrNodeInfoFlag_IsNOP: PrNodeInfoFlag = 32;
pub const PrNodeInfoFlag_kPrNodeInfoFlag_NodeDoesNotDependOnTrackInputs: PrNodeInfoFlag = 64;
pub const PrNodeInfoFlag_kPrNodeInfoFlag_IsAdjustment: PrNodeInfoFlag = 128;
pub const PrNodeInfoFlag_kPrNodeInfoFlag_MaxSize: PrNodeInfoFlag = -1;
pub type PrNodeInfoFlag = ::std::os::raw::c_int;
pub const kMaxNodeTypeStringSize: ::std::os::raw::c_int = 256;
pub const PrKeyframeInterpolationModeFlag_kPrInterpolationModeFlag_Linear:
    PrKeyframeInterpolationModeFlag = 0;
pub const PrKeyframeInterpolationModeFlag_kPrInterpolationModeFlag_Hold:
    PrKeyframeInterpolationModeFlag = 4;
pub const PrKeyframeInterpolationModeFlag_kPrInterpolationModeFlag_Bezier:
    PrKeyframeInterpolationModeFlag = 5;
pub const PrKeyframeInterpolationModeFlag_kPrInterpolationModeFlag_Time:
    PrKeyframeInterpolationModeFlag = 6;
pub const PrKeyframeInterpolationModeFlag_kPrInterpolationModeFlag_TimeTransitionStart:
    PrKeyframeInterpolationModeFlag = 7;
pub const PrKeyframeInterpolationModeFlag_kPrInterpolationModeFlag_TimeTransitionEnd:
    PrKeyframeInterpolationModeFlag = 8;
pub const PrKeyframeInterpolationModeFlag_kPrInterpolationModeFlag_MaxSize:
    PrKeyframeInterpolationModeFlag = -1;
pub type PrKeyframeInterpolationModeFlag = ::std::os::raw::c_int;
pub const PrNodeScalePolicy_kPrNodeScalePolicy_None: PrNodeScalePolicy = 0;
pub const PrNodeScalePolicy_kPrNodeScalePolicy_ScaleToFrame: PrNodeScalePolicy = 1;
pub const PrNodeScalePolicy_kPrNodeScalePolicy_ScaleToFillCrop: PrNodeScalePolicy = 2;
pub const PrNodeScalePolicy_kPrNodeScalePolicy_ScaleToFillDistort: PrNodeScalePolicy = 3;
pub type PrNodeScalePolicy = ::std::os::raw::c_int;
#[doc = "\tThis callback function is used by the property query methods. Iteration can be cancelled at\n\tany time by returning a result other than malNoError.\n\n\t@param\tinPluginObject\t\t\tA value (such as \"this\") passed by the plugin in the original call\n\t\t\t\t\t\t\t\t\tand passed back in the callback. May be NULL.\n\t@param\tinKey\t\t\t\t\tThe key for the property\n\t@param\tinValue\t\t\t\t\tThe value for the property"]
pub type SegmentNodePropertyCallback = ::std::option::Option<
    unsafe extern "C" fn(
        inPluginObject: csSDK_int32,
        inKey: *const ::std::os::raw::c_char,
        inValue: *const prUTF8Char,
    ) -> prSuiteError,
>;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKVideoSegmentSuite {
    #[doc = "\tFrom a sequence, get an ID to its video segments ID. This is a ref-counted\n\tobject, and must be released when no longer needed.\n\n\t@param\tinTimelineID\t\tThe plugin timeline ID for the sequence\n\t@param\toutVideoSegmentsID\tReceives the ID for the Video Segments"]
    pub AcquireVideoSegmentsID: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineData: PrTimelineID,
            outVideoSegmentsID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tFrom a sequence, get an ID to its video segments ID with preview files substituted. This is a ref-counted\n\tobject, and must be released when no longer needed.\n\n\t@param\tinTimelineID\t\tThe plugin timeline ID for the sequence\n\t@param\toutVideoSegmentsID\tReceives the ID for the Video Segments with Previews."]
    pub AcquireVideoSegmentsWithPreviewsID: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineData: PrTimelineID,
            outVideoSegmentsID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tFrom a sequence, get an ID to its video segments ID with preview files substituted, but only previews\n\tfor sections that are opaque. This is appropriate for use when using previews for nested sequences. This is a ref-counted\n\tobject, and must be released when no longer needed.\n\n\t@param\tinTimelineID\t\tThe plugin timeline ID for the sequence\n\t@param\toutVideoSegmentsID\tRecevies the ID for the Video Segments with Previews."]
    pub AcquireVideoSegmentsWithOpaquePreviewsID: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineData: PrTimelineID,
            outVideoSegmentsID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tRelease a Video Segments ID\n\n\t@param\tinVideoSegmentsID\tThe Video Segments ID to release"]
    pub ReleaseVideoSegmentsID:
        ::std::option::Option<unsafe extern "C" fn(inVideoSegmentsID: csSDK_int32) -> prSuiteError>,
    #[doc = "\tGet the hash of a Video Segments object\n\n\t@param\tinVideoSegmentsID\tThe Video Segments ID\n\t@param\toutHash\t\t\t\tThe GUID hash of the segments"]
    pub GetHash: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoSegmentsID: csSDK_int32,
            outHash: *mut prPluginID,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the number of segments in the segments object\n\n\t@param\tinVideoSegmentsID\tThe Video Segments ID\n\t@param\toutNumSegments\t\tThe number of segments"]
    pub GetSegmentCount: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoSegmentsID: csSDK_int32,
            outNumSegments: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the details of the Nth Node.\n\n\t@param\tinVideoSegmentsID\tThe Video Segments ID\n\t@param\tinIndex\t\t\t\tWhich segment?\n\t@param\toutStartTime\t\tThe start time of the segment\n\t@param\toutEndTime\t\t\tThe end time of the segment\n\t@param\toutSegmentOffset\tThe offset value for the segment\n\t@param\toutHash\t\t\t\tThe hash for the segment"]
    pub GetSegmentInfo: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoSegmentsID: csSDK_int32,
            inIndex: csSDK_int32,
            outStartTime: *mut PrTime,
            outEndTime: *mut PrTime,
            outSegmentOffset: *mut PrTime,
            outHash: *mut prPluginID,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet a segment node. This object is ref-counted and must be released.\n\n\t@param\tinVideoSegmentsID\tThe Video Segments ID\n\t@param\tinHash\t\t\t\tThe hash for the segment\n\t@param\toutVideoNodeID\t\tThe video node ID."]
    pub AcquireNodeID: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoSegmentsID: csSDK_int32,
            inHash: *mut prPluginID,
            outVideoNodeID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tRelease a Video Node ID\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID to release"]
    pub ReleaseVideoNodeID:
        ::std::option::Option<unsafe extern "C" fn(inVideoNodeID: csSDK_int32) -> prSuiteError>,
    #[doc = "\tGet details about a node.\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\toutNodeType\t\t\tA string of size kMaxNodeTypeStringSize holding the node type\n\t@param\toutHash\t\t\t\tThe hash for the node (may be different than the hash used to get the node)\n\t@param\toutInfoFlags\t\tThe flags for this node (see enum above)"]
    pub GetNodeInfo: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            outNodeType: *mut ::std::os::raw::c_char,
            outHash: *mut prPluginID,
            outFlags: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the number of inputs on the node object\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\toutNumInputs\t\tThe number of inputs"]
    pub GetNodeInputCount: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            outNumInputs: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet a segment node that is an input to another node. This object is ref-counted and must be released.\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\tinIndex\t\t\t\tThe index of the input\n\t@param\toutOffset\t\t\tThe time offset relative to it's parent node\n\t@param\toutInputVideoNodeID\tThe video node ID of the input node."]
    pub AcquireInputNodeID: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            inIndex: csSDK_int32,
            outOffset: *mut PrTime,
            outInputVideoNodeID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the number of inputs on the node object\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\toutNumOperators\t\tThe number of operators"]
    pub GetNodeOperatorCount: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            outNumOperators: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet a segment node that is an operator on another node. This object is ref-counted and must be released.\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\tinIndex\t\t\t\tThe index of the operator\n\t@param\toutOperatorVideoNodeID\tThe video node ID of the input node."]
    pub AcquireOperatorNodeID: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            inIndex: csSDK_int32,
            outOperatorVideoNodeID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tIterate all of the properties on a node.\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\tinCallback\t\t\tThe callback function to return the properties\n\t@param\tinPluginObject\t\tThe plugin object returned in the callback."]
    pub IterateNodeProperties: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            inCallback: SegmentNodePropertyCallback,
            inPluginObject: csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the value of a single property on a node\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\tinKey\t\t\t\tThe key of the property\n\t@param\toutValue\t\t\tA string holding the value. This UTF8 string is allocated using PrNewPtr,\n\t\t\t\t\t\t\t\tand ownership is transferred to the plugin and must be disposed\n\t\t\t\t\t\t\t\tby the plugin."]
    pub GetNodeProperty: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            inKey: *const ::std::os::raw::c_char,
            outValue: *mut PrMemoryPtr,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the number of params\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\toutParamCount\t\tThe number of params"]
    pub GetParamCount: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            outParamCount: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet a specific param value at a specific time\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\tinIndex\t\t\t\tThe index of the param\n\t@param\tinTime\t\t\t\tThe time requested (in Media time)\n\t@param\toutParam\t\t\tThe param"]
    pub GetParam: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            inIndex: csSDK_int32,
            inTime: PrTime,
            outParam: *mut PrParam,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet the next keyframe time after the specified time.\n\n\tExample: Keyframes at 0 and 10\n\tinTime = -1, outKeyframeTime = 0\n\tinTime = 0, outKeyframeTime = 10\n\tinTime = 9, outKeyframeTime = 10\n\tinTime = 10, returns suiteError_NoKeyframeAfterInTime\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\tinIndex\t\t\t\tThe index of the param\n\t@param\tinTime\t\t\t\tThe lower bound time\n\t@param\toutKeyframeTime\t\tThe time of the next keyframe > inTime\n\t@param\toutKeyframeInterpolationMode\tThe temporal interpolation mode of the keyframe, see\n\t\t\t\t\t\t\t\t\t\t\tthe enum for PrKeyframeInterpolationModeFlag above"]
    pub GetNextKeyframeTime: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            inIndex: csSDK_int32,
            inTime: PrTime,
            outKeyframeTime: *mut PrTime,
            outKeyframeInterpolationMode: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tTransform a node local time into a time appropriate for node inputs and\n\toperators. When used on the clip node, for instance, this will take into\n\taccount speed change, reverse, time remapping and return a time value\n\twhich can be used in the Media and Effect nodes.\n\tIf the node does not have a time transform, function will not fail but\n\twill return in input time in the output."]
    pub TransformNodeTime: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            inTime: PrTime,
            outTime: *mut PrTime,
        ) -> prSuiteError,
    >,
    #[doc = "\tRetrieve general properties of a sequence (video segments). I.e. width/height, par and framerate.\n\n\t@param\tinTimelineID\t\t\t\t\tThe plugin timeline ID for the sequence\n\t@param\toutWidth\t\t\t\t\t\tReceives width of the sequence\n\t@param\toutHeight\t\t\t\t\t\tReceives height of the sequence\n\t@param\toutPixelAspectRatioNumerator\tReceives the pixel aspect ratio numerator of the sequence\n\t@param\toutPixelAspectRatioDenominator\tReceives the pixel aspect ratio denominator of the sequence\n\t@param\toutFrameRateNumerator\t\t\tReceives the frame rate numerator of the sequence\n\t@param\toutFrameRateDenominator\t\t\tReceives the frame rate denominator of the sequence"]
    pub GetVideoSegmentsProperties: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineData: PrTimelineID,
            outBounds: *mut prRect,
            outPixelAspectRatioNumerator: *mut csSDK_int32,
            outPixelAspectRatioDenominator: *mut csSDK_int32,
            outFrameRate: *mut PrTime,
            outFieldType: *mut prFieldType,
        ) -> prSuiteError,
    >,
    #[doc = "\tFrom a sequence, get a segment node for a requested time. This is a ref-counted\n\tobject, and must be released when no longer needed.\n\n\t@param\tinVideoSegmentsID\tThe Video Segments ID\n\t@param\tinTime\t\t\t\tRequested segment time\n\t@param\toutVideoNodeID\t\tThe video node ID\n\t@param\toutSegmentOffset\tOffset of retrieved segment"]
    pub AcquireNodeForTime: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoSegmentsID: csSDK_int32,
            inTime: PrTime,
            outVideoNodeID: *mut csSDK_int32,
            outSegmentOffset: *mut PrTime,
        ) -> prSuiteError,
    >,
    #[doc = "\tFrom a sequence, get an ID to its video segments ID. This is a ref-counted\n\tobject, and must be released when no longer needed.\n\n\t@param\tinTimelineID\t\tThe plugin timeline ID for the sequence\n\t@param\toutVideoSegmentsID\tReceives the ID for the Video Segments"]
    pub AcquireVideoSegmentsIDWithStreamLabel: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineData: PrTimelineID,
            inStreamLabel: PrSDKStreamLabel,
            outVideoSegmentsID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tFrom a sequence, get an ID to its video segments ID with preview files substituted. This is a ref-counted\n\tobject, and must be released when no longer needed.\n\n\t@param\tinTimelineID\t\tThe plugin timeline ID for the sequence\n\t@param\toutVideoSegmentsID\tReceives the ID for the Video Segments with Previews."]
    pub AcquireVideoSegmentsWithPreviewsIDWithStreamLabel: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineData: PrTimelineID,
            inStreamLabel: PrSDKStreamLabel,
            outVideoSegmentsID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tFrom a sequence, get an ID to its video segments ID with preview files substituted, but only previews\n\tfor sections that are opaque. This is appropriate for use when using previews for nested sequences. This is a ref-counted\n\tobject, and must be released when no longer needed.\n\n\t@param\tinTimelineID\t\tThe plugin timeline ID for the sequence\n\t@param\toutVideoSegmentsID\tRecevies the ID for the Video Segments with Previews."]
    pub AcquireVideoSegmentsWithOpaquePreviewsIDWithStreamLabel: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineData: PrTimelineID,
            inStreamLabel: PrSDKStreamLabel,
            outVideoSegmentsID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tFrom a sequence, get the first segment node that intersects with a range of times.\n  This is a ref-counted object, and must be released when no longer needed.\n\n\t@param\tinVideoSegmentsID\tThe Video Segments ID\n\t@param\tinStartTime\t\t\tThe start of the requested segment time range\n\t@param\tinEndTime\t\t\tThe end of the requested segment time range\n\t@param\toutVideoNodeID\t\tThe video node ID\n\t@param\toutSegmentOffset\tOffset of retrieved segment"]
    pub AcquireFirstNodeInTimeRange: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoSegmentsID: csSDK_int32,
            inStartTime: PrTime,
            inEndTime: PrTime,
            outVideoNodeID: *mut csSDK_int32,
            outSegmentOffset: *mut PrTime,
        ) -> prSuiteError,
    >,
    #[doc = "\tAcquire the node owning an operator\n\n\t@param\tinVideoNodeID\t\tThe operator\n\t@param\toutOwnerNodeID\t\tThe owner"]
    pub AcquireOperatorOwnerNodeID: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            outOwnerNodeID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet graphic layer params at a specific time\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\tinTime\t\t\t\tThe time requested (in Media time)"]
    pub GetGraphicsTransformedParams: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            inTime: PrTime,
            outPosition: *mut prFPoint64,
            outAnchor: *mut prFPoint64,
            outScale: *mut prFPoint64,
            outRotation: *mut f32,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet graphic layer group ID\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID"]
    pub HasGraphicsGroup: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            outHasGraphicGroup: *mut bool,
        ) -> prSuiteError,
    >,
    #[doc = "\tGet graphic layer group ID\n\n\t@param\tinVideoNodeID\t\tThe Video Node ID"]
    pub GetGraphicsGroupID: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            outGroupID: *mut csSDK_int32,
        ) -> prSuiteError,
    >,
    #[doc = " Color managed version of GetVideoSegmentsProperties\n\tRetrieve general properties of a sequence (video segments). I.e. width/height, par and framerate\n and color space\n\n\t@param\tinTimelineID\t\t\t\t\tThe plugin timeline ID for the sequence\n\t@param\toutWidth\t\t\t\t\t\tReceives width of the sequence\n\t@param\toutHeight\t\t\t\t\t\tReceives height of the sequence\n\t@param\toutPixelAspectRatioNumerator\tReceives the pixel aspect ratio numerator of the sequence\n\t@param\toutPixelAspectRatioDenominator\tReceives the pixel aspect ratio denominator of the sequence\n\t@param\toutFrameRateNumerator\t\t\tReceives the frame rate numerator of the sequence\n\t@param\toutFrameRateDenominator\t\t\tReceives the frame rate denominator of the sequence\n @param\toutColorSpaceID\t\t\t\t\tReceives the opaque ID of the sequence's working color space"]
    pub GetVideoSegmentsPropertiesExt: ::std::option::Option<
        unsafe extern "C" fn(
            inTimelineData: PrTimelineID,
            outBounds: *mut prRect,
            outPixelAspectRatioNumerator: *mut csSDK_int32,
            outPixelAspectRatioDenominator: *mut csSDK_int32,
            outFrameRate: *mut PrTime,
            outFieldType: *mut prFieldType,
            outColorSpaceID: *mut PrSDKColorSpaceID,
        ) -> prSuiteError,
    >,
    #[doc = "\tFrom a sequence, get the first segment node that intersects with a range of times.\n  This is a ref-counted object, and must be released when no longer needed.\n\n\t@param\tinVideoSegmentsID\tThe Video Segments ID\n\t@param\tinStartTime\t\t\tThe start of the requested segment time range\n\t@param\tinEndTime\t\t\tThe end of the requested segment time range\n\t@param\toutVideoNodeID\t\tThe video node ID\n\t@param\toutSegmentStartTime\tStart time of retrieved segment\n\t@param\toutSegmentEndTime\tEnd time of retrieved segment\n\t@param\toutSegmentOffset\tOffset of retrieved segment"]
    pub AcquireFirstNodeInTimeRangeExt: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoSegmentsID: csSDK_int32,
            inStartTime: PrTime,
            inEndTime: PrTime,
            outVideoNodeID: *mut csSDK_int32,
            outSegmentStartTime: *mut PrTime,
            outSegmentEndTime: *mut PrTime,
            outSegmentOffset: *mut PrTime,
        ) -> prSuiteError,
    >,
    #[doc = "\tReturns the relative time rate of a node at a given point in time.\n  Node time rate varies with e.g. time remapping but not the playback speed of the sequence\n  Can be thought of as the instantaneous rate of change of TransformNodeTime()\n\t@param\tinVideoNodeID\t\tThe Video Node ID\n\t@param\tinTime\t\t\t\tThe time requested (in Media time - untransformed)\n\t@param\toutRate\t\t\t\tThe node rate relative to the containing sequence"]
    pub GetNodeTimeScale: ::std::option::Option<
        unsafe extern "C" fn(
            inVideoNodeID: csSDK_int32,
            inTime: PrTime,
            outRate: *mut f64,
        ) -> prSuiteError,
    >,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKWindowSuite {
    pub GetMainWindow: ::std::option::Option<unsafe extern "C" fn() -> prWnd>,
    pub UpdateAllWindows: ::std::option::Option<unsafe extern "C" fn()>,
}
pub type A_long = i32;
pub type A_u_long = u32;
pub type A_char = ::std::os::raw::c_char;
pub type A_FpLong = f64;
pub type A_FpShort = f32;
pub type A_short = ::std::os::raw::c_short;
pub type A_u_short = ::std::os::raw::c_ushort;
pub type A_u_char = ::std::os::raw::c_uchar;
pub type A_Boolean = ::std::os::raw::c_uchar;
pub type A_intptr_t = ::std::os::raw::c_longlong;
pub type A_u_longlong = ::std::os::raw::c_ulonglong;
pub const PF_Stage_DEVELOP: _bindgen_ty_18 = 0;
pub const PF_Stage_ALPHA: _bindgen_ty_18 = 1;
pub const PF_Stage_BETA: _bindgen_ty_18 = 2;
pub const PF_Stage_RELEASE: _bindgen_ty_18 = 3;
pub type _bindgen_ty_18 = ::std::os::raw::c_int;
pub type PF_Stage = A_long;
pub const PF_Quality_DRAWING_AUDIO: _bindgen_ty_19 = -1;
pub const PF_Quality_LO: _bindgen_ty_19 = 0;
pub const PF_Quality_HI: _bindgen_ty_19 = 1;
pub type _bindgen_ty_19 = ::std::os::raw::c_int;
pub type PF_Quality = A_long;
pub const PF_MF_Alpha_PREMUL: _bindgen_ty_20 = 0;
pub const PF_MF_Alpha_STRAIGHT: _bindgen_ty_20 = 1;
pub type _bindgen_ty_20 = ::std::os::raw::c_int;
pub type PF_ModeFlags = A_long;
pub const PF_Field_FRAME: _bindgen_ty_21 = 0;
pub const PF_Field_UPPER: _bindgen_ty_21 = 1;
pub const PF_Field_LOWER: _bindgen_ty_21 = 2;
pub type _bindgen_ty_21 = ::std::os::raw::c_int;
pub type PF_Field = A_long;
pub const PF_Param_RESERVED: _bindgen_ty_22 = -1;
pub const PF_Param_LAYER: _bindgen_ty_22 = 0;
pub const PF_Param_SLIDER: _bindgen_ty_22 = 1;
pub const PF_Param_FIX_SLIDER: _bindgen_ty_22 = 2;
pub const PF_Param_ANGLE: _bindgen_ty_22 = 3;
pub const PF_Param_CHECKBOX: _bindgen_ty_22 = 4;
pub const PF_Param_COLOR: _bindgen_ty_22 = 5;
pub const PF_Param_POINT: _bindgen_ty_22 = 6;
pub const PF_Param_POPUP: _bindgen_ty_22 = 7;
pub const PF_Param_CUSTOM: _bindgen_ty_22 = 8;
pub const PF_Param_NO_DATA: _bindgen_ty_22 = 9;
pub const PF_Param_FLOAT_SLIDER: _bindgen_ty_22 = 10;
pub const PF_Param_ARBITRARY_DATA: _bindgen_ty_22 = 11;
pub const PF_Param_PATH: _bindgen_ty_22 = 12;
pub const PF_Param_GROUP_START: _bindgen_ty_22 = 13;
pub const PF_Param_GROUP_END: _bindgen_ty_22 = 14;
pub const PF_Param_BUTTON: _bindgen_ty_22 = 15;
pub const PF_Param_RESERVED2: _bindgen_ty_22 = 16;
pub const PF_Param_RESERVED3: _bindgen_ty_22 = 17;
pub const PF_Param_POINT_3D: _bindgen_ty_22 = 18;
pub type _bindgen_ty_22 = ::std::os::raw::c_int;
pub type PF_ParamType = A_long;
pub const PF_ParamFlag_RESERVED1: _bindgen_ty_23 = 1;
pub const PF_ParamFlag_CANNOT_TIME_VARY: _bindgen_ty_23 = 2;
pub const PF_ParamFlag_CANNOT_INTERP: _bindgen_ty_23 = 4;
pub const PF_ParamFlag_RESERVED2: _bindgen_ty_23 = 8;
pub const PF_ParamFlag_RESERVED3: _bindgen_ty_23 = 16;
pub const PF_ParamFlag_COLLAPSE_TWIRLY: _bindgen_ty_23 = 32;
pub const PF_ParamFlag_SUPERVISE: _bindgen_ty_23 = 64;
pub const PF_ParamFlag_START_COLLAPSED: _bindgen_ty_23 = 32;
pub const PF_ParamFlag_USE_VALUE_FOR_OLD_PROJECTS: _bindgen_ty_23 = 128;
pub const PF_ParamFlag_LAYER_PARAM_IS_TRACKMATTE: _bindgen_ty_23 = 128;
pub const PF_ParamFlag_EXCLUDE_FROM_HAVE_INPUTS_CHANGED: _bindgen_ty_23 = 256;
pub const PF_ParamFlag_SKIP_REVEAL_WHEN_UNHIDDEN: _bindgen_ty_23 = 512;
pub type _bindgen_ty_23 = ::std::os::raw::c_int;
pub type PF_ParamFlags = A_long;
pub const PF_Err_NONE: _bindgen_ty_24 = 0;
pub const PF_Err_OUT_OF_MEMORY: _bindgen_ty_24 = 4;
pub const PF_Err_INTERNAL_STRUCT_DAMAGED: _bindgen_ty_24 = 512;
pub const PF_Err_INVALID_INDEX: _bindgen_ty_24 = 513;
pub const PF_Err_UNRECOGNIZED_PARAM_TYPE: _bindgen_ty_24 = 514;
pub const PF_Err_INVALID_CALLBACK: _bindgen_ty_24 = 515;
pub const PF_Err_BAD_CALLBACK_PARAM: _bindgen_ty_24 = 516;
pub const PF_Interrupt_CANCEL: _bindgen_ty_24 = 517;
pub const PF_Err_CANNOT_PARSE_KEYFRAME_TEXT: _bindgen_ty_24 = 518;
pub type _bindgen_ty_24 = ::std::os::raw::c_int;
pub type PF_Err = A_long;
pub const PF_WorldFlag_DEEP: _bindgen_ty_25 = 1;
pub const PF_WorldFlag_WRITEABLE: _bindgen_ty_25 = 2;
pub const PF_WorldFlag_RESERVED0: _bindgen_ty_25 = 16777216;
pub const PF_WorldFlag_RESERVED1: _bindgen_ty_25 = 33554432;
pub const PF_WorldFlag_RESERVED2: _bindgen_ty_25 = 67108864;
pub const PF_WorldFlag_RESERVED3: _bindgen_ty_25 = 134217728;
pub const PF_WorldFlag_RESERVED4: _bindgen_ty_25 = 268435456;
pub const PF_WorldFlag_RESERVED5: _bindgen_ty_25 = 536870912;
pub const PF_WorldFlag_RESERVED6: _bindgen_ty_25 = 1073741824;
pub const PF_WorldFlag_RESERVED: _bindgen_ty_25 = -2147483648;
pub type _bindgen_ty_25 = ::std::os::raw::c_int;
pub type PF_WorldFlags = A_long;
pub const PF_OutFlag_NONE: _bindgen_ty_26 = 0;
pub const PF_OutFlag_KEEP_RESOURCE_OPEN: _bindgen_ty_26 = 1;
pub const PF_OutFlag_WIDE_TIME_INPUT: _bindgen_ty_26 = 2;
pub const PF_OutFlag_NON_PARAM_VARY: _bindgen_ty_26 = 4;
pub const PF_OutFlag_RESERVED6: _bindgen_ty_26 = 8;
pub const PF_OutFlag_SEQUENCE_DATA_NEEDS_FLATTENING: _bindgen_ty_26 = 16;
pub const PF_OutFlag_I_DO_DIALOG: _bindgen_ty_26 = 32;
pub const PF_OutFlag_USE_OUTPUT_EXTENT: _bindgen_ty_26 = 64;
pub const PF_OutFlag_SEND_DO_DIALOG: _bindgen_ty_26 = 128;
pub const PF_OutFlag_DISPLAY_ERROR_MESSAGE: _bindgen_ty_26 = 256;
pub const PF_OutFlag_I_EXPAND_BUFFER: _bindgen_ty_26 = 512;
pub const PF_OutFlag_PIX_INDEPENDENT: _bindgen_ty_26 = 1024;
pub const PF_OutFlag_I_WRITE_INPUT_BUFFER: _bindgen_ty_26 = 2048;
pub const PF_OutFlag_I_SHRINK_BUFFER: _bindgen_ty_26 = 4096;
pub const PF_OutFlag_WORKS_IN_PLACE: _bindgen_ty_26 = 8192;
pub const PF_OutFlag_RESERVED8: _bindgen_ty_26 = 16384;
pub const PF_OutFlag_CUSTOM_UI: _bindgen_ty_26 = 32768;
pub const PF_OutFlag_RESERVED7: _bindgen_ty_26 = 65536;
pub const PF_OutFlag_REFRESH_UI: _bindgen_ty_26 = 131072;
pub const PF_OutFlag_NOP_RENDER: _bindgen_ty_26 = 262144;
pub const PF_OutFlag_I_USE_SHUTTER_ANGLE: _bindgen_ty_26 = 524288;
pub const PF_OutFlag_I_USE_AUDIO: _bindgen_ty_26 = 1048576;
pub const PF_OutFlag_I_AM_OBSOLETE: _bindgen_ty_26 = 2097152;
pub const PF_OutFlag_FORCE_RERENDER: _bindgen_ty_26 = 4194304;
pub const PF_OutFlag_PiPL_OVERRIDES_OUTDATA_OUTFLAGS: _bindgen_ty_26 = 8388608;
pub const PF_OutFlag_I_HAVE_EXTERNAL_DEPENDENCIES: _bindgen_ty_26 = 16777216;
pub const PF_OutFlag_DEEP_COLOR_AWARE: _bindgen_ty_26 = 33554432;
pub const PF_OutFlag_SEND_UPDATE_PARAMS_UI: _bindgen_ty_26 = 67108864;
pub const PF_OutFlag_AUDIO_FLOAT_ONLY: _bindgen_ty_26 = 134217728;
pub const PF_OutFlag_AUDIO_IIR: _bindgen_ty_26 = 268435456;
pub const PF_OutFlag_I_SYNTHESIZE_AUDIO: _bindgen_ty_26 = 536870912;
pub const PF_OutFlag_AUDIO_EFFECT_TOO: _bindgen_ty_26 = 1073741824;
pub const PF_OutFlag_AUDIO_EFFECT_ONLY: _bindgen_ty_26 = -2147483648;
#[doc = " -------------------- Output Flags --------------------\n\nThe out_flags field of the OutData can be set to an OR-ed\ncombination of these flags to communicate various things to\nthe driver program.  The flags are described here:\n\nPF_OutFlag_NONE\nThis is the \"empty\" setting -- no outflags.\n\nPF_OutFlag_WIDE_TIME_INPUT\nSet this flag if the effect calls get_param to inquire a\nparameter at a time besides the current one (e.g. to get\nthe previous video frame). This should be sent, if it is\ngoing to be sent, at PF_Cmd_GLOBAL_SETUP. Can be over-ridden\ndynamically during PF_Cmd_QUERY_DYNAMIC_FLAGS.\n\nAs of AE10, this flag is no longer recommended. It still works the\nsame way and is safe to set, but there's a more efficient option.\nSee PF_OutFlag2_AUTOMATIC_WIDE_TIME_INPUT.\n\nPF_OutFlag_NON_PARAM_VARY\nSet this if the effect uses information other than the parameters\nin the param list to generate its output at the current time.\nFor instance, if the effect uses the current time of the frame\nor some random value to decide the output, set this flag.  This\nflag should be sent at PF_Cmd_GLOBAL_SETUP.  If the effect\nproduces changing frames when applied to a still image and\nall parameters are constant, that's a sure sign that this bit\nshould be set (e.g. Wave Warp).\tCan be over-ridden dynamically\nduring PF_Cmd_QUERY_DYNAMIC_FLAGS.\n\nPF_OutFlag_SEQUENCE_DATA_NEEDS_FLATTENING\nWhen you allocate a sequence data handle, the app\nmay write the handle out to disk and reuse it\nlater. Pass this flag if the handle is not \"flat\"\n(i.e. has pointers or handles hanging off of it).\nBasically, this gives you a chance to alter the\nhandle contents before it is written out to disk,\nso  you won't get invalid handles or pointers. Once\nyou have flattened a handle, you will get an\nopportunity to un-flatten it before the effect\nneeds to continue. For sequence data, you will be\ninvoked with a PF_Cmd_SEQUENCE_RESETUP call. You\nshould store a boolean at a common  offset in your\nunflattened and flattened data that says whether\nthe data is flat or not. If you get a\nPF_Cmd_SEQUENCE_RESETUP and the boolean indicated\nthe data is flattened, you should  unflatten the\ndata, free the flattened data handle, and set the\nsequence_data handle in the  PF_OutData. If you\never set the data to NULL when you flatten it, you\nwill NOT get the sequence  resetup call to\nunflatten it. Instead, you may just get a RENDER\ncall with NULL data. Forewarned is  forearmed. This\nflag, indicating if the data will need to be\nflattened, should be set at  PF_Cmd_GLOBAL_SETUP time.\n\nPF_OutFlag_I_DO_DIALOG\nSet this is the effect responds to a PF_Cmd_DO_DIALOG, i.e. Does this\neffect bring up an options dialog box.  PF_Cmd_DO_DIALOG is generated\nwhen the user presses the Options button on the Effect floater.\nThis flag should be set at PF_Cmd_GLOBAL_SETUP time.\n\nPF_OutFlag_USE_OUTPUT_EXTENT\nThe output layer is passed with an \"extent rect\" indicating\nthe area of the layer that actually contains visible image data.  If\nthe effect changes its behavior based on the extent rect (for instance,\nby not iterating over the entire image), set this flag, so the\napplication will know whether having the extent\tchange should cause\nthe frame to re-render.  Specify this flag at PF_Cmd_GLOBAL_SETUP.\n\nPF_OutFlag_SEND_DO_DIALOG\nSome filters need their options dialog box to be brought up at least\nonce to be valid.  You can set this flag, and the driver app will\nautomatically send a PF_Cmd_DO_DIALOG to the effect when it is applied.\nThe DO_DIALOG will be sent after PF_Cmd_SEQUENCE_SETUP.  This flag\nshould be set in PF_Cmd_SEQUENCE_SETUP if it is going to be set.\n\nPF_OutFlag_DISPLAY_ERROR_MESSAGE\nWhenever the return_msg field in the PF_OutData is set to a string,\nAfter Effects will bring up a simple dialog box containing that\nstring.  If you set this flag, the dialog box will be made to look\nlike an error message dialog box.  If you don't set this flag, it\nwill be an undecorated dialog box.  Using this flag, an effects module\ncan have and display its own error messages and not worry about the\ncode for dialog boxes -- the program will do it for you.\nThis flag can be sent after any command.\n\nPF_OutFlag_I_EXPAND_BUFFER\nStarting with After Effects 2.0, effects will be able to expand their buffers\nbeyond the current layer's dimensions. This has always been part of the\nPF specification, but as an extra precaution (and hint to the AE rendering\nengine) set this flag at PF_Cmd_GLOBAL_SETUP if you plan to expand your\nbuffer.\n\nPF_OutFlag_I_SHRINK_BUFFER\nSet this flag if you can shrink your buffer based on the extent-rects passed\nto you in order to be more memory efficient.\n\nPF_OutFlag_PIX_INDEPENDENT\nSet this flag if the output at a given pixel is not dependent on the values\nof the pixels around it. If this is set, the pixels After Effects does not\ncare about (because of field rendering, for example) could be filled with garbage\ncolors.  Please set this flag at PF_Cmd_GLOBAL_SETUP. Can be over-ridden\ndynamically during PF_Cmd_QUERY_DYNAMIC_FLAGS.\n\nPF_OutFlag_I_WRITE_INPUT_BUFFER\nSet this flag if your effect would like to write into the input buffer. This\ncan be useful if you need an scratch buffer, but it also invalidates some speedups\nin the AE rendering pipeline, so use it with some discretion. Please set this\nflag at PF_Cmd_GLOBAL_SETUP.\n\nPF_OutFlag_KEEP_RESOURCE_OPEN\n\nObsoleted in AE 2015 (does nothing when set).\n\nSet this flag if your effect expects its Macintosh resource fork to be open\nat any time other than global setup.  Note that this does not mean that\nthe resource fork will be kept open at all times, just whenever the\neffect is being executed.\n\nPF_OutFlag_NOP_RENDER\n\nSet this flag in PF_Cmd_GLOBAL_SETUP if the render would never result in changes\nto the source image (or audio?). For example, an expression control would set this.\n\nPF_OutFlag_CUSTOM_UI\n\nThis flag must be set if your effect has a custom UI in the Effect Controls\nWindow, Layer Window or Comp Window.\n\nPF_OutFlag2_CUSTOM_UI_ASYNC_MANAGER\t(new in 13.5)\n\nThis flags enables use of AEGP_CheckoutOrRender_*_AsyncManager() calls\nwhich avoid the need for plugin management of the lifetime of async custom UI renders from the UI thread.\nThe plugin asks for what frames it needs and the manager calls PF_Event_DRAW again when they are available\n(or cancels them as needed automatically).  The plugin responds in PF_Event_DRAW by asking for what it needs\nand drawing what it can from what is available.\n\nDue to separation of Render thread and UI thread in 13.5, frames for custom UI should no longer be\nrendered synchronously (see RenderSuite5 for more details). The manager simplifies this, especially when\nthere are multiple requests needed for DRAW.\n\nWhen enabled, this flag associates a \"PF_AsyncManager\" with the NEW_CONTEXT/CLOSE_CONTEXT and PF_Event_DRAW\nthat will automatically track completion of 1 or more asynch render requests made for drawing custom UI.\nAs requests complete,  PF_Event_DRAW will be called again and the current state of the CUSTOM_UI can be drawn.\nSuch requests may be canceled automatically as the user scrubs the time needle or project changes are made and\nbecome invalid.\n\nThis flag is used in addition to the CUSTOM_UI flag during PF_Cmd_GLOBAL_SETUP\n\nPF_OutFlag_REFRESH_UI\n\nCan be returned from PF_Cmd_EVENT, PF_Cmd_RENDER, and PF_Cmd_DO_DIALOG.\nCauses the effects control window, layer window, and comp window to be re-drawn.\n\nPF_OutFlag_I_USE_SHUTTER_ANGLE\n\nMust be set at PF_Cmd_GLOBAL_SETUP time if the effect uses\nthe shutter_angle or the shutter_phase. Can be over-ridden dynamically during\nPF_Cmd_QUERY_DYNAMIC_FLAGS.\n\nPF_OutFlag_I_USE_AUDIO\n\nMust be set at PF_Cmd_GLOBAL_SETUP time for a visual effect\nthat calls the audio checkout calls.\n\nPF_OutFlag_I_AM_OBSOLETE\n\nSet at PF_Cmd_GLOBAL_SETUP time for effects that don't\nwant to appear in the AE Effects menu (but will still be invoked\nif you load a project that has an old copy of the effect applied).\n\nPF_OutFlag_FORCE_RERENDER\n\nSet at PF_Cmd_EVENT if the effect modified sequence data,\nor did anything else that requires the effect needs to re-render.\nNote that setting PF_ChangeFlag_CHANGED_VALUE automatically\ncauses a re-render, so don't worry about setting PF_OutFlag_FORCE_RERENDER\nin that case. Also, I_MIX_GUID_DEPENDENCIES can be used to trigger a rerender on\ndependant changes if sequence_data has not been changed.\n\nIMPORTANT: FORCE_RERENDER should be used as a last resort. Long term we should be eliminating the need for this\nbecause it causes forced cache invalidation that doesn't work well with undo.\nOnce we have the full set of APIs in place needed to manage render state, we will be able to deprecate this.\nPrefer using ARB data + CHANGED_VALUE or I_MIX_GUID_DEPENDENCIES when possible instead.\n\nIn 13.5 the split between a UI and render threads means that FORCE_RERENDER will now also have the needed\nside effect of copying sequence_data state to the render project.  This can be expensive if the sequence_data is large.\nSupport GET_FLATTENED_SEQUENCE_DATA to prevent deallocation of your sequence_data, which can help.\nGET_FLATTENED_SEQUENCE_DATA support is required for FORCE_RERENDER use in custom mouse/key events.\n\nPF_OutFlag_PiPL_OVERRIDES_OUTDATA_OUTFLAGS\n\nValid only for setting in your PiPL.  When set out_flags will be\nignored at PF_Cmd_GLOBAL_SETUP time (& thus don't need to match).\n\nPF_OutFlag_I_HAVE_EXTERNAL_DEPENDENCIES\n\nSet this flag at PF_Cmd_GLOBAL_SETUP time if the effect has dependencies\nthat the user should know about before transporting their project to a\ndifferent machine.  For example, dependencies on an installed font,\nor on an external file.  If set, the effect will receive a\nPF_Cmd_GET_EXTERNAL_DEPENDENCIES request, where the extra\nparam will be a PF_ExtDependenciesExtra, and the effect should\nreport its information based on the given sequence_data.\n\nPF_OutFlag_SEND_UPDATE_PARAMS_UI\n\nSet this flag at PF_Cmd_GLOBAL_SETUP time if you want to receive\nPF_Cmd_UPDATE_PARAMS_UI messages.\n\nPF_OutFlag_AUDIO_FLOAT_ONLY\n\nSet this flag if you only want to receive PF_SIGNED_FLOAT data\nwhen processing audio data.  Requires PF_OutFlag_AUDIO_EFFECT_TOO\nor PF_OutFlag_AUDIO_EFFECT_ONLY.\n\nPF_OutFlag_AUDIO_IIR\n\nSet this flag at PF_Cmd_GLOBAL_SETUP time if you are an\nInfinite-Impulse-Response audio filter (i.e. your output at a given\ntime depends on your output from previous times).\n\nPF_OutFlag_I_SYNTHESIZE_AUDIO\n\nSet this flag at PF_Cmd_GLOBAL_SETUP time if you generate\naudio even when handed silence.  Requires PF_OutFlag_AUDIO_EFFECT_TOO\nor PF_OutFlag_AUDIO_EFFECT_ONLY.\n\nPF_OutFlag_AUDIO_EFFECT_TOO\n\nMust be set at PF_Cmd_GLOBAL_SETUP time for an effect that\nwants to filter the audio too (as opposed to just reading the audio).\n\nPF_OutFlag_AUDIO_EFFECT_ONLY\n\nMust be set at PF_Cmd_GLOBAL_SETUP time for an effect\nthat only filters audio (no video).\n\nPF_OutFlag2_SUPPORTS_QUERY_DYNAMIC_FLAGS\n\nSet this during PF_Cmd_GLOBAL_SETUP if the effect handles PF_Cmd_QUERY_DYNAMIC_FLAGS.\nSupporting this command can dramatically improve performance for certain\neffects, because it provides dynamic information to the host about what\ncan be cached (as opposed to PIPL bits which cannot be changed at run-time)\n\nPF_OutFlag2_I_USE_3D_CAMERA\n\nThis bit must be set if the effect ever uses the AEGP PF_Interface suite to\naccess camera layers. Can be over-ridden dynamically during PF_Cmd_QUERY_DYNAMIC_FLAGS.\n\nPF_OutFlag2_I_USE_3D_LIGHTS\n\nThis bit must be set if the effect ever uses the AEGP PF_Interface suite to\naccess camera layers. Can be over-ridden dynamically during PF_Cmd_QUERY_DYNAMIC_FLAGS.\n\nPF_OutFlag2_PARAM_GROUP_START_COLLAPSED_FLAG\n\nIf you want a parameter group to honor the PF_ParamFlag_COLLAPSE_TWIRLY or\nPF_ParamFlag_START_COLLAPSED flag, set this bit.  Otherwise, all parameter\ngroups will be collapsed by default.\n\nPF_OutFlag2_DOESNT_NEED_EMPTY_PIXELS\n\nAdded for render optimizations; shrinks the input buffer passed to the effect to\nexclude any empty pixels (where empty means \"zero alpha\" unless\nPF_OutFlag2_REVEALS_ZERO_ALPHA is set, in which case RGB must be zero as well.)\nThe origin of the trimmed buffer can be found in in_data->pre_effect_source_origin.\nEffects with both this flag and PF_OutFlag_I_EXPAND_BUFFER set may get called with\na null input buffer if their input is completely empty, and must be able to handle\nthis case without crashing. This flag can be cleared dynamically during\nPF_Cmd_QUERY_DYNAMIC_FLAGS.\n\nPF_OutFlag2_REVEALS_ZERO_ALPHA\n\nThe effect can take pixels with zero alpha and reveal the RGB data in them (like\nour Set Channels effect). This tells After Effects not to trim such pixels when\ndetermining the input for the effect. This flag can be cleared dynamically during\nPF_Cmd_QUERY_DYNAMIC_FLAGS.\n\nPF_OutFlag2_I_AM_DEPRECATED\nthis effect is still available, and shows up under user-visible \"Obsolete\" category\nin the UI. Setting this flag means \"there's a better way to do this, but this effect\nmay still be useful in some situations\".  distinct from PF_OutFlag_I_AM_OBSOLETE in\nthat these will still show up in the GUI and the user can still apply them to new\nprojects.  The category that is set by the effect is pretty much ignored, as it will\ninstead always go into the \"Obsolete\" category\n\nPF_OutFlag2_I_USE_TIMECODE\nNew in AE 9.0.  The effect depends on the Composition's timecode or a layer's\nsource footage timecode.  If the underlying timecode changes the effects will\nbe asked to rerender.\n\nPF_OutFlag2_AUTOMATIC_WIDE_TIME_INPUT\nNew in AE 10. Requires setting of PF_OutFlag_WIDE_TIME_INPUT (which allows you\nto support old hosts), but effectively overrides that flag. When set, all\nparameter checkouts are tracked so over-time dependencies are known by AE. Note\nthat if you use this new flag, and you cache any time-dependent data in your\nsequence data (or anywhere else), you must validate that cache using the\nnew PF_HaveInputsChangedOverTimeSpan() before using it.\n\nThis only works for smart effects (those that set PF_OutFlag2_SUPPORTS_SMART_RENDER). If you haven't\nset that, After Effects will silently treat this as PF_OutFlag_WIDE_TIME_INPUT instead.\n\nTo test that it's working, apply your effect with one parameter keyframed on every frame.\nRAM Preview to fill the cache, then change one of the keyframes. The related frame and\nall dependent frames (e.g. later frames, in the case of a simulation) should lose their\ncache marks and require re-rendering. Simlarly, upstream changes to sources of layer\nparameters should cause time-selective invalidation of the cache.\n\nPF_OutFlag2_DEPENDS_ON_UNREFERENCED_MASKS\nSet this if you are going to look at paths that aren't directly referenced by a path\nparam, e.g. if you are going to draw a stroke on all masks.\n\nPF_OutFlag2_OUTPUT_IS_WATERMARKED\nSet this if your output is going to be watermarked in some way that makes it unsuitable for\nfinal use, probably because the user is using an unlicensed demo version. It is ok to change\nthis state during the course of app session, if e.g. a floating license status changes.\nPlugin authors that actually do have this state changing asynchronously must be careful to\nhave the next render match the last state returned from QUERY_DYNAMIC_FLAGS otherwise race conditions\ncould cause incorrect frames to be cached. (This is a non-issue if you only change this in response\nto DO_DIALOG.)\n\nPF_OutFlag2_I_MIX_GUID_DEPENDENCIES\t(new in 13.5)\nSmart effects only. With this option, FORCE_RERENDER becomes a cache-savvy more efficient MAYBE rerender.\nIf custom UI or DO_DIALOG change sequence data, returning FORCE_RERENDER requests AE to check whether\nrerender needs to occur.  During PreRender, the effect uses the GuidMixInPtr callback to mix\nany additional state that affects the render into our internal GUID for the cached frame.\nAE can then tell whether the frame already exists and if so, no longer needs to render.\nThis also means that DO_DIALOG no longer always blows the cache and that undo works across DO_DIALOG.\nCancelation of DO_DIALOG no longer blows the cache either.\nThis also means that I_USE_* flags are now basically redundant since any dependency could be mixed in.\nJust be sure to mix in everything that can uniquely affect resulting rendered pixels (that is not already\nan AE stream parameter).  But don't mixin things that are disabled and have no render effect  (this\nresults in less cache efficiency).\n\nPF_OutFlag2_SUPPORTS_THREADED_RENDERING\nIndicates the effect supports rendering on multiple threads at the same time. Single or multiple\napplications of this effect on a layer can be called to render at the same time on multiple threads.\n\nUI selectors are still sent on the main thread, however Sequence Setup, Sequence Resetup, Sequence SetDown,\nPreRender, and Render may be sent on multiple threads at the same time as the UI selectors are being handled\nso all of these selectors must be thread safe.\n\nGlobal Setup and Global Setdown selectors are unaffected by this flag.  Regardless whether this flag is set\nor not, they will only be sent on the main thread, and will not be sent at the same time as any other selectors.\n\nIf the effect sets PF_OutFlag_SEQUENCE_DATA_NEEDS_FLATTENING indicating the sequence data needs flattening\nthen it must also set PF_OutFlag2_SUPPORTS_GET_FLATTENED_SEQUENCE_DATA.\n\nsequence_data is read-only at render time and must be accessed with PF_EffectSequenceDataSuite.\nin_data->sequence_data will be NULL during render. AEGP_ComputeCacheSuite is suggested if writing to\nsequence_data at render time is needed for caching. This suite unifies cache entries so multiple threads do\nnot recompute the same cache value. If neither of these solutions work, see the next flag,\nPF_OutFlag2_MUTABLE_RENDER_SEQUENCE_DATA_SLOWER.\n\nPF_OutFlag2_MUTABLE_RENDER_SEQUENCE_DATA_SLOWER\nIndicates the effect needs sequence_data replicated for each render thread, thus allowing each render to have\nsequence_data which can be written to. Note that changes to sequence_data will be discarded regularly, currently\nafter each span of frames is rendered such as single RAM Preview or Render Queue export."]
pub type _bindgen_ty_26 = ::std::os::raw::c_int;
pub type PF_OutFlags = A_long;
pub const PF_OutFlag2_NONE: _bindgen_ty_27 = 0;
pub const PF_OutFlag2_SUPPORTS_QUERY_DYNAMIC_FLAGS: _bindgen_ty_27 = 1;
pub const PF_OutFlag2_I_USE_3D_CAMERA: _bindgen_ty_27 = 2;
pub const PF_OutFlag2_I_USE_3D_LIGHTS: _bindgen_ty_27 = 4;
pub const PF_OutFlag2_PARAM_GROUP_START_COLLAPSED_FLAG: _bindgen_ty_27 = 8;
pub const PF_OutFlag2_I_AM_THREADSAFE: _bindgen_ty_27 = 16;
pub const PF_OutFlag2_CAN_COMBINE_WITH_DESTINATION: _bindgen_ty_27 = 32;
pub const PF_OutFlag2_DOESNT_NEED_EMPTY_PIXELS: _bindgen_ty_27 = 64;
pub const PF_OutFlag2_REVEALS_ZERO_ALPHA: _bindgen_ty_27 = 128;
pub const PF_OutFlag2_PRESERVES_FULLY_OPAQUE_PIXELS: _bindgen_ty_27 = 256;
pub const PF_OutFlag2_SUPPORTS_SMART_RENDER: _bindgen_ty_27 = 1024;
pub const PF_OutFlag2_RESERVED9: _bindgen_ty_27 = 2048;
pub const PF_OutFlag2_FLOAT_COLOR_AWARE: _bindgen_ty_27 = 4096;
pub const PF_OutFlag2_I_USE_COLORSPACE_ENUMERATION: _bindgen_ty_27 = 8192;
pub const PF_OutFlag2_I_AM_DEPRECATED: _bindgen_ty_27 = 16384;
pub const PF_OutFlag2_PPRO_DO_NOT_CLONE_SEQUENCE_DATA_FOR_RENDER: _bindgen_ty_27 = 32768;
pub const PF_OutFlag2_RESERVED10: _bindgen_ty_27 = 65536;
pub const PF_OutFlag2_AUTOMATIC_WIDE_TIME_INPUT: _bindgen_ty_27 = 131072;
pub const PF_OutFlag2_I_USE_TIMECODE: _bindgen_ty_27 = 262144;
pub const PF_OutFlag2_DEPENDS_ON_UNREFERENCED_MASKS: _bindgen_ty_27 = 524288;
pub const PF_OutFlag2_OUTPUT_IS_WATERMARKED: _bindgen_ty_27 = 1048576;
pub const PF_OutFlag2_I_MIX_GUID_DEPENDENCIES: _bindgen_ty_27 = 2097152;
pub const PF_OutFlag2_AE13_5_THREADSAFE: _bindgen_ty_27 = 4194304;
pub const PF_OutFlag2_SUPPORTS_GET_FLATTENED_SEQUENCE_DATA: _bindgen_ty_27 = 8388608;
pub const PF_OutFlag2_CUSTOM_UI_ASYNC_MANAGER: _bindgen_ty_27 = 16777216;
pub const PF_OutFlag2_SUPPORTS_GPU_RENDER_F32: _bindgen_ty_27 = 33554432;
pub const PF_OutFlag2_RESERVED12: _bindgen_ty_27 = 67108864;
pub const PF_OutFlag2_SUPPORTS_THREADED_RENDERING: _bindgen_ty_27 = 134217728;
pub const PF_OutFlag2_MUTABLE_RENDER_SEQUENCE_DATA_SLOWER: _bindgen_ty_27 = 268435456;
pub type _bindgen_ty_27 = ::std::os::raw::c_int;
pub type PF_OutFlags2 = A_long;
pub const PF_InFlag_NONE: _bindgen_ty_28 = 0;
pub const PF_InFlag_PROJECT_IS_RENDER_ONLY: _bindgen_ty_28 = 1;
#[doc = " -------------------- Input Flags --------------------\n\nThe in_flags field of the InData can be set to an OR-ed\ncombination of these flags to communicate various things from AE to an effect plugin\nThe flags are described here:\n\nPF_InFlag_NONE\nThis is the \"empty\" setting -- no inflags.\n\nPF_InFlag_PROJECT_IS_RENDER_ONLY  (since 13.5)\n\nFor efficiency, if a plugin sets up UI that is not used in render, this flag\ncan be tested to skip that step when an effect is being RESETUP for render only.\nEffect instances with this flag on in RESETUP are in read-only AE projects and will not receive UI related selectors.\n\nThis is an optimization hint.  If you don't make such optimizations in render your plugin should still work.\n\nThis flag should generally not be used to suppress errors in render.  Errors should still be reported as usual via AE standard mechanisms,\nand AE will then handle the differences in context reporting.\n\nIf this is off, UI should be set up normally (and the effect could also be running in an earlier version of\nAE that assumed render and UI on the same effect instance.)"]
pub type _bindgen_ty_28 = ::std::os::raw::c_int;
pub type PF_InFlags = A_long;
pub const PF_Cmd_ABOUT: _bindgen_ty_29 = 0;
pub const PF_Cmd_GLOBAL_SETUP: _bindgen_ty_29 = 1;
pub const PF_Cmd_UNUSED_0: _bindgen_ty_29 = 2;
pub const PF_Cmd_GLOBAL_SETDOWN: _bindgen_ty_29 = 3;
pub const PF_Cmd_PARAMS_SETUP: _bindgen_ty_29 = 4;
pub const PF_Cmd_SEQUENCE_SETUP: _bindgen_ty_29 = 5;
pub const PF_Cmd_SEQUENCE_RESETUP: _bindgen_ty_29 = 6;
pub const PF_Cmd_SEQUENCE_FLATTEN: _bindgen_ty_29 = 7;
pub const PF_Cmd_SEQUENCE_SETDOWN: _bindgen_ty_29 = 8;
pub const PF_Cmd_DO_DIALOG: _bindgen_ty_29 = 9;
pub const PF_Cmd_FRAME_SETUP: _bindgen_ty_29 = 10;
pub const PF_Cmd_RENDER: _bindgen_ty_29 = 11;
pub const PF_Cmd_FRAME_SETDOWN: _bindgen_ty_29 = 12;
pub const PF_Cmd_USER_CHANGED_PARAM: _bindgen_ty_29 = 13;
pub const PF_Cmd_UPDATE_PARAMS_UI: _bindgen_ty_29 = 14;
pub const PF_Cmd_EVENT: _bindgen_ty_29 = 15;
pub const PF_Cmd_GET_EXTERNAL_DEPENDENCIES: _bindgen_ty_29 = 16;
pub const PF_Cmd_COMPLETELY_GENERAL: _bindgen_ty_29 = 17;
pub const PF_Cmd_QUERY_DYNAMIC_FLAGS: _bindgen_ty_29 = 18;
pub const PF_Cmd_AUDIO_RENDER: _bindgen_ty_29 = 19;
pub const PF_Cmd_AUDIO_SETUP: _bindgen_ty_29 = 20;
pub const PF_Cmd_AUDIO_SETDOWN: _bindgen_ty_29 = 21;
pub const PF_Cmd_ARBITRARY_CALLBACK: _bindgen_ty_29 = 22;
pub const PF_Cmd_SMART_PRE_RENDER: _bindgen_ty_29 = 23;
pub const PF_Cmd_SMART_RENDER: _bindgen_ty_29 = 24;
pub const PF_Cmd_RESERVED1: _bindgen_ty_29 = 25;
pub const PF_Cmd_RESERVED2: _bindgen_ty_29 = 26;
pub const PF_Cmd_RESERVED3: _bindgen_ty_29 = 27;
pub const PF_Cmd_GET_FLATTENED_SEQUENCE_DATA: _bindgen_ty_29 = 28;
pub const PF_Cmd_TRANSLATE_PARAMS_TO_PREFS: _bindgen_ty_29 = 29;
pub const PF_Cmd_RESERVED4: _bindgen_ty_29 = 30;
pub const PF_Cmd_SMART_RENDER_GPU: _bindgen_ty_29 = 31;
pub const PF_Cmd_GPU_DEVICE_SETUP: _bindgen_ty_29 = 32;
pub const PF_Cmd_GPU_DEVICE_SETDOWN: _bindgen_ty_29 = 33;
pub const PF_Cmd_NUM_CMDS: _bindgen_ty_29 = 34;
#[doc = " -------------------- Command Selectors --------------------\n\nThe first parameter to the effect routine is one of t\these command\nselectors.  The commands are described here.\n\nPF_Cmd_ABOUT\nThis command should display an information dialog box about the\neffect module.  The easiest thing to do is PF_SPRINTF the info\ninto the out_data->return_msg field.  After Effects will bring\nup a simple undecorated modal dialog with your text proudly displayed.\nThis command can be sent at _any_ time, so don't count on having\nany global data or anything else set.  (Except, as always, the\ncurrent resource file will be set to your effects module.)\n\nPF_Cmd_GLOBAL_SETUP\nWhen you get this command, you should check the version of the\neffect protocol with which you are being invoked, and set any of\nthe necessary out flags (described above) or out data fields\n(described below).  If your global data was flattened, the flat\ndata will be passed here and you should unflatten it, free the\nflat global data, and set the OutData global_data to the new un-flat\ndata.  Alternatively, the global data may come in NULL and you can\nallocate new global data at this time.\n\nPF_Cmd_GLOBAL_SETDOWN\nYou should free any global data you have allocated when you get\nthis command.\n\nPF_Cmd_PARAMS_SETUP\nHere you should add any params your effect wants using the\nPF_ADD_PARAM callback described below.  This is called after global\nsetup -- see the add_param callback described below.\n\nPF_Cmd_SEQUENCE_SETUP\nThis is called when the effect is first applied to a layer.\nA sequence is a series of images that will usually be all be of the same\nsize and in the same context.  You can allocate sequence data\nat this time -- many more input fields are defined at this time.\nSee the PF_InData description below.\n\nAs of 13.5 this only happens on the UI thread.\nExcept for legacy (no GET_FLATTENED_SEQUENCE_DATA) effects that do I_DO_DIALOG which can still hit this in render.\n\nPF_Cmd_SEQUENCE_RESETUP\nThis call is made to unflatten flattened sequence data.\nThere are at least three cases when this can happen:\n1) after the sequence data is written to disk, 2) after the\nsequence data is read in from disk, 3) after a duplicate\nis made (called on both original and the new sequence).\n\nThis can happen in UI or Render thread (13.5),  the effect must handle\ninitialization of a NULL sequence_data input if needed.  See also PF_InFlag_PROJECT_IS_RENDER_ONLY.\n\nPF_Cmd_SEQUENCE_FLATTEN\nThis call is made to flatten unflat sequence data so it can be\ncached to disk.  After the data is flattened, free the un-flat data\nand set the out_data->sequence_data to the new flat data.\nIf you don't want your sequence handle written to disk, you\ncan set it to NULL (after disposing it) at this time.  Presumably\nyou would then reallocate it at another time.\n\nThis command will be sent when saving and when duplicating\nthe sequence.\n\nPF_Cmd_GET_FLATTENED_SEQUENCE_DATA\t(new in 13.5)\nReturns an independent allocation of the sequence data which can be written\nto disk or used to initialise or update other instances of the effect plug-in.\n\nThe host calls this command to serialize the sequence data without\nhaving to flatten and resetup the UI plug-in as was legacy practice. (However, at present effects\nstill may need flattening in render if the sequence_data is about to be assigned.)\n\nAn effect that implements GET_FLATTENED_SEQUENCE_DATA will only receive SEQUENCE_SETUP on the UI thread.\nSEQUENCE_RESETUP can happen on either thread. Make sure you handle a NULL sequence_data in RESETUP.\n(Without GET_FLATTENED, a legacy effect may still get SEQUENCE_SETUP in render but DO_DIALOG will not be called.)\n\nAlso when enabled, this means that the effect is guaranteed to get a\nSEQUENCE_SETDOWN cmd to dispose the effect's sequence_data  (previously\nit was possible for AE to bypass this if the sequence_data was flat,\nbut that lead to SEQUENCE_SETUP/SETDOWN imbalances for some plugins.\nThe imbalance should not happen when using this flag, but the plugin must\nhandle being called on SETDOWN with possibly flat data. For example,\ntry copy and pasting an effect onto itself.\n\nSupport for this command is indicated by setting\nPF_OutFlag2_SUPPORTS_GET_FLATTENED_SEQUENCE_DATA\n\nThe ownership of the returned handle is transferred to the host.\n\nPF_Cmd_SEQUENCE_SETDOWN\nYou should free any sequence data you have allocated when you\nget this command.\n\nPF_Cmd_DO_DIALOG\nThis command indicated that the Options button or command has\nbeen selected and the effect should bring up its options dialog.\nThis command will only be sent it the effect has indicated that\nit has an options dialog with PF_OutFlag_I_DO_DIALOG.  This\ncommand will automatically be sent once upon applying the filter\nif PF_OutFlag_SEND_DO_DIALOG is set in SEQUENCE_SETUP.\n\nPF_Cmd_FRAME_SETUP\nThis is called immediately before each frame is invoked.  You\ncan allocate frame data at this time, if you wish, or you can\njust wait for the RENDER which will immediately follow.\n\nPF_Cmd_RENDER\nThis is the call to render the frame.  All fields in the in_data\nwill be valid at this time and you can inquire parameters or\nwhat-have-you.  This should set the output frame with the new\nimage data.  This is the main action command.\n\nPF_Cmd_FRAME_SETDOWN\nIf you allocated data in PF_Cmd_FRAME_SETUP, this is the time\nto free it and clean up after rendering the frame.\n\nPF_Cmd_USER_CHANGED_PARAM\nThis command will be sent if you set the PF_ParamFlag_SUPERVISE\nflag for a param.  This allows you to modify the params array contents to\ncontrol values or make one control affect others, including arbitrary\ndata.  This command will be sent whenever the user interacts with a\nstandard param controller that has PF_ParamFlag_SUPERVISE\nset.\n\nThe \"extra\" field will be a pointer to a PF_UserChangedParamExtra structure\nwhich contains the param_index of the changed parameter.\n\nYou can return PF_ChangeFlag_CHANGED_VALUE and/or call PF_UpdateParamUI()\nfor any param.\n\nPF_Cmd_UPDATE_PARAMS_UI\nThis command will be sent when the Effect Controls Window (ECW)\nneeds to updated (e.g. after opening the ECW or moving the comp to\na new time) if you have set PF_OutFlag_SEND_UPDATE_PARAMS_UI at\nglobal setup time.\n\nThis gives you a chance to call PF_UpdateParamUI() to modify certain\nui fields for the params.  See the doc for PF_UpdateParamUI()\nto see which fields can be modified.\n\nWARNING: When handling PF_Cmd_UPDATE_PARAMS_UI, you can call\nPF_UpdateParamUI() for any param(s), but not PF_ChangeFlag_CHANGED_VALUE --\nonly cosmetic changes can be made in response to this command.\n\nPF_Cmd_QUERY_DYNAMIC_FLAGS\nThis command will be sent at arbitrary times if PF_OutFlag2_SUPPORTS_QUERY_DYNAMIC_FLAGS\nis set during global setup. During this call the effect may examine the values\nof its parameters at the current time (except layer parameters) by checking them out,\nand decide whether any of the flags that support PF_Cmd_QUERY_DYNAMIC_FLAGS should be set.\n\nThe appropriate flags must be set in out_data->out_flags and out_data->out_flags2 before\nreturning. The effect must decide what information is necessary to render a frame at\nthe current time, given only the values of parameters at that time. Clearing the\nappropriate bits when possible can result in great performance improvements, but\nincorrectly clearing bits will result in caching bugs, and you won't like that. Nope.\n\n Important Reminder***\nBefore you add a new PF_Cmd, evaluate whether it should allow\nnew Sequence Data allocations! If so, remember to add it to\nCmdCanChangeSequenceData() in FLT_Host.cpp!"]
pub type _bindgen_ty_29 = ::std::os::raw::c_int;
pub type PF_Cmd = A_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PF_LayerAudio {
    _unused: [u8; 0],
}
#[doc = " -------------------- Simple Types --------------------"]
pub type PF_LayerAudio = *mut _PF_LayerAudio;
pub type PF_SndSamplePtr = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ProgressInfo {
    _unused: [u8; 0],
}
pub type PF_ProgPtr = *mut PF_ProgressInfo;
pub type PF_ParamValue = A_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_SpecVersion {
    pub major: A_short,
    pub minor: A_short,
}
pub type PF_ParamIndex = A_long;
pub type PF_UFixed = A_u_long;
pub type PF_Fixed = A_long;
pub type PF_Boolean = A_char;
pub type PF_Handle = *mut *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_LegacyPoint {
    pub v: A_short,
    pub h: A_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_LegacyRect {
    pub top: A_short,
    pub left: A_short,
    pub bottom: A_short,
    pub right: A_short,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_Point {
    pub h: A_long,
    pub v: A_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_LRect {
    pub left: A_long,
    pub top: A_long,
    pub right: A_long,
    pub bottom: A_long,
}
pub type PF_Rect = PF_LRect;
pub type PF_UnionableRect = PF_Rect;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_RationalScale {
    pub num: A_long,
    pub den: A_u_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_FixedPoint {
    pub x: PF_Fixed,
    pub y: PF_Fixed,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_FixedRect {
    pub left: PF_Fixed,
    pub top: PF_Fixed,
    pub right: PF_Fixed,
    pub bottom: PF_Fixed,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_Matrix {
    pub mat: [[PF_Fixed; 3usize]; 3usize],
}
pub type PF_TransferMode = A_long;
pub type PF_XferMode = PF_TransferMode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_Pixel {
    pub alpha: A_u_char,
    pub red: A_u_char,
    pub green: A_u_char,
    pub blue: A_u_char,
}
pub type PF_Pixel8 = PF_Pixel;
pub type PF_UnionablePixel = PF_Pixel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_Pixel16 {
    pub alpha: A_u_short,
    pub red: A_u_short,
    pub green: A_u_short,
    pub blue: A_u_short,
}
pub type PF_FpShort = A_FpShort;
pub type PF_FpLong = A_FpLong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_PixelFloat {
    pub alpha: PF_FpShort,
    pub red: PF_FpShort,
    pub green: PF_FpShort,
    pub blue: PF_FpShort,
}
pub type PF_Pixel32 = PF_PixelFloat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_FloatMatrix {
    pub mat: [[PF_FpLong; 3usize]; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_CompositeMode {
    pub xfer: PF_TransferMode,
    pub rand_seed: A_long,
    pub opacity: A_u_char,
    pub rgb_only: PF_Boolean,
    pub opacitySu: A_u_short,
}
pub type PF_PixLong = A_u_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PF_PixelOpaque {
    _unused: [u8; 0],
}
pub type PF_PixelOpaquePtr = *mut _PF_PixelOpaque;
pub type PF_PixelPtr = *mut PF_Pixel;
pub type PF_RGB_Pixel = [PF_Fixed; 3usize];
pub type PF_YIQ_Pixel = [PF_Fixed; 3usize];
pub type PF_HLS_Pixel = [PF_Fixed; 3usize];
pub type PF_ChannelType = A_long;
pub type PF_DataType = A_long;
#[doc = " for enumerating over all the channels"]
pub type PF_ChannelIndex = A_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ChannelDesc {
    pub channel_type: PF_ChannelType,
    pub name: [A_char; 64usize],
    pub data_type: PF_DataType,
    pub dimension: A_long,
}
#[doc = " the opaque type representing the channel data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ChannelRef {
    pub opaque: [A_intptr_t; 8usize],
}
#[doc = " the opaque type representing the channel data"]
pub type PF_ChannelRefPtr = *mut PF_ChannelRef;
#[doc = " the channel data parallels the image data in size and shape.\n the width is the number of pixels, the height is the number of scanlines\n the height is image_height\n the dimension is the number of planes in a pixel\n the row_bytes is the length of a scanline in bytes\n the data type is the type of data in a plane\n\tNote : a pixel consists of dimensionL * sizeof(data_type) bytes\n dataH is a handle to the data.\n dataPV is a pointer to the dereferenced locked handle\n effects should always have dataPV non null."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ChannelChunk {
    pub channel_ref: PF_ChannelRef,
    pub widthL: A_long,
    pub heightL: A_long,
    pub dimensionL: A_long,
    pub row_bytesL: A_long,
    pub data_type: PF_DataType,
    pub dataH: PF_Handle,
    pub dataPV: *mut ::std::os::raw::c_void,
}
pub const PF_LayerDefault_MYSELF: _bindgen_ty_30 = -1;
pub const PF_LayerDefault_NONE: _bindgen_ty_30 = 0;
#[doc = " -------------------- Effect Parameter Description Structures --------------------\n\nIn general each structure is divided into two parts:\na) description of the parameter\nb) setting of parameter at the current invocation time\n\nA number of these structures end in A_char*, A_char[] unions.  These\nstructures are \"flattened\" between the add_param callback (in which\nthe A_char * should be used) and the read-only values accessible when\nthe effect is later invoked (at which time the A_char [] is used and\nthe string data is concatenated right at the end of the struct)."]
pub type _bindgen_ty_30 = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_LayerDef {
    pub reserved0: *mut ::std::os::raw::c_void,
    pub reserved1: *mut ::std::os::raw::c_void,
    pub world_flags: PF_WorldFlags,
    pub data: PF_PixelPtr,
    pub rowbytes: A_long,
    pub width: A_long,
    pub height: A_long,
    pub extent_hint: PF_UnionableRect,
    pub platform_ref: *mut ::std::os::raw::c_void,
    pub reserved_long1: A_long,
    pub reserved_long4: *mut ::std::os::raw::c_void,
    pub pix_aspect_ratio: PF_RationalScale,
    pub reserved_long2: *mut ::std::os::raw::c_void,
    pub origin_x: A_long,
    pub origin_y: A_long,
    pub reserved_long3: A_long,
    pub dephault: A_long,
}
pub type PF_EffectWorld = PF_LayerDef;
pub const PF_UNSIGNED_PCM: _bindgen_ty_31 = 0;
pub const PF_SIGNED_PCM: _bindgen_ty_31 = 1;
pub const PF_SIGNED_FLOAT: _bindgen_ty_31 = 2;
pub type _bindgen_ty_31 = ::std::os::raw::c_int;
pub type PF_SoundFormat = A_short;
pub const PF_SSS_1: _bindgen_ty_32 = 1;
pub const PF_SSS_2: _bindgen_ty_32 = 2;
pub const PF_SSS_4: _bindgen_ty_32 = 4;
pub type _bindgen_ty_32 = ::std::os::raw::c_int;
pub type PF_SoundSampleSize = A_short;
pub const PF_Channels_MONO: _bindgen_ty_33 = 1;
pub const PF_Channels_STEREO: _bindgen_ty_33 = 2;
pub type _bindgen_ty_33 = ::std::os::raw::c_int;
pub type PF_SoundChannels = A_short;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_SoundFormatInfo {
    pub rateF: PF_FpLong,
    pub num_channels: PF_SoundChannels,
    pub format: PF_SoundFormat,
    pub sample_size: PF_SoundSampleSize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_SoundWorld {
    pub fi: PF_SoundFormatInfo,
    pub num_samples: A_long,
    pub dataP: *mut ::std::os::raw::c_void,
}
pub const PF_ValueDisplayFlag_NONE: _bindgen_ty_34 = 0;
pub const PF_ValueDisplayFlag_PERCENT: _bindgen_ty_34 = 1;
pub const PF_ValueDisplayFlag_PIXEL: _bindgen_ty_34 = 2;
pub const PF_ValueDisplayFlag_RESERVED1: _bindgen_ty_34 = 4;
pub const PF_ValueDisplayFlag_REVERSE: _bindgen_ty_34 = 8;
pub type _bindgen_ty_34 = ::std::os::raw::c_int;
pub type PF_ValueDisplayFlags = A_short;
#[doc = " Slider -- PF_Param_SLIDER"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_SliderDef {
    pub value: PF_ParamValue,
    pub value_str: [A_char; 32usize],
    pub value_desc: [A_char; 32usize],
    pub valid_min: PF_ParamValue,
    pub valid_max: PF_ParamValue,
    pub slider_min: PF_ParamValue,
    pub slider_max: PF_ParamValue,
    pub dephault: PF_ParamValue,
}
#[doc = " Fixed Point Slider -- PF_Param_FIX_SLIDER"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_FixedSliderDef {
    pub value: PF_Fixed,
    pub value_str: [A_char; 32usize],
    pub value_desc: [A_char; 32usize],
    pub valid_min: PF_Fixed,
    pub valid_max: PF_Fixed,
    pub slider_min: PF_Fixed,
    pub slider_max: PF_Fixed,
    pub dephault: PF_Fixed,
    pub precision: A_short,
    pub display_flags: PF_ValueDisplayFlags,
}
pub const PF_FSliderFlag_NONE: _bindgen_ty_35 = 0;
pub const PF_FSliderFlag_WANT_PHASE: _bindgen_ty_35 = 1;
pub type _bindgen_ty_35 = ::std::os::raw::c_int;
pub type PF_FSliderFlags = A_u_long;
#[doc = " Floating Point Slider -- PF_Param_FLOAT_SLIDER"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_FloatSliderDef {
    pub value: PF_FpLong,
    pub phase: PF_FpLong,
    pub value_desc: [A_char; 32usize],
    pub valid_min: PF_FpShort,
    pub valid_max: PF_FpShort,
    pub slider_min: PF_FpShort,
    pub slider_max: PF_FpShort,
    pub dephault: PF_FpShort,
    pub precision: A_short,
    pub display_flags: PF_ValueDisplayFlags,
    pub fs_flags: PF_FSliderFlags,
    pub curve_tolerance: PF_FpShort,
    pub useExponent: PF_Boolean,
    pub exponent: PF_FpShort,
}
#[doc = " Angle -- PF_Param_ANGLE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_AngleDef {
    pub value: PF_Fixed,
    pub dephault: PF_Fixed,
    pub valid_min: PF_Fixed,
    pub valid_max: PF_Fixed,
}
#[doc = " CheckBox -- PF_Param_CHECKBOX"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PF_CheckBoxDef {
    pub value: PF_ParamValue,
    pub dephault: PF_Boolean,
    pub reserved: A_char,
    pub reserved1: A_short,
    pub u: PF_CheckBoxDef__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PF_CheckBoxDef__bindgen_ty_1 {
    pub nameptr: *const A_char,
}
#[doc = " Color -- PF_Param_COLOR"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ColorDef {
    pub value: PF_UnionablePixel,
    pub dephault: PF_UnionablePixel,
}
#[doc = " Point -- PF_Param_POINT\n\nThe values for the point use the source's coordinate system, with the\norigin at the top left. The values are expressed in fixed point, with\n16 bits of fractional precision (out of a total of 32 bits).\n\nThe dephaults (sorry) are expressed as percentages (with 16 bits of\nfraction) with the origin at the top left. The percent can be negative,\nbut should not be smaller than -600%. It should not be greater than 600%.\n\nIf restrict_bounds is TRUE, the user will not be allowed to specify\npoints outside the bounds of the layer to which they are applying the\neffect. If this is TRUE, the dephaults should be between 0.0 and 100.0."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_PointDef {
    pub x_value: PF_Fixed,
    pub y_value: PF_Fixed,
    pub reserved: [A_char; 3usize],
    pub restrict_bounds: PF_Boolean,
    pub x_dephault: PF_Fixed,
    pub y_dephault: PF_Fixed,
}
#[doc = " 3D Point -- PF_Param_POINT_3D\n\nJust like POINT, with an extra dimension. Supported in AE starting with version 10.5 (CS 5.5)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_Point3DDef {
    pub x_value: PF_FpLong,
    pub y_value: PF_FpLong,
    pub z_value: PF_FpLong,
    pub x_dephault: PF_FpLong,
    pub y_dephault: PF_FpLong,
    pub z_dephault: PF_FpLong,
    pub reserved: [::std::os::raw::c_char; 16usize],
}
#[doc = " Popup Menu -- PF_Param_POPUP\n\n can also be used as a radio-button group in some hosts\n when PF_PUI_RADIO_BUTTON is set\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PF_PopupDef {
    pub value: PF_ParamValue,
    pub num_choices: A_short,
    pub dephault: A_short,
    pub u: PF_PopupDef__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PF_PopupDef__bindgen_ty_1 {
    pub namesptr: *const A_char,
}
#[doc = " Momentary Buttons -- PF_Param_BUTTON\n\n supported by AE starting with CS 5.5 (AE 10.5); may be supported in other hosts\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PF_ButtonDef {
    pub value: PF_ParamValue,
    pub u: PF_ButtonDef__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PF_ButtonDef__bindgen_ty_1 {
    pub namesptr: *const A_char,
}
pub const PF_PathID_NONE: _bindgen_ty_36 = 0;
pub type _bindgen_ty_36 = ::std::os::raw::c_int;
pub type PF_PathID = A_u_long;
pub const PF_MaskMode_NONE: _bindgen_ty_37 = 0;
pub const PF_MaskMode_ADD: _bindgen_ty_37 = 1;
pub const PF_MaskMode_SUBTRACT: _bindgen_ty_37 = 2;
pub const PF_MaskMode_INTERSECT: _bindgen_ty_37 = 3;
pub const PF_MaskMode_LIGHTEN: _bindgen_ty_37 = 4;
pub const PF_MaskMode_DARKEN: _bindgen_ty_37 = 5;
pub const PF_MaskMode_DIFFERENCE: _bindgen_ty_37 = 6;
pub const PF_MaskMode_ACCUM: _bindgen_ty_37 = 7;
pub const PF_NUM_MASKMODES: _bindgen_ty_37 = 8;
pub type _bindgen_ty_37 = ::std::os::raw::c_int;
pub type PF_MaskMode = A_long;
#[doc = " Path -- PF_Param_PATH\n\nPath parameters give access to the mask/path/shapes of the layer on which\nthe effect is applied.  For more information\non how to use these paths, see the PF_PathQuerySuite, and the PF_PathDataSuite\nin AE_EffectSuites.h"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_PathDef {
    pub path_id: PF_PathID,
    pub reserved0: A_long,
    pub dephault: A_long,
}
pub type PF_ArbitraryH = PF_Handle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbitraryDef {
    pub id: A_short,
    pub pad: A_short,
    pub dephault: PF_ArbitraryH,
    pub value: PF_ArbitraryH,
    pub refconPV: *mut ::std::os::raw::c_void,
}
pub const PF_Arbitrary_NEW_FUNC: _bindgen_ty_38 = 0;
pub const PF_Arbitrary_DISPOSE_FUNC: _bindgen_ty_38 = 1;
pub const PF_Arbitrary_COPY_FUNC: _bindgen_ty_38 = 2;
pub const PF_Arbitrary_FLAT_SIZE_FUNC: _bindgen_ty_38 = 3;
pub const PF_Arbitrary_FLATTEN_FUNC: _bindgen_ty_38 = 4;
pub const PF_Arbitrary_UNFLATTEN_FUNC: _bindgen_ty_38 = 5;
pub const PF_Arbitrary_INTERP_FUNC: _bindgen_ty_38 = 6;
pub const PF_Arbitrary_COMPARE_FUNC: _bindgen_ty_38 = 7;
pub const PF_Arbitrary_PRINT_SIZE_FUNC: _bindgen_ty_38 = 8;
pub const PF_Arbitrary_PRINT_FUNC: _bindgen_ty_38 = 9;
pub const PF_Arbitrary_SCAN_FUNC: _bindgen_ty_38 = 10;
pub type _bindgen_ty_38 = ::std::os::raw::c_int;
pub type PF_FunctionSelector = A_long;
pub const PF_ArbCompare_EQUAL: _bindgen_ty_39 = 0;
pub const PF_ArbCompare_LESS: _bindgen_ty_39 = 1;
pub const PF_ArbCompare_MORE: _bindgen_ty_39 = 2;
pub const PF_ArbCompare_NOT_EQUAL: _bindgen_ty_39 = 3;
pub type _bindgen_ty_39 = ::std::os::raw::c_int;
pub type PF_ArbCompareResult = A_long;
pub const PF_ArbPrint_NONE: _bindgen_ty_40 = 0;
pub const PF_ArbPrint_ABBREVIATED: _bindgen_ty_40 = 1;
pub type _bindgen_ty_40 = ::std::os::raw::c_int;
pub type PF_ArbPrintFlags = A_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PF_ArbParamsExtra {
    pub which_function: PF_FunctionSelector,
    pub id: A_short,
    pub padding: A_short,
    pub u: PF_ArbParamsExtra__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PF_ArbParamsExtra__bindgen_ty_1 {
    pub new_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_1,
    pub dispose_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_2,
    pub copy_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_3,
    pub flat_size_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_4,
    pub flatten_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_5,
    pub unflatten_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_6,
    pub interp_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_7,
    pub compare_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_8,
    pub print_size_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_9,
    pub print_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_10,
    pub scan_func_params: PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_11,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_1 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub arbPH: *mut PF_ArbitraryH,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_2 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub arbH: PF_ArbitraryH,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_3 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub src_arbH: PF_ArbitraryH,
    pub dst_arbPH: *mut PF_ArbitraryH,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_4 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub arbH: PF_ArbitraryH,
    pub flat_data_sizePLu: *mut A_u_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_5 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub arbH: PF_ArbitraryH,
    pub buf_sizeLu: A_u_long,
    pub flat_dataPV: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_6 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub buf_sizeLu: A_u_long,
    pub flat_dataPV: *const ::std::os::raw::c_void,
    pub arbPH: *mut PF_ArbitraryH,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_7 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub left_arbH: PF_ArbitraryH,
    pub right_arbH: PF_ArbitraryH,
    pub tF: PF_FpLong,
    pub interpPH: *mut PF_ArbitraryH,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_8 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub a_arbH: PF_ArbitraryH,
    pub b_arbH: PF_ArbitraryH,
    pub compareP: *mut PF_ArbCompareResult,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_9 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub arbH: PF_ArbitraryH,
    pub print_sizePLu: *mut A_u_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_10 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub print_flags: PF_ArbPrintFlags,
    pub arbH: PF_ArbitraryH,
    pub print_sizeLu: A_u_long,
    pub print_bufferPC: *mut A_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ArbParamsExtra__bindgen_ty_1__bindgen_ty_11 {
    pub refconPV: *mut ::std::os::raw::c_void,
    pub bufPC: *const A_char,
    pub bytes_to_scanLu: A_u_long,
    pub arbPH: *mut PF_ArbitraryH,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_UserChangedParamExtra {
    pub param_index: PF_ParamIndex,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ImporterPrefsData {
    _unused: [u8; 0],
}
pub type PF_ImporterPrefsDataPtr = *mut PF_ImporterPrefsData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_TranslateParamsToPrefsExtra {
    pub prefsPC: PF_ImporterPrefsDataPtr,
    pub prefs_sizeLu: A_u_long,
}
pub const PF_DepCheckType_NONE: _bindgen_ty_41 = 0;
pub const PF_DepCheckType_ALL_DEPENDENCIES: _bindgen_ty_41 = 1;
pub const PF_DepCheckType_MISSING_DEPENDENCIES: _bindgen_ty_41 = 2;
pub type _bindgen_ty_41 = ::std::os::raw::c_int;
pub type PF_DepCheckType = A_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ExtDependenciesExtra {
    pub check_type: PF_DepCheckType,
    pub dependencies_strH: PF_Handle,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PF_ParamDefUnion {
    pub ld: PF_LayerDef,
    pub sd: PF_SliderDef,
    pub fd: PF_FixedSliderDef,
    pub ad: PF_AngleDef,
    pub bd: PF_CheckBoxDef,
    pub cd: PF_ColorDef,
    pub td: PF_PointDef,
    pub pd: PF_PopupDef,
    pub fs_d: PF_FloatSliderDef,
    pub arb_d: PF_ArbitraryDef,
    pub path_d: PF_PathDef,
    pub button_d: PF_ButtonDef,
    pub point3d_d: PF_Point3DDef,
}
pub const PF_PUI_NONE: _bindgen_ty_42 = 0;
pub const PF_PUI_TOPIC: _bindgen_ty_42 = 1;
pub const PF_PUI_CONTROL: _bindgen_ty_42 = 2;
pub const PF_PUI_STD_CONTROL_ONLY: _bindgen_ty_42 = 4;
pub const PF_PUI_NO_ECW_UI: _bindgen_ty_42 = 8;
pub const PF_PUI_ECW_SEPARATOR: _bindgen_ty_42 = 16;
pub const PF_PUI_DISABLED: _bindgen_ty_42 = 32;
pub const PF_PUI_DONT_ERASE_TOPIC: _bindgen_ty_42 = 64;
pub const PF_PUI_DONT_ERASE_CONTROL: _bindgen_ty_42 = 128;
pub const PF_PUI_RADIO_BUTTON: _bindgen_ty_42 = 256;
pub const PF_PUI_INVISIBLE: _bindgen_ty_42 = 512;
#[doc = " Param UI Flags\n\nPF_PUI_TOPIC\n\nSet this flag if you handle PF_Cmd_EVENTs for the \"topic\" of\nthe parameter.  The \"topic\" is the portion of the param UI\nin the Effect Controls Window (ECW) that is still visible\nwhen the twirly-arrow is twirled up for that param.\n\nIf you set this flag, you must also set PF_OutFlag_CUSTOM_UI\nat PF_Cmd_GLOBAL_SETUP time.\n\nPF_PUI_CONTROL\n\nSet this flag if you handle PF_Cmd_EVENTs for the control\narea in the ECW.  This is the area that becomes invisible\nwhen you twirl up a parameter's twirly arrow (and is the\nusual place to have your custom UI).\n\nIf you set this flag, you must also set PF_OutFlag_CUSTOM_UI\nat PF_Cmd_GLOBAL_SETUP time.\n\nPF_PUI_STD_CONTROL_ONLY\n\nSet this flag if you want the standard control only -- no\ndata stream will be associated with this parameter, and\nthus no keyframes (nothing appears in the Time Layout window\nfor this type of param).\n\nYou might want to do this to control something in your\nsequence data with a standard control.  Or in your arb\ndata, or custom UI in the comp window, or to group-set multiple\nother controls.\n\n\nThis flag can be used with these param types:\nPF_Param_SLIDER, PF_Param_FIX_SLIDER, PF_Param_ANGLE,\nPF_Param_CHECKBOX, PF_Param_COLOR, PF_Param_POINT,\nPF_Param_POPUP, PF_Param_FLOAT_SLIDER, PF_Param_POINT_3D\n\nbut NOT:\n\nPF_Param_CUSTOM, PF_Param_NO_DATA,\nPF_Param_LAYER, PF_Param_ARBITRARY_DATA, PF_Param_PATH\n\nIf you set this flag, you must also set PF_ParamFlag_SUPERVISE\n(otherwise you would never find out about value changes, and\nthe setting would never be used for anything).  This flag\ndoes not require the setting of PF_OutFlag_CUSTOM_UI.\n\nIf you want a standard control for PF_Param_ARBITRARY_DATA,\njust add one (or more) using PF_PUI_STD_CONTROL_ONLY with\nthe supported param types, and then when handling\nPF_Cmd_USER_CHANGED_PARAM you can modify your arb data.\n\n\nPF_PUI_NO_ECW_UI\n\nSet this flag if you want no UI to appear in the Effect Controls\nWindow.  Presumably, you are setting the value of the parameter\nthrough some other method (e.g. custom UI in the comp window,\nor while handling PF_Cmd_USER_CHANGED_PARAM for a different param with\nPF_ParamFlag_SUPERVISE set). In AE, this doesn't affect keyframe\nvisibility in the timeline. In PPro it does remove the entire row,\nso you won't see keyframes.\n\nPF_PUI_ECW_SEPARATOR\n\nSet this flag if you'd like a thick line above this parameter\nin the effect control window. This is provided so that parameters\ncan be grouped visually, if needed (without adding groups).\nThis flag can be changed at runtime through the PF_UpdateParamUI()\nmethod. Not used by AE.\n\nPF_PUI_INVISIBLE\n\nSet this flag if you'd like the parameter to be initially invisible. This is useful\nif your effect needs hidden data parameters that affect rendering.\n\nPremiere only: The parameter can later be made visible by clearing the flag\nduring the PF_UpdateParamUI() callback."]
pub type _bindgen_ty_42 = ::std::os::raw::c_int;
pub type PF_ParamUIFlags = A_long;
pub const PF_ChangeFlag_NONE: _bindgen_ty_43 = 0;
pub const PF_ChangeFlag_CHANGED_VALUE: _bindgen_ty_43 = 1;
pub const PF_ChangeFlag_RESERVED: _bindgen_ty_43 = 2;
pub const PF_ChangeFlag_SET_TO_VARY: _bindgen_ty_43 = 4;
pub const PF_ChangeFlag_SET_TO_CONSTANT: _bindgen_ty_43 = 8;
#[doc = " PF_ChangeFlags\n\nNew in AE 4.0 (although PF_ChangeFlag_CHANGED_VALUE was implemented\nby setting low bit of old changed field).\n\nPF_ChangeFlag_CHANGED_VALUE\n\nSet this flag for each param whose value you change when handling\na PF_Cmd_USER_CHANGED_PARAM or specific PF_Cmd_EVENT events\n(PF_Event_DO_CLICK, PF_Event_DRAG, & PF_Event_KEYDOWN). If set during\nPF_Cmd_EVENT, but sure to also set PF_EO_HANDLED_EVENT before returning.\nYou can change as many params as you want at once.  These changes are undoable and\nre-doable by the user.  Exception: do not set PF_PUI_STD_CONTROL_ONLY\nparam values with this flag, use PF_UpdateParamUI() instead.\n\nPF_ChangeFlag_SET_TO_VARY\n\nNot yet implemented.  Same restrictions as PF_ChangeFlag_CHANGED_VALUE.\n\nPF_ChangeFlag_SET_TO_CONSTANT\n\nNot yet implemented.  Same restrictions as PF_ChangeFlag_CHANGED_VALUE."]
pub type _bindgen_ty_43 = ::std::os::raw::c_int;
pub type PF_ChangeFlags = A_long;
#[doc = " ParamDef"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PF_ParamDef {
    pub uu: PF_ParamDef__bindgen_ty_1,
    pub ui_flags: PF_ParamUIFlags,
    pub ui_width: A_short,
    pub ui_height: A_short,
    pub param_type: PF_ParamType,
    pub name: [A_char; 32usize],
    pub flags: PF_ParamFlags,
    pub unused: A_long,
    pub u: PF_ParamDefUnion,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PF_ParamDef__bindgen_ty_1 {
    pub id: A_long,
    pub change_flags: PF_ChangeFlags,
}
#[doc = " ParamDef"]
pub type PF_ParamDefPtr = *mut PF_ParamDef;
#[doc = " ParamDef"]
pub type PF_ParamDefH = *mut *mut PF_ParamDef;
pub type PF_ParamList = *mut *mut PF_ParamDef;
pub const PF_ChannelMask_ALPHA: _bindgen_ty_44 = 1;
pub const PF_ChannelMask_RED: _bindgen_ty_44 = 2;
pub const PF_ChannelMask_GREEN: _bindgen_ty_44 = 4;
pub const PF_ChannelMask_BLUE: _bindgen_ty_44 = 8;
pub const PF_ChannelMask_ARGB: _bindgen_ty_44 = 15;
#[doc = " -------------------- Smart Render Interface Constants and Structures --------------------\n\nPF_Cmd_SMART_PRE_RENDER gets a PF_PreRenderExtra struct in the extra pointer, and must\nfill out the \"output\" field before returning.\n\nPF_Cmd_SMART_RENDER gets a PF_SmartRenderExtra struct in the extra pointer, if pre-render was invoked.\n"]
pub type _bindgen_ty_44 = ::std::os::raw::c_int;
pub type PF_ChannelMask = A_long;
pub const PF_GPU_Framework_NONE: _bindgen_ty_45 = 0;
pub const PF_GPU_Framework_OPENCL: _bindgen_ty_45 = 1;
pub const PF_GPU_Framework_METAL: _bindgen_ty_45 = 2;
pub const PF_GPU_Framework_CUDA: _bindgen_ty_45 = 3;
pub type _bindgen_ty_45 = ::std::os::raw::c_int;
pub type PF_GPU_Framework = A_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_RenderRequest {
    pub rect: PF_LRect,
    pub field: PF_Field,
    pub channel_mask: PF_ChannelMask,
    pub preserve_rgb_of_zero_alpha: PF_Boolean,
    pub unused: [::std::os::raw::c_char; 3usize],
    pub reserved: [A_long; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_PreRenderInput {
    pub output_request: PF_RenderRequest,
    pub bitdepth: ::std::os::raw::c_short,
    pub gpu_data: *const ::std::os::raw::c_void,
    pub what_gpu: PF_GPU_Framework,
    pub device_index: A_u_long,
}
pub type PF_DeletePreRenderDataFunc =
    ::std::option::Option<unsafe extern "C" fn(pre_render_data: *mut ::std::os::raw::c_void)>;
pub const PF_RenderOutputFlag_RETURNS_EXTRA_PIXELS: _bindgen_ty_46 = 1;
pub const PF_RenderOutputFlag_GPU_RENDER_POSSIBLE: _bindgen_ty_46 = 2;
pub const PF_RenderOutputFlag_RESERVED1: _bindgen_ty_46 = 4;
pub type _bindgen_ty_46 = ::std::os::raw::c_int;
pub type PF_RenderOutputFlags = ::std::os::raw::c_short;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_PreRenderOutput {
    pub result_rect: PF_LRect,
    pub max_result_rect: PF_LRect,
    pub solid: PF_Boolean,
    pub reserved: PF_Boolean,
    pub flags: PF_RenderOutputFlags,
    pub pre_render_data: *mut ::std::os::raw::c_void,
    pub delete_pre_render_data_func: PF_DeletePreRenderDataFunc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_CheckoutResult {
    pub result_rect: PF_LRect,
    pub max_result_rect: PF_LRect,
    pub par: PF_RationalScale,
    pub solid: PF_Boolean,
    pub reservedB: [PF_Boolean; 3usize],
    pub ref_width: A_long,
    pub ref_height: A_long,
    pub reserved: [A_long; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_PreRenderCallbacks {
    pub checkout_layer: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            index: PF_ParamIndex,
            checkout_idL: A_long,
            req: *const PF_RenderRequest,
            what_time: A_long,
            time_step: A_long,
            time_scale: A_u_long,
            checkout_result: *mut PF_CheckoutResult,
        ) -> PF_Err,
    >,
    pub GuidMixInPtr: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            buf_sizeLu: A_u_long,
            buf: *const ::std::os::raw::c_void,
        ) -> PF_Err,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_PreRenderExtra {
    pub input: *mut PF_PreRenderInput,
    pub output: *mut PF_PreRenderOutput,
    pub cb: *mut PF_PreRenderCallbacks,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_SmartRenderInput {
    pub output_request: PF_RenderRequest,
    pub bitdepth: ::std::os::raw::c_short,
    pub pre_render_data: *mut ::std::os::raw::c_void,
    pub gpu_data: *const ::std::os::raw::c_void,
    pub what_gpu: PF_GPU_Framework,
    pub device_index: A_u_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_SmartRenderCallbacks {
    pub checkout_layer_pixels: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            checkout_idL: A_long,
            pixels: *mut *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub checkin_layer_pixels: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, checkout_idL: A_long) -> PF_Err,
    >,
    pub checkout_output: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, output: *mut *mut PF_EffectWorld) -> PF_Err,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_SmartRenderExtra {
    pub input: *mut PF_SmartRenderInput,
    pub cb: *mut PF_SmartRenderCallbacks,
}
#[doc = " -------------------- GPU Setup/Setdown Constants and Structures --------------------\n\nPF_Cmd_GPU_DEVICE_SETUP gets a PF_GPUDeviceSetupExtra struct in the extra pointer.\n\nPF_Cmd_GPU_DEVICE_SETDOWN gets a PF_GPUDeviceSetdownExtra struct in the extra pointer.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_GPUDeviceSetupInput {
    pub what_gpu: PF_GPU_Framework,
    pub device_index: A_u_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_GPUDeviceSetupOutput {
    pub gpu_data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_GPUDeviceSetupExtra {
    pub input: *mut PF_GPUDeviceSetupInput,
    pub output: *mut PF_GPUDeviceSetupOutput,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_GPUDeviceSetdownInput {
    pub gpu_data: *mut ::std::os::raw::c_void,
    pub what_gpu: PF_GPU_Framework,
    pub device_index: A_u_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_GPUDeviceSetdownExtra {
    pub input: *mut PF_GPUDeviceSetdownInput,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PF_CustomUIInfo {
    _unused: [u8; 0],
}
#[doc = " -------------------- Interaction Callbacks --------------------\n\nEffects modules use callbacks to define their parameters.  When invoked,\nthey will be given the parameters values at the particular invocation\nmoment, but some effects may need to ask for the parameter values at\nother times (notably of layer parameters for, say, a visual echo).\n\nWhile running, effects modules are responsible for checking for user\ninterrupts.  This checking can be done with either the abort callback,\nwhich will return a value indicating if the user has taken any action,\nor with the progress callback, which performs user interrupt checking\njust like the abort callback, and also displays a progress display.\n\nAt the bottom of this section are macros for accessing these callback\nroutines.  The first parameter to each macro is a pointer to a PF_InData\nstructure, defined below.  This pointer will be passed to your effect.\n\ncheckout_param\nThe checkout_param callback allows you to inquire param values at times\nother than the current one, and allows you to access layer params other\nthan the default input layer and the output layer.  See the notes on the\n\"params\" structure at the end of this file.  The PF_ParamDef you must\nspecify cannot point into the \"params\" array; the memory must exist else-\nwhere, such as on the stack.\n\nIf you checkout a layer parameter and the layer popup is currently set\nto <none>, the return value will be filled with zeros.  You can check\nthe \"data\" pointer.  If it is NULL, then the layer param is set to <none>\nand you should do something like faking an all alpha zero layer or some\nsuch nonsense.  IMPORTANT: Due to 13.5 threading changes, checking out\na layer param that is not <none> inside of UPDATE_PARAMS_UI will return\na frame with black pixels to avoid render requests and possible deadlock.\nIn other selectors the actual render will be triggered as it did before.\n\ncheckin_param\nWhen you have called checkout_param, you must call checkin_param when you\nare done, so After Effects can clean up after itself and you.  This is\nvery important for smooth functioning and also to save memory where possible.\nOnce checked in, the fields in the PF_ParamDef will no longer be valid.\n\nadd_param\nWhen given the PARAMS_SETUP message, the effect will generally make a\nseries of calls to the add_param routine to define the interface that\nthe After Effects user will see.  See the PF_ParamDefs defined above.\nCurrently you can only add params at the end, and only at PARAMS_SETUP\ntime.\n\nabort\nPeriodically, you should check if the user wants to interrupt the\ncurrent processing.  The abort proc here will return non-zero if\nthe effects module should suspend its current processing.  If you\ncall this routine and it returns a value other than zero, you should\nreturn that value when your effect returns.  That will let us know\nif the effect completed rendering or not.\n\nprogress\nAlternatively, you may wish to display a progress bar while you are\nprocessing the image.  This routine combines the abort proc user\ninterrupt checking with code that will display a progress bar for\nyou.  The current and total params represent a fraction (current/total)\nthat describes how far you are along in your processing.  Current\nshould equal total when done.  Additionally, this routine will return\nnon-zero if you should suspend/abort your current processing.  You\nshould probably try not to call this too frequently (e.g. at every pixel).\nIt is better to call it, say, once per scanline, unless your filter is\nreally really slow."]
pub type PF_CustomUIInfo = _PF_CustomUIInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_InteractCallbacks {
    pub checkout_param: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            index: PF_ParamIndex,
            what_time: A_long,
            time_step: A_long,
            time_scale: A_u_long,
            param: *mut PF_ParamDef,
        ) -> PF_Err,
    >,
    pub checkin_param: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, param: *mut PF_ParamDef) -> PF_Err,
    >,
    pub add_param: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            index: PF_ParamIndex,
            def: PF_ParamDefPtr,
        ) -> PF_Err,
    >,
    pub abort: ::std::option::Option<unsafe extern "C" fn(effect_ref: PF_ProgPtr) -> PF_Err>,
    pub progress: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, current: A_long, total: A_long) -> PF_Err,
    >,
    pub register_ui: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, cust_info: *mut PF_CustomUIInfo) -> PF_Err,
    >,
    pub checkout_layer_audio: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            index: PF_ParamIndex,
            start_time: A_long,
            duration: A_long,
            time_scale: A_u_long,
            rate: PF_UFixed,
            bytes_per_sample: A_long,
            num_channels: A_long,
            fmt_signed: A_long,
            audio: *mut PF_LayerAudio,
        ) -> PF_Err,
    >,
    pub checkin_layer_audio: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, audio: PF_LayerAudio) -> PF_Err,
    >,
    pub get_audio_data: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            audio: PF_LayerAudio,
            data0: *mut PF_SndSamplePtr,
            num_samples0: *mut A_long,
            rate0: *mut PF_UFixed,
            bytes_per_sample0: *mut A_long,
            num_channels0: *mut A_long,
            fmt_signed0: *mut A_long,
        ) -> PF_Err,
    >,
    pub reserved_str: [*mut ::std::os::raw::c_void; 3usize],
    pub reserved: [*mut ::std::os::raw::c_void; 10usize],
}
#[doc = " -------------------- Effect Parameter Blocks --------------------\n\nThe effects module itself is invoked with input and output blocks\nof parameters for various messages that it needs to handle.  The\noutput block (values returned from the effect to the program) and\nthe input block (values provided by the program for the edification\nof the effect) are defined here.  Discussion follows.\n\nThe Output Block\n\nMost fields of the output block are only examined for changes after\ncertain commands have been sent to the effect module.  Each field\nbelow describes when it will be checked.\n\nmy_version\nThis is the version number of your plug-in effect, not to be confused\nwith the version of the plug-in specification. Please set this\nat PF_Cmd_GLOBAL_SETUP.\n\nname\nThis lets you override the name of the effect in the Time Layout and\nin the Effect Controls windows when the effect is applied. The name from\nthe PiPL resource is always used in the Effect menu. This field is\nchecked after PF_Cmd_SEQUENCE_SETUP. You will almost always leave\nthis field empty.\n\nglobal_data\nThis is a Handle that you can allocate at PF_Cmd_GLOBAL_SETUP\ntime.  It will be passed back to you verbatim in the input\nparameter block for use later on.  In PF_Cmd_GLOBAL_SETUP,\nthe global_data field in the Input Block may be set to a\nflattened version of your global data, in which case you should\nunflatten it, free the flat version, and set this field to the\nunflattened new global data.\n\nIt will be locked & unlocked for you automatically like sequence_data.\n\nnum_params\nThe calling application will sanity check the num_params field\nvs the times add_param is called.  The implicit main\nlayer parameter MUST be included in the parameter count.  Use the\nnum_params value in the in_data as a starting value (it will\ninclude the implicit layer parameter).\nSet this field when you get PF_Cmd_PARAMS_SETUP.\n\nsequence_data\nThis is a Handle that you can allocate (using PF_NEW_HANDLE)\nat PF_Cmd_SEQUENCE_SETUP time.\nIt will be passed back to you in the input parameter block\nfor later use.\n\nWARNING: this handle is always locked for you before your plugin\nis called, and the lock-state is restored on the way out.  If you\nhave arbitrary data, your plugin can be called re-entrantly, so\nif you have a lock/unlock inside your plugin, the handle will\nbecome unlocked prematurely -- instead simply depend on the host\nto lock & unlock your sequence data for you.  Of course during\nPF_Cmd_SEQUENCE_SETUP the handle you allocate will not be\nlocked unless you explicitly lock it at that time.\n\nThe contents of this handle will be written out to\ndisk.  If other handles\thang off this block, you must specify the\nPF_OutFlag_SEQUENCE_DATA_NEEDS_FLATTENING out flag when you get\nthe PF_Cmd_GLOBAL_SETUP command.  You will then receive the\nPF_Cmd_SEQUENCE_FLATTEN before your handle is written out.  At that\ntime, you should create a flat version of the handle contents,\nfree the old unflat handle, and set this field to the flattened\nversion of the handle.  Or after disposing, simply set to NULL\nand nothing will be written to disk.\n\nYou will receive a PF_Cmd_SEQUENCE_RESETUP\ncall to unflatten this handle (as well as to adjust the sequence\ndata to altered frame rates, etc).  If your\nsequence data can be flat or unflat, you should store its current\nstate along with the other data, and check that value in Resetup.\nIf the handle is flat, Resetup should unflatten it, free the flat\nhandle, and set this field to the new unflat usable handle.\n\nflat_sdata_size\nOBSOLETE.  Turns out, it was never used.  Since the handle\nset in sequence_data must be allocated using PF_NEW_HANDLE,\nthe host can find out the size of the handle without asking.\n\nframe_data\nThis is a Handle that you can allocated at PF_Cmd_FRAME_SETUP\ntime.  It will be passed to you in the input parameters, as\nwith the global_data and the sequence_data.  This will not\nbe written out to disk.  There is no particular use for this.\nSet this field in PF_Cmd_FRAME_SETUP, if you must.\n\nIt will be locked & unlocked for you like sequence_data.\n\nwidth\nheight\norigin\nYou set these fields at PF_Cmd_FRAME_SETUP time to indicate\nthat the output image will be larger than the input image.\nYou\tshould set width and height to the size that you want the\noutput buffer to be.  Set origin to the place that the\npoint (0,0) in the input should map to in the new larger\noutput.  Thus, if you created a 5 pixel drop shadow up and left,\nyou would set origin to (5, 5).\n\nout_flags\nout_flags2\nThis field can be set to an OR-ed combination of the PF_OutFlag\nand PF_OutFlag2 constants (don't mix them up!) to communicate\nthings to After Effects.  This will be checked after every\ncommand, but only certain flags are relevant at given times.\nCheck the PF_OutFlag constants above.\n\nreturn_msg\nThis is a message string (in C string format) that will be\ninterpreted as either an error message or a useful display\nmessage (for instance, for handling PF_Cmd_ABOUT).  Fill\nthis string with a message you want After Effects to report\nto the user for you.  It will come up in a simple dialog\nwith an OK button.  Set the first byte of this string to '\\0'\nto indicate no string -- it is set that way upon entry.  This\nfield is examined after every PF_Cmd.\n\nThe Input Block\n\nMany parts of the input block are actually structures defined elsewhere\nin this file, or in the companion file AE_EffectCB.h.  See the documentation\nwhere those structures are defined to understand their contents.\nWith any given PF_Cmd, only certain fields in the Input Block will\nhave valid values.  Each field described below tells when it is valid.\n\nin_flags\nin_flags2\nThese are various flags indicating some boolean value to\nthe effect module.  This is a combination of PF_InFlag values\nOR-ed together.  This is set for all commands, though most\nflags make sense only at certain times.  Usually this is\njust a copy of the PiPL global flags.  See PF_OutFlags and\nPF_OutFlags2 above.\n\ninter\nThis is a structure defined above containing callbacks\nrelated to user interaction.  This has callbacks to add parameters,\nto check if the user has interrupted the effect, to display\na progress bar, and to inquire parameter values outside of the\ncurrent moment.  See the doc above.  When each callback can\nvalidly be executed is defined above.\n\nutils\nThis is a pointer to a block of useful graphical and mathematical\ncallbacks provided for the effects module.  The documentation\nfor this block is in the AE_EffectCB.h file.  This is a void *,\nwhich can be confusing.  See AE_EffectCB.h for macros to use these\nfunctions.  This pointer will be defined at all times.\n\neffect_ref\nThis is a opaque piece of data that needs to be passed to\nmost of the various callback routines.  Don't worry about it.\n\nquality\nThis is set to one of the PF_Quality constants above to\ndescribe the Quality currently chosen by the user.  Ideally,\nyour effect should do a faster version with LO quality, and\na better, \"broadcast\"-able version with HI quality.  Also,\nsome of the utility callbacks perform differently between\nLO and HI quality.  This is defined for all PF_Cmds related\nto SEQUENCE and FRAME (obviously, including RENDER).\n\nversion\nThis is the version of the effects spec with which you are\nbeing invoked.  This will not be defined until after GLOBAL_SETUP.\n\nserial_num\nThis is the serial number of the invoking application.\n\nappl_id\nThis is the identifier of the invoking application.  It will\nbe the creator A_long of the app.\n\nfreq\nThis is an estimate of the frequency with which you should\ncall the abort check callback.  You can ignore this.\n\nnum_params\nThis is set to the number of input parameters you are receiving.\n\nwhat_cpu\nThis is set to the return value from Gestalt asking what sort\nof CPU your machine has.  If your effect requires a certain\ntype of CPU it should check this value and return an error\nindicating that it cannot run.  After Effects only runs on\n68020s and higher, so don't sweat it if you require that.\n\nwhat_fpu\nThis is set to the return value from Gestalt asking what sort\nof FPU your machine has.  If you require a floating point unit,\nyou should return the OutFlag indicating that in GLOBAL_SETUP,\nand then do not execute your floating point code if this value\nis set to 0 -- just do a PF_COPY of the input to the output when\nyou get the PF_Cmd_RENDER.  See OutFlag description above.\n\ncurrent_time\nThis is the time of the current frame.  It will be set in RENDER.\nThe number of the current frame is current_time / time_step.\nAll effects sequences start at time 0.\n\ntime_step\nThis is the time difference to the next or last frame.  This value\nand current_time and total_time are in units given by time_scale.\nThe time between frames is time_step, not 1.  This value will be 0\nat SEQUENCE_SETUP if it is not constant for all frames.  It will\nbe set correctly in the FRAME calls, even if it's not constant.\n\ntotal_time\nThis is the amount of time from the start to the end of the\nimage sequence on which this effect is being invoked.  The total\nnumber of frames is total_time / time_step.\n\ntime_scale\nThese are the units that current_time, time_step, and total_time\nare in.  See QuickTime for an explanation of how these time values work.\n\nwidth\nheight\nThese are the size of the input image. As Stoney Ballard points out,\nthese are certainly NOT the same as the\twidth and height fields in param[0],\nbut rather reflect the full-resolution dimensions of the input layer.\n\nfield\nWill be set to PF_Field_UPPER or PF_Field_LOWER during field-rendering\nif certain conditions are met -- for example: effect must have\nPF_OutFlag_PIX_INDEPENDENT set, and the layer to which the effect is\napplied must not be rotated, scaled nor positioned on a subpixel.\nYou can safely ignore the setting of this field, but might be able to\noptimize things by only processing the specified field.\n\nextent_hint\nThis is a rectangle that indicates the intersection of the visible\nportions of the input and output layers.  For an effect that does\nnot do a geometric distortion of the image, copying just this rectangle\nfrom the source image to the destination image is sufficient to copy\nall the image data that the user will see.  This can speed up effects\nvery much.  Just iterate over only this rectangle of pixels.\n\noutput_origin_x\noutput_origin_y\nThese fields correspond to the origin returned in the out_data at\nPF_Cmd_FRAME_SETUP time. They indicate the position of the top left\ncorner of the input buffer in the output buffer.\n\ndownsample_x\ndownsample_y\nFor speed, the user may have asked for only every Nth vertical or\nhorizontal pixel to be actually rendered by After Effects.  The width\nand height of all effect parameters (including layers) will be\nautomatically adjusted to compensate, but the effect needs to know\nthe downsampling factors to correctly interpret scalar parameters\n(ie. sliders) that represent pixel distances in the image.\nDownsample factors will be in the range 1 to 999+.  This is set in\nSEQUENCE_SETUP or RESETUP as the case may be. As of PF_PLUG_IN_VERSION 2,\nthis factor is a rational quantity.\n\nglobal_data\nsequence_data\nframe_data\nThese fields are copied from the out data on previous invocations\nand set here for you to access as you need them.  They will only\nbe set if they have been allocated during previous commands.\n\npre_effect_source_origin_x\npre_effect_source_origin_y\nThese fields are the origin of the source image in the input buffer. They are set\nonly during frame calls (PF_Cmd_FRAME_SETUP, PF_Cmd_RENDER, PF_Cmd_FRAME_SETDOWN).\nThey will be non-zero only if one or more effects that preceded this effect\non the same layer resized the output buffer (i.e. specified that the output\nimage will be larger or smaller than the input image)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_OutData {
    pub my_version: A_u_long,
    pub name: [A_char; 32usize],
    pub global_data: PF_Handle,
    pub num_params: A_long,
    pub sequence_data: PF_Handle,
    pub flat_sdata_size: A_long,
    pub frame_data: PF_Handle,
    pub width: A_long,
    pub height: A_long,
    pub origin: PF_Point,
    pub out_flags: PF_OutFlags,
    pub return_msg: [A_char; 256usize],
    pub start_sampL: A_long,
    pub dur_sampL: A_long,
    pub dest_snd: PF_SoundWorld,
    pub out_flags2: PF_OutFlags2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_InData {
    pub inter: PF_InteractCallbacks,
    pub utils: *mut _PF_UtilCallbacks,
    pub effect_ref: PF_ProgPtr,
    pub quality: PF_Quality,
    pub version: PF_SpecVersion,
    pub serial_num: A_long,
    pub appl_id: A_long,
    pub num_params: A_long,
    pub reserved: A_long,
    pub what_cpu: A_long,
    pub what_fpu: A_long,
    pub current_time: A_long,
    pub time_step: A_long,
    pub total_time: A_long,
    pub local_time_step: A_long,
    pub time_scale: A_u_long,
    pub field: PF_Field,
    pub shutter_angle: PF_Fixed,
    pub width: A_long,
    pub height: A_long,
    pub extent_hint: PF_Rect,
    pub output_origin_x: A_long,
    pub output_origin_y: A_long,
    pub downsample_x: PF_RationalScale,
    pub downsample_y: PF_RationalScale,
    pub pixel_aspect_ratio: PF_RationalScale,
    pub in_flags: PF_InFlags,
    pub global_data: PF_Handle,
    pub sequence_data: PF_Handle,
    pub frame_data: PF_Handle,
    pub start_sampL: A_long,
    pub dur_sampL: A_long,
    pub total_sampL: A_long,
    pub src_snd: PF_SoundWorld,
    pub pica_basicP: *mut SPBasicSuite,
    pub pre_effect_source_origin_x: A_long,
    pub pre_effect_source_origin_y: A_long,
    pub shutter_phase: PF_Fixed,
}
#[doc = " -------------------- Effect Prototype --------------------\n\nThe effects module provides a single entry point corresponding to the\nbelow prototype through which all messages are dispatched to the\nappropriate code.\n\nThe cmd parameter is one of the PF_Cmd enumeration defined above.\nAll commands are discussed at that enumeration.  There are a lot.\n\nThe in_data and out_data parameters are respectively, PF_InData and\nPF_OutData blocks defined and described above.  The in_data contains\nread only information that the effect can use.  The out_data contains\nwrite only information through which the effect communicates back to\nthe calling program.  The descriptions above give a lot more detail.\n\nThe params list is an array of pointers to variably sized PF_ParamDef\nstructs.  This is in typical Unix-like argv format, where the last item\npoints to NULL.  The entries in this array describe the current settings\nof the parameters to the effect.  Params[0] is the layer to which the\neffect has been applied and is a PF_LayerDef param.  Other parameters\nare defined by the effect.\n\nThe output param is also a PF_LayerDef param, like params[0], and is\nan output buffer into which your effect should write the new contents\nof the layer.\n\nA brief explanation about parameter passing to effects:\n\nWhen you are invoked to Render, all \"params\" array entries will be filled\nwith their value at the current time, except for layer params other than\nthe default input layer parameter (ie. param[0]).  To get other layer param\nvalues, you must call the checkout_param callback.  (See callbacks above.)\n\nIn other words, on PF_Cmd_RENDER, params[0] will be a valid ready-to-use\nPF_EffectWorld and output will be a valid ready-to-use PF_EffectWorld.  Other params that\nare not layer params (i.e. sliders, popups, etc.) will be ready-to-use, filled\nwith their value at the current time; you do not need to call checkout_param for\nthem.  However, other params (besides [0]) that are layer params will NOT be\nfilled in correctly -- you must make a checkout_param callback to get them.\n\nANY param which you call checkout_param on, you must also call checkin_param\nbefore you exit.  If not, After Effects will automatically erase your effect\nmodule code resource from the users hard disk, along with any files that contain\nyour name or any nicknames you have.  Sorry.  Calling checkin_param is important!"]
pub type PF_FilterProc = ::std::option::Option<
    unsafe extern "C" fn(
        cmd: PF_Cmd,
        in_data: *mut PF_InData,
        out_data: *mut PF_OutData,
        params: PF_ParamList,
        output: *mut PF_LayerDef,
        extra: *mut ::std::os::raw::c_void,
    ) -> PF_Err,
>;
pub type PF_KernelFlags = A_u_long;
pub const PF_SampleEdgeBehav_ZERO: _bindgen_ty_47 = 0;
#[doc = " ---------- PF_SampleEdgeBehav ----------\n\nThe sampling routines always deal with 32 bit images, and thus\nneed to compute properly alpha-weighted samples. An issue arises\nwhen an attempt is made to sample outside of the image content area.\n\nBefore PF_PLUG_IN_VERSION 2, After Effects always treated pixels\noutside of the image content area as having alpha = 0, which is desirable\nin many cases. Distortions and other effects may want different sampling\nbehaviors, however, hence the PF_SampleEdgeBehav.\n"]
pub type _bindgen_ty_47 = ::std::os::raw::c_int;
pub type PF_SampleEdgeBehav = A_u_long;
pub const PF_Xfer_NONE: _bindgen_ty_48 = -1;
pub const PF_Xfer_COPY: _bindgen_ty_48 = 0;
pub const PF_Xfer_BEHIND: _bindgen_ty_48 = 1;
pub const PF_Xfer_IN_FRONT: _bindgen_ty_48 = 2;
pub const PF_Xfer_DISSOLVE: _bindgen_ty_48 = 3;
pub const PF_Xfer_ADD: _bindgen_ty_48 = 4;
pub const PF_Xfer_MULTIPLY: _bindgen_ty_48 = 5;
pub const PF_Xfer_SCREEN: _bindgen_ty_48 = 6;
pub const PF_Xfer_OVERLAY: _bindgen_ty_48 = 7;
pub const PF_Xfer_SOFT_LIGHT: _bindgen_ty_48 = 8;
pub const PF_Xfer_HARD_LIGHT: _bindgen_ty_48 = 9;
pub const PF_Xfer_DARKEN: _bindgen_ty_48 = 10;
pub const PF_Xfer_LIGHTEN: _bindgen_ty_48 = 11;
pub const PF_Xfer_DIFFERENCE: _bindgen_ty_48 = 12;
pub const PF_Xfer_HUE: _bindgen_ty_48 = 13;
pub const PF_Xfer_SATURATION: _bindgen_ty_48 = 14;
pub const PF_Xfer_COLOR: _bindgen_ty_48 = 15;
pub const PF_Xfer_LUMINOSITY: _bindgen_ty_48 = 16;
pub const PF_Xfer_MULTIPLY_ALPHA: _bindgen_ty_48 = 17;
pub const PF_Xfer_MULTIPLY_ALPHA_LUMA: _bindgen_ty_48 = 18;
pub const PF_Xfer_MULTIPLY_NOT_ALPHA: _bindgen_ty_48 = 19;
pub const PF_Xfer_MULTIPLY_NOT_ALPHA_LUMA: _bindgen_ty_48 = 20;
pub const PF_Xfer_ADDITIVE_PREMUL: _bindgen_ty_48 = 21;
pub const PF_Xfer_ALPHA_ADD: _bindgen_ty_48 = 22;
pub const PF_Xfer_COLOR_DODGE: _bindgen_ty_48 = 23;
pub const PF_Xfer_COLOR_BURN: _bindgen_ty_48 = 24;
pub const PF_Xfer_EXCLUSION: _bindgen_ty_48 = 25;
pub const PF_Xfer_DIFFERENCE2: _bindgen_ty_48 = 26;
pub const PF_Xfer_COLOR_DODGE2: _bindgen_ty_48 = 27;
pub const PF_Xfer_COLOR_BURN2: _bindgen_ty_48 = 28;
pub const PF_Xfer_LINEAR_DODGE: _bindgen_ty_48 = 29;
pub const PF_Xfer_LINEAR_BURN: _bindgen_ty_48 = 30;
pub const PF_Xfer_LINEAR_LIGHT: _bindgen_ty_48 = 31;
pub const PF_Xfer_VIVID_LIGHT: _bindgen_ty_48 = 32;
pub const PF_Xfer_PIN_LIGHT: _bindgen_ty_48 = 33;
pub const PF_Xfer_HARD_MIX: _bindgen_ty_48 = 34;
pub const PF_Xfer_LIGHTER_COLOR: _bindgen_ty_48 = 35;
pub const PF_Xfer_DARKER_COLOR: _bindgen_ty_48 = 36;
pub const PF_Xfer_SUBTRACT: _bindgen_ty_48 = 37;
pub const PF_Xfer_DIVIDE: _bindgen_ty_48 = 38;
pub const PF_Xfer_RESERVED0: _bindgen_ty_48 = 39;
pub const PF_Xfer_RESERVED1: _bindgen_ty_48 = 40;
pub const PF_Xfer_NUM_MODES: _bindgen_ty_48 = 41;
pub type _bindgen_ty_48 = ::std::os::raw::c_int;
pub const PF_Xfer_TINT: _bindgen_ty_49 = 29;
pub const PF_Xfer_SHADE: _bindgen_ty_49 = 30;
pub const PF_Xfer_INTENSE_LIGHT: _bindgen_ty_49 = 32;
pub type _bindgen_ty_49 = ::std::os::raw::c_int;
pub const PF_MaskFlag_NONE: _bindgen_ty_50 = 0;
pub const PF_MaskFlag_INVERTED: _bindgen_ty_50 = 1;
pub const PF_MaskFlag_LUMINANCE: _bindgen_ty_50 = 2;
pub type _bindgen_ty_50 = ::std::os::raw::c_int;
pub type PF_MaskFlags = A_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_MaskWorld {
    pub mask: PF_EffectWorld,
    pub offset: PF_Point,
    pub what_is_mask: PF_MaskFlags,
}
#[doc = " ---------- PF_SampPB ----------\n\nThere are calls to sample an a non-integral point in an image,\nand to sample an area of an image.  This parameter block describes\nsome information needed for these image resampling routines."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_SampPB {
    pub x_radius: PF_Fixed,
    pub y_radius: PF_Fixed,
    pub area: PF_Fixed,
    pub src: *mut PF_EffectWorld,
    pub samp_behave: PF_SampleEdgeBehav,
    pub allow_asynch: A_long,
    pub motion_blur: A_long,
    pub comp_mode: PF_CompositeMode,
    pub mask0: PF_PixelPtr,
    pub fcm_table: *mut A_u_char,
    pub fcd_table: *mut A_u_char,
    pub reserved: [A_long; 8usize],
}
pub const PF_Callback_NONE: _bindgen_ty_51 = 0;
pub const PF_Callback_BEGIN_SAMPLING: _bindgen_ty_51 = 1;
pub const PF_Callback_SUBPIXEL_SAMPLE: _bindgen_ty_51 = 2;
pub const PF_Callback_AREA_SAMPLE: _bindgen_ty_51 = 3;
pub const PF_Callback_OBSOLETE0: _bindgen_ty_51 = 4;
pub const PF_Callback_END_SAMPLING: _bindgen_ty_51 = 5;
pub const PF_Callback_COMPOSITE_RECT: _bindgen_ty_51 = 6;
pub const PF_Callback_BLEND: _bindgen_ty_51 = 7;
pub const PF_Callback_CONVOLVE: _bindgen_ty_51 = 8;
pub const PF_Callback_COPY: _bindgen_ty_51 = 9;
pub const PF_Callback_FILL: _bindgen_ty_51 = 10;
pub const PF_Callback_GAUSSIAN: _bindgen_ty_51 = 11;
pub const PF_Callback_ITERATE: _bindgen_ty_51 = 12;
pub const PF_Callback_PREMUL: _bindgen_ty_51 = 13;
pub const PF_Callback_PREMUL_COLOR: _bindgen_ty_51 = 14;
pub const PF_Callback_RGB_TO_HLS: _bindgen_ty_51 = 15;
pub const PF_Callback_HLS_TO_RGB: _bindgen_ty_51 = 16;
pub const PF_Callback_RGB_TO_YIQ: _bindgen_ty_51 = 17;
pub const PF_Callback_YIQ_TO_RGB: _bindgen_ty_51 = 18;
pub const PF_Callback_LUMINANCE: _bindgen_ty_51 = 19;
pub const PF_Callback_HUE: _bindgen_ty_51 = 20;
pub const PF_Callback_LIGHTNESS: _bindgen_ty_51 = 21;
pub const PF_Callback_SATURATION: _bindgen_ty_51 = 22;
pub const PF_Callback_NEW_WORLD: _bindgen_ty_51 = 23;
pub const PF_Callback_DISPOSE_WORLD: _bindgen_ty_51 = 24;
pub const PF_Callback_ITERATE_ORIGIN: _bindgen_ty_51 = 25;
pub const PF_Callback_ITERATE_LUT: _bindgen_ty_51 = 26;
pub const PF_Callback_TRANSFER_RECT: _bindgen_ty_51 = 27;
pub const PF_Callback_TRANSFORM_WORLD: _bindgen_ty_51 = 28;
pub const PF_Callback_ITERATE_ORIGIN_NON_CLIP_SRC: _bindgen_ty_51 = 29;
pub const PF_Callback_ITERATE_GENERIC: _bindgen_ty_51 = 30;
pub const PF_Callback_SUBPIXEL_SAMPLE16: _bindgen_ty_51 = 31;
pub const PF_Callback_AREA_SAMPLE16: _bindgen_ty_51 = 32;
pub const PF_Callback_FILL16: _bindgen_ty_51 = 33;
pub const PF_Callback_PREMUL_COLOR16: _bindgen_ty_51 = 34;
pub const PF_Callback_ITERATE16: _bindgen_ty_51 = 35;
pub const PF_Callback_ITERATE_ORIGIN16: _bindgen_ty_51 = 36;
pub const PF_Callback_ITERATE_ORIGIN_NON_CLIP_SRC16: _bindgen_ty_51 = 37;
pub const PF_Callback_ITERATE_GENERIC_NO_MAX_THREADS: _bindgen_ty_51 = 38;
pub const PF_Callback_ITERATE_NO_MAX_THREADS: _bindgen_ty_51 = 39;
pub const PF_Callback_ITERATE_ORIGIN_NO_MAX_THREADS: _bindgen_ty_51 = 40;
pub const PF_Callback_ITERATE_ORIGIN_NON_CLIP_SRC_NO_MAX_THREADS: _bindgen_ty_51 = 41;
pub const PF_Callback_ITERATE16_NO_MAX_THREADS: _bindgen_ty_51 = 42;
pub const PF_Callback_ITERATE_ORIGIN16_NO_MAX_THREADS: _bindgen_ty_51 = 43;
pub const PF_Callback_ITERATE_ORIGIN_NON_CLIP_SRC16_NO_MAX_THREADS: _bindgen_ty_51 = 44;
#[doc = " ---------- Callback Selectors ----------\n\nSome callbacks have different high and low quality versions.\nThe parameter block of function pointers will automatically\nbe filled with the appropriate versions for the current quality\nsetting, but some filters may wish to override this and access\na callback of different quality.  To do this, a get_callback_addr\ncallback is provided which will take a callback selector and a\ndesired quality and return the callback of that quality.  The\nselectors for the various callbacks are listed here.  Also, a\ntypedef for the function pointer that will be returned is given."]
pub type _bindgen_ty_51 = ::std::os::raw::c_int;
pub type PF_CallbackID = A_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_YouMustCastThisToActualFunctionType {
    _unused: [u8; 0],
}
#[doc = "Previous versions of PF_CallbackFunc were defined using varargs in attempt to enforce\nthe effect_ref passed as the first argument to all callbacks. The actual host\nimplementations are generally *not* varargs, and on some platforms the calling\nconventions between normal C ABI and C varargs ABI are not compatible. If your\ncode is trying to call through a PF_CallbackFunc it is unsafe; with this definition\nit will now no longer compile. To fix, cast to the proper API signature before\ncalling. Or better, use the extensive Suite implementations which are explicitly typed"]
pub type PF_CallbackFunc = *mut PF_YouMustCastThisToActualFunctionType;
pub const PF_PlatData_MAIN_WND: _bindgen_ty_52 = 0;
pub const PF_PlatData_EXE_FILE_PATH_DEPRECATED: _bindgen_ty_52 = 1;
pub const PF_PlatData_RES_FILE_PATH_DEPRECATED: _bindgen_ty_52 = 2;
pub const PF_PlatData_RES_REFNUM: _bindgen_ty_52 = 3;
pub const PF_PlatData_RES_DLLINSTANCE: _bindgen_ty_52 = 4;
pub const PF_PlatData_SP_PLUG_REF: _bindgen_ty_52 = 5;
pub const PF_PlatData_BUNDLE_REF: _bindgen_ty_52 = 6;
pub const PF_PlatData_EXE_FILE_PATH_W: _bindgen_ty_52 = 7;
pub const PF_PlatData_RES_FILE_PATH_W: _bindgen_ty_52 = 8;
pub type _bindgen_ty_52 = ::std::os::raw::c_int;
pub type PF_PlatDataID = A_long;
pub const PF_Plane_ALPHA: _bindgen_ty_53 = 1;
pub const PF_Plane_RED: _bindgen_ty_53 = 2;
pub const PF_Plane_GREEN: _bindgen_ty_53 = 4;
pub const PF_Plane_BLUE: _bindgen_ty_53 = 8;
#[doc = " ---------- Image Plane Selectors ----------\n\nThese constants can be used to specify a subset\nof the planes of the 32-bit image."]
pub type _bindgen_ty_53 = ::std::os::raw::c_int;
pub type PF_Plane = A_u_long;
#[doc = " ---------- ANSI Routines Block ----------\n\nWithin the callback routines block there is a block of ANSI\nroutines, so that the filter will not need to link with the\nANSI library.  The following structure describes that block\nand is included in the larger Callback Routines block below.\n\nAll angles are expressed in radians; use PF_RAD_PER_DEGREE\nto convert from degrees to radians, if necessary.  Be aware\nthat angle parameter types use degrees (in fixed point).\n\nSprintf and strcpy are provided to facilitate string usage,\nsuch as printing for names and supervised controls.\n\nNone of these callbacks vary based on the Quality setting."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ANSICallbacks {
    pub atan: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub atan2: ::std::option::Option<unsafe extern "C" fn(y: A_FpLong, x: A_FpLong) -> A_FpLong>,
    pub ceil: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub cos: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub exp: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub fabs: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub floor: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub fmod: ::std::option::Option<unsafe extern "C" fn(x: A_FpLong, y: A_FpLong) -> A_FpLong>,
    pub hypot: ::std::option::Option<unsafe extern "C" fn(x: A_FpLong, y: A_FpLong) -> A_FpLong>,
    pub log: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub log10: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub pow: ::std::option::Option<unsafe extern "C" fn(x: A_FpLong, y: A_FpLong) -> A_FpLong>,
    pub sin: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub sqrt: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub tan: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub sprintf: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut A_char, arg2: *const A_char, ...) -> ::std::os::raw::c_int,
    >,
    pub strcpy: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut A_char, arg2: *const A_char) -> *mut A_char,
    >,
    pub asin: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub acos: ::std::option::Option<unsafe extern "C" fn(arg1: A_FpLong) -> A_FpLong>,
    pub ansi_procs: [A_long; 1usize],
}
#[doc = " ---------- Colorspace Conversion Callbacks\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_ColorCallbacks {
    pub RGBtoHLS: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            rgb: *mut PF_Pixel,
            hls: *mut PF_Fixed,
        ) -> PF_Err,
    >,
    pub HLStoRGB: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            hls: *mut PF_Fixed,
            rgb: *mut PF_Pixel,
        ) -> PF_Err,
    >,
    pub RGBtoYIQ: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            rgb: *mut PF_Pixel,
            yiq: *mut PF_Fixed,
        ) -> PF_Err,
    >,
    pub YIQtoRGB: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            yiq: *mut PF_Fixed,
            rgb: *mut PF_Pixel,
        ) -> PF_Err,
    >,
    pub Luminance: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            rgb: *mut PF_Pixel,
            lum100: *mut A_long,
        ) -> PF_Err,
    >,
    pub Hue: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            rgb: *mut PF_Pixel,
            hue: *mut A_long,
        ) -> PF_Err,
    >,
    pub Lightness: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            rgb: *mut PF_Pixel,
            lightness: *mut A_long,
        ) -> PF_Err,
    >,
    pub Saturation: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            rgb: *mut PF_Pixel,
            saturation: *mut A_long,
        ) -> PF_Err,
    >,
}
pub type PF_BatchSampleFunc = *mut ::std::os::raw::c_void;
pub type PF_BatchSample16Func = *mut ::std::os::raw::c_void;
pub const PF_NewWorldFlag_NONE: _bindgen_ty_54 = 0;
pub const PF_NewWorldFlag_CLEAR_PIXELS: _bindgen_ty_54 = 1;
pub const PF_NewWorldFlag_DEEP_PIXELS: _bindgen_ty_54 = 2;
pub const PF_NewWorldFlag_RESERVED0: _bindgen_ty_54 = 4;
pub const PF_NewWorldFlag_RESERVED1: _bindgen_ty_54 = 8;
pub type _bindgen_ty_54 = ::std::os::raw::c_int;
pub type PF_NewWorldFlags = A_long;
#[doc = "prototypes for PF_ITERATE8 and PF_ITERATE16 pixel functions\n\nthe user of PF_ITERATE provides a refcon; After Effects may distribute iteration\nacross multiple threads, so any data pointed to by refconL should be read-only or\nproperly synchronized\n\ninP is writable only if the world you pass to PF_ITERATE() is PF_WorldFlag_WRITEABLE\n\n"]
pub type PF_IteratePixel8Func = ::std::option::Option<
    unsafe extern "C" fn(
        refconP: *mut ::std::os::raw::c_void,
        xL: A_long,
        yL: A_long,
        inP: *mut PF_Pixel,
        outP: *mut PF_Pixel,
    ) -> PF_Err,
>;
pub type PF_IteratePixel16Func = ::std::option::Option<
    unsafe extern "C" fn(
        refconP: *mut ::std::os::raw::c_void,
        xL: A_long,
        yL: A_long,
        inP: *mut PF_Pixel16,
        outP: *mut PF_Pixel16,
    ) -> PF_Err,
>;
pub type PF_IteratePixelFloatFunc = ::std::option::Option<
    unsafe extern "C" fn(
        refconP: *mut ::std::os::raw::c_void,
        xL: A_long,
        yL: A_long,
        inP: *mut PF_PixelFloat,
        outP: *mut PF_PixelFloat,
    ) -> PF_Err,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PF_UtilCallbacks {
    pub begin_sampling: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            qual: PF_Quality,
            mf: PF_ModeFlags,
            params: *mut PF_SampPB,
        ) -> PF_Err,
    >,
    pub subpixel_sample: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            x: PF_Fixed,
            y: PF_Fixed,
            params: *const PF_SampPB,
            dst_pixel: *mut PF_Pixel,
        ) -> PF_Err,
    >,
    pub area_sample: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            x: PF_Fixed,
            y: PF_Fixed,
            params: *const PF_SampPB,
            dst_pixel: *mut PF_Pixel,
        ) -> PF_Err,
    >,
    pub get_batch_func_is_deprecated: *mut ::std::os::raw::c_void,
    pub end_sampling: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            qual: PF_Quality,
            mf: PF_ModeFlags,
            params: *mut PF_SampPB,
        ) -> PF_Err,
    >,
    pub composite_rect: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            src_rect: *mut PF_Rect,
            src_opacity: A_long,
            source_wld: *mut PF_EffectWorld,
            dest_x: A_long,
            dest_y: A_long,
            field_rdr: PF_Field,
            xfer_mode: PF_XferMode,
            dest_wld: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub blend: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            src1: *const PF_EffectWorld,
            src2: *const PF_EffectWorld,
            ratio: PF_Fixed,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub convolve: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            src: *mut PF_EffectWorld,
            area: *const PF_Rect,
            flags: PF_KernelFlags,
            kernel_size: A_long,
            a_kernel: *mut ::std::os::raw::c_void,
            r_kernel: *mut ::std::os::raw::c_void,
            g_kernel: *mut ::std::os::raw::c_void,
            b_kernel: *mut ::std::os::raw::c_void,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            src: *mut PF_EffectWorld,
            dst: *mut PF_EffectWorld,
            src_r: *mut PF_Rect,
            dst_r: *mut PF_Rect,
        ) -> PF_Err,
    >,
    pub fill: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            color: *const PF_Pixel,
            dst_rect: *const PF_Rect,
            world: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub gaussian_kernel: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            kRadius: A_FpLong,
            flags: PF_KernelFlags,
            multiplier: A_FpLong,
            diameter: *mut A_long,
            kernel: *mut ::std::os::raw::c_void,
        ) -> PF_Err,
    >,
    pub iterate: ::std::option::Option<
        unsafe extern "C" fn(
            in_data: *mut PF_InData,
            progress_base: A_long,
            progress_final: A_long,
            src: *mut PF_EffectWorld,
            area: *const PF_Rect,
            refcon: *mut ::std::os::raw::c_void,
            pix_fn: PF_IteratePixel8Func,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub premultiply: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            forward: A_long,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub premultiply_color: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            src: *mut PF_EffectWorld,
            color: *const PF_Pixel,
            forward: A_long,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub new_world: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            width: A_long,
            height: A_long,
            flags: PF_NewWorldFlags,
            world: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub dispose_world: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, world: *mut PF_EffectWorld) -> PF_Err,
    >,
    pub iterate_origin: ::std::option::Option<
        unsafe extern "C" fn(
            in_data: *mut PF_InData,
            progress_base: A_long,
            progress_final: A_long,
            src: *mut PF_EffectWorld,
            area: *const PF_Rect,
            origin: *const PF_Point,
            refcon: *mut ::std::os::raw::c_void,
            pix_fn: PF_IteratePixel8Func,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub iterate_lut: ::std::option::Option<
        unsafe extern "C" fn(
            in_data: *mut PF_InData,
            progress_base: A_long,
            progress_final: A_long,
            src: *mut PF_EffectWorld,
            area: *const PF_Rect,
            a_lut0: *mut A_u_char,
            r_lut0: *mut A_u_char,
            g_lut0: *mut A_u_char,
            b_lut0: *mut A_u_char,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub transfer_rect: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            quality: PF_Quality,
            m_flags: PF_ModeFlags,
            field: PF_Field,
            src_rec: *const PF_Rect,
            src_world: *const PF_EffectWorld,
            comp_mode: *const PF_CompositeMode,
            mask_world0: *const PF_MaskWorld,
            dest_x: A_long,
            dest_y: A_long,
            dst_world: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub transform_world: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            quality: PF_Quality,
            m_flags: PF_ModeFlags,
            field: PF_Field,
            src_world: *const PF_EffectWorld,
            comp_mode: *const PF_CompositeMode,
            mask_world0: *const PF_MaskWorld,
            matrices: *const PF_FloatMatrix,
            num_matrices: A_long,
            src2dst_matrix: PF_Boolean,
            dest_rect: *const PF_Rect,
            dst_world: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub host_new_handle:
        ::std::option::Option<unsafe extern "C" fn(size: A_u_longlong) -> PF_Handle>,
    pub host_lock_handle: ::std::option::Option<
        unsafe extern "C" fn(pf_handle: PF_Handle) -> *mut ::std::os::raw::c_void,
    >,
    pub host_unlock_handle: ::std::option::Option<unsafe extern "C" fn(pf_handle: PF_Handle)>,
    pub host_dispose_handle: ::std::option::Option<unsafe extern "C" fn(pf_handle: PF_Handle)>,
    pub get_callback_addr: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            quality: PF_Quality,
            mode_flags: PF_ModeFlags,
            which_callback: PF_CallbackID,
            fn_ptr: *mut PF_CallbackFunc,
        ) -> PF_Err,
    >,
    pub app:
        ::std::option::Option<unsafe extern "C" fn(arg1: PF_ProgPtr, arg2: A_long, ...) -> PF_Err>,
    pub ansi: PF_ANSICallbacks,
    pub colorCB: PF_ColorCallbacks,
    pub get_platform_data: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            which: PF_PlatDataID,
            data: *mut ::std::os::raw::c_void,
        ) -> PF_Err,
    >,
    pub host_get_handle_size:
        ::std::option::Option<unsafe extern "C" fn(pf_handle: PF_Handle) -> A_u_longlong>,
    pub iterate_origin_non_clip_src: ::std::option::Option<
        unsafe extern "C" fn(
            in_data: *mut PF_InData,
            progress_base: A_long,
            progress_final: A_long,
            src: *mut PF_EffectWorld,
            area: *const PF_Rect,
            origin: *const PF_Point,
            refcon: *mut ::std::os::raw::c_void,
            pix_fn: PF_IteratePixel8Func,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub iterate_generic: ::std::option::Option<
        unsafe extern "C" fn(
            iterationsL: A_long,
            refconPV: *mut ::std::os::raw::c_void,
            fn_func: ::std::option::Option<
                unsafe extern "C" fn(
                    refconPV: *mut ::std::os::raw::c_void,
                    thread_indexL: A_long,
                    i: A_long,
                    iterationsL: A_long,
                ) -> PF_Err,
            >,
        ) -> PF_Err,
    >,
    pub host_resize_handle: ::std::option::Option<
        unsafe extern "C" fn(new_sizeL: A_u_longlong, handlePH: *mut PF_Handle) -> PF_Err,
    >,
    pub subpixel_sample16: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            x: PF_Fixed,
            y: PF_Fixed,
            params: *const PF_SampPB,
            dst_pixel: *mut PF_Pixel16,
        ) -> PF_Err,
    >,
    pub area_sample16: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            x: PF_Fixed,
            y: PF_Fixed,
            params: *const PF_SampPB,
            dst_pixel: *mut PF_Pixel16,
        ) -> PF_Err,
    >,
    pub fill16: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            color: *const PF_Pixel16,
            dst_rect: *const PF_Rect,
            world: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub premultiply_color16: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            src: *mut PF_EffectWorld,
            color: *const PF_Pixel16,
            forward: A_long,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub iterate16: ::std::option::Option<
        unsafe extern "C" fn(
            in_data: *mut PF_InData,
            progress_base: A_long,
            progress_final: A_long,
            src: *mut PF_EffectWorld,
            area: *const PF_Rect,
            refcon: *mut ::std::os::raw::c_void,
            pix_fn: PF_IteratePixel16Func,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub iterate_origin16: ::std::option::Option<
        unsafe extern "C" fn(
            in_data: *mut PF_InData,
            progress_base: A_long,
            progress_final: A_long,
            src: *mut PF_EffectWorld,
            area: *const PF_Rect,
            origin: *const PF_Point,
            refcon: *mut ::std::os::raw::c_void,
            pix_fn: PF_IteratePixel16Func,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub iterate_origin_non_clip_src16: ::std::option::Option<
        unsafe extern "C" fn(
            in_data: *mut PF_InData,
            progress_base: A_long,
            progress_final: A_long,
            src: *mut PF_EffectWorld,
            area: *const PF_Rect,
            origin: *const PF_Point,
            refcon: *mut ::std::os::raw::c_void,
            pix_fn: PF_IteratePixel16Func,
            dst: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub get_pixel_data8: ::std::option::Option<
        unsafe extern "C" fn(
            worldP: *mut PF_EffectWorld,
            pixelsP0: PF_PixelPtr,
            pixPP: *mut *mut PF_Pixel8,
        ) -> PF_Err,
    >,
    pub get_pixel_data16: ::std::option::Option<
        unsafe extern "C" fn(
            worldP: *mut PF_EffectWorld,
            pixelsP0: PF_PixelPtr,
            pixPP: *mut *mut PF_Pixel16,
        ) -> PF_Err,
    >,
    pub reserved: [A_long; 1usize],
}
pub type PF_UtilCallbacks = _PF_UtilCallbacks;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_CacheOnLoadSuite1 {
    pub PF_SetNoCacheOnLoad: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            effectAvailable: ::std::os::raw::c_long,
        ) -> PF_Err,
    >,
}
pub const PF_TimeDisplay_24: _bindgen_ty_55 = 1;
pub const PF_TimeDisplay_25: _bindgen_ty_55 = 2;
pub const PF_TimeDisplay_30Drop: _bindgen_ty_55 = 3;
pub const PF_TimeDisplay_30NonDrop: _bindgen_ty_55 = 4;
pub const PF_TimeDisplay_50: _bindgen_ty_55 = 5;
pub const PF_TimeDisplay_60Drop: _bindgen_ty_55 = 6;
pub const PF_TimeDisplay_60NonDrop: _bindgen_ty_55 = 7;
pub const PF_TimeDisplay_NonStandard: _bindgen_ty_55 = 8;
pub const PF_TimeDisplay_Invalid: _bindgen_ty_55 = 9;
pub type _bindgen_ty_55 = ::std::os::raw::c_int;
pub type PF_TimeDisplay = csSDK_uint32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_PixelFormatSuite1 {
    pub AddSupportedPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, pixelFormat: PrPixelFormat) -> PF_Err,
    >,
    pub ClearSupportedPixelFormats:
        ::std::option::Option<unsafe extern "C" fn(effect_ref: PF_ProgPtr) -> PF_Err>,
    pub NewWorldOfPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            width: A_u_long,
            height: A_u_long,
            flags: PF_NewWorldFlags,
            pixelFormat: PrPixelFormat,
            world: *mut PF_EffectWorld,
        ) -> PF_Err,
    >,
    pub DisposeWorld: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, world: *mut PF_EffectWorld) -> PF_Err,
    >,
    pub GetPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            inWorld: *mut PF_EffectWorld,
            pixelFormat: *mut PrPixelFormat,
        ) -> PF_Err,
    >,
    pub GetBlackForPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            pixelFormat: PrPixelFormat,
            pixelData: *mut ::std::os::raw::c_void,
        ) -> PF_Err,
    >,
    pub GetWhiteForPixelFormat: ::std::option::Option<
        unsafe extern "C" fn(
            pixelFormat: PrPixelFormat,
            pixelData: *mut ::std::os::raw::c_void,
        ) -> PF_Err,
    >,
    pub ConvertColorToPixelFormattedData: ::std::option::Option<
        unsafe extern "C" fn(
            pixelFormat: PrPixelFormat,
            alpha: f32,
            red: f32,
            green: f32,
            blue: f32,
            pixelData: *mut ::std::os::raw::c_void,
        ) -> PF_Err,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_BackgroundFrameSuite1 {
    pub AddSupportedBackgroundTransferMode: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            supportedTransferMode: PF_TransferMode,
            supportedPixelFormat: PrPixelFormat,
        ) -> PF_Err,
    >,
    pub GetBackgroundFrame: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            backgroundFrame: *mut *mut PF_LayerDef,
            backgroundTransferMode: *mut PF_TransferMode,
        ) -> PF_Err,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_UtilitySuite4 {
    pub GetFilterInstanceID: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outFilterInstanceID: *mut A_long) -> PF_Err,
    >,
    pub GetMediaTimecode: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            outCurrentFrame: *mut A_long,
            outTimeDisplay: *mut PF_TimeDisplay,
        ) -> PF_Err,
    >,
    pub GetClipSpeed: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, speed: *mut f64) -> PF_Err,
    >,
    pub GetClipDuration: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetClipStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetUnscaledClipDuration: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetUnscaledClipStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetTrackItemStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetMediaFieldType: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outFieldType: *mut prFieldType) -> PF_Err,
    >,
    pub GetMediaFrameRate: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTicksPerFrame: *mut PrTime) -> PF_Err,
    >,
    pub GetContainingTimelineID: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTimelineID: *mut PrTimelineID) -> PF_Err,
    >,
    pub GetClipName: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outSDKString: *mut PrSDKString) -> PF_Err,
    >,
    pub EffectWantsCheckedOutFramesToMatchRenderPixelFormat:
        ::std::option::Option<unsafe extern "C" fn(effect_ref: PF_ProgPtr) -> PF_Err>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_UtilitySuite {
    pub GetFilterInstanceID: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outFilterInstanceID: *mut A_long) -> PF_Err,
    >,
    pub GetMediaTimecode: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            outCurrentFrame: *mut A_long,
            outTimeDisplay: *mut PF_TimeDisplay,
        ) -> PF_Err,
    >,
    pub GetClipSpeed: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, speed: *mut f64) -> PF_Err,
    >,
    pub GetClipDuration: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetClipStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetUnscaledClipDuration: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetUnscaledClipStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetTrackItemStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetMediaFieldType: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outFieldType: *mut prFieldType) -> PF_Err,
    >,
    pub GetMediaFrameRate: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTicksPerFrame: *mut PrTime) -> PF_Err,
    >,
    pub GetContainingTimelineID: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTimelineID: *mut PrTimelineID) -> PF_Err,
    >,
    pub GetClipName: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inGetMasterClipName: A_Boolean,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub EffectWantsCheckedOutFramesToMatchRenderPixelFormat:
        ::std::option::Option<unsafe extern "C" fn(effect_ref: PF_ProgPtr) -> PF_Err>,
    pub EffectDependsOnClipName: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, inDependsOnClipName: A_Boolean) -> PF_Err,
    >,
    pub SetEffectInstanceName: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, inSDKString: *const PrSDKString) -> PF_Err,
    >,
    pub GetFileName: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outSDKString: *mut PrSDKString) -> PF_Err,
    >,
    pub GetOriginalClipFrameRate: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTicksPerFrame: *mut PrTime) -> PF_Err,
    >,
    pub GetSourceTrackMediaTimecode: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inApplyTransform: bool,
            inAddStartTimeOffset: bool,
            outCurrentFrame: *mut A_long,
        ) -> PF_Err,
    >,
    pub GetSourceTrackClipName: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inGetMasterClipName: A_Boolean,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSourceTrackFileName: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub EffectDependsOnClipName2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inDependsOnClipName: A_Boolean,
            inLayerParamIndex: csSDK_uint32,
        ) -> PF_Err,
    >,
    pub GetMediaTimecode2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inApplyTrim: bool,
            outCurrentFrame: *mut A_long,
            outTimeDisplay: *mut PF_TimeDisplay,
        ) -> PF_Err,
    >,
    pub GetSourceTrackMediaTimecode2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inApplyTransform: bool,
            inAddStartTimeOffset: bool,
            inSequenceTime: PrTime,
            outCurrentFrame: *mut A_long,
        ) -> PF_Err,
    >,
    pub GetSourceTrackClipName2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inGetMasterClipName: A_Boolean,
            outSDKString: *mut PrSDKString,
            inSequenceTime: PrTime,
        ) -> PF_Err,
    >,
    pub GetSourceTrackFileName2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            outSDKString: *mut PrSDKString,
            inSequenceTime: PrTime,
        ) -> PF_Err,
    >,
    pub GetCommentString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetLogNoteString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetCameraRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetClientMetadataString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetDailyRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetDescriptionString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetLabRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSceneString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetShotString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetTapeNameString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetVideoCodecString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetGoodMetadataString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSoundRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSequenceTime: ::std::option::Option<
        unsafe extern "C" fn(inEffectRef: PF_ProgPtr, outSequenceTime: *mut PrTime) -> PF_Err,
    >,
    pub GetSoundTimecode: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outCurrentFrame: *mut A_long,
        ) -> PF_Err,
    >,
    pub GetOriginalClipFrameRateForSourceTrack: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            outTicksPerFrame: *mut PrTime,
        ) -> PF_Err,
    >,
    pub GetMediaFrameRateForSourceTrack: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outTicksPerFrame: *mut PrTime,
        ) -> PF_Err,
    >,
    pub GetSourceTrackMediaActualStartTime: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inSequenceTime: PrTime,
            outClipActualStartTime: *mut PrTime,
        ) -> PF_Err,
    >,
    pub IsSourceTrackMediaTrimmed: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inSequenceTime: PrTime,
            outTrimApplied: *mut bool,
        ) -> PF_Err,
    >,
    pub IsMediaTrimmed: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSequenceTime: PrTime,
            outTrimApplied: *mut bool,
        ) -> PF_Err,
    >,
    pub IsTrackEmpty: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inSequenceTime: PrTime,
            outIsTrackEmpty: *mut bool,
        ) -> PF_Err,
    >,
    pub IsTrackItemEffectAppliedToSynthetic: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            outIsTrackItemEffectAppliedToSynthetic: *mut bool,
        ) -> PF_Err,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_UtilitySuite10 {
    pub GetFilterInstanceID: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outFilterInstanceID: *mut A_long) -> PF_Err,
    >,
    pub GetMediaTimecode: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            outCurrentFrame: *mut A_long,
            outTimeDisplay: *mut PF_TimeDisplay,
        ) -> PF_Err,
    >,
    pub GetClipSpeed: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, speed: *mut f64) -> PF_Err,
    >,
    pub GetClipDuration: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetClipStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetUnscaledClipDuration: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetUnscaledClipStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetTrackItemStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetMediaFieldType: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outFieldType: *mut prFieldType) -> PF_Err,
    >,
    pub GetMediaFrameRate: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTicksPerFrame: *mut PrTime) -> PF_Err,
    >,
    pub GetContainingTimelineID: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTimelineID: *mut PrTimelineID) -> PF_Err,
    >,
    pub GetClipName: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inGetMasterClipName: A_Boolean,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub EffectWantsCheckedOutFramesToMatchRenderPixelFormat:
        ::std::option::Option<unsafe extern "C" fn(effect_ref: PF_ProgPtr) -> PF_Err>,
    pub EffectDependsOnClipName: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, inDependsOnClipName: A_Boolean) -> PF_Err,
    >,
    pub SetEffectInstanceName: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, inSDKString: *const PrSDKString) -> PF_Err,
    >,
    pub GetFileName: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outSDKString: *mut PrSDKString) -> PF_Err,
    >,
    pub GetOriginalClipFrameRate: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTicksPerFrame: *mut PrTime) -> PF_Err,
    >,
    pub GetSourceTrackMediaTimecode: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inApplyTransform: bool,
            inAddStartTimeOffset: bool,
            outCurrentFrame: *mut A_long,
        ) -> PF_Err,
    >,
    pub GetSourceTrackClipName: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inGetMasterClipName: A_Boolean,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSourceTrackFileName: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub EffectDependsOnClipName2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inDependsOnClipName: A_Boolean,
            inLayerParamIndex: csSDK_uint32,
        ) -> PF_Err,
    >,
    pub GetMediaTimecode2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inApplyTrim: bool,
            outCurrentFrame: *mut A_long,
            outTimeDisplay: *mut PF_TimeDisplay,
        ) -> PF_Err,
    >,
    pub GetSourceTrackMediaTimecode2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inApplyTransform: bool,
            inAddStartTimeOffset: bool,
            inSequenceTime: PrTime,
            outCurrentFrame: *mut A_long,
        ) -> PF_Err,
    >,
    pub GetSourceTrackClipName2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inGetMasterClipName: A_Boolean,
            outSDKString: *mut PrSDKString,
            inSequenceTime: PrTime,
        ) -> PF_Err,
    >,
    pub GetSourceTrackFileName2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            outSDKString: *mut PrSDKString,
            inSequenceTime: PrTime,
        ) -> PF_Err,
    >,
    pub GetCommentString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetLogNoteString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetCameraRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetClientMetadataString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetDailyRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetDescriptionString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetLabRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSceneString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetShotString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetTapeNameString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetVideoCodecString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetGoodMetadataString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSoundRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSequenceTime: ::std::option::Option<
        unsafe extern "C" fn(inEffectRef: PF_ProgPtr, outSequenceTime: *mut PrTime) -> PF_Err,
    >,
    pub GetSoundTimecode: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outCurrentFrame: *mut A_long,
        ) -> PF_Err,
    >,
    pub GetOriginalClipFrameRateForSourceTrack: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            outTicksPerFrame: *mut PrTime,
        ) -> PF_Err,
    >,
    pub GetMediaFrameRateForSourceTrack: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outTicksPerFrame: *mut PrTime,
        ) -> PF_Err,
    >,
    pub GetSourceTrackMediaActualStartTime: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inSequenceTime: PrTime,
            outClipActualStartTime: *mut PrTime,
        ) -> PF_Err,
    >,
    pub IsSourceTrackMediaTrimmed: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inSequenceTime: PrTime,
            outTrimApplied: *mut bool,
        ) -> PF_Err,
    >,
    pub IsMediaTrimmed: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSequenceTime: PrTime,
            outTrimApplied: *mut bool,
        ) -> PF_Err,
    >,
    pub IsTrackEmpty: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inSequenceTime: PrTime,
            outIsTrackEmpty: *mut bool,
        ) -> PF_Err,
    >,
    pub IsTrackItemEffectAppliedToSynthetic: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            outIsTrackItemEffectAppliedToSynthetic: *mut bool,
        ) -> PF_Err,
    >,
    pub GetSourceTrackCurrentMediaTimeInfo: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inUseSoundTimecodeAsStartTime: bool,
            inSequenceTime: PrTime,
            outCurrentMediaTime: *mut PrTime,
            outMediaTicksPerFrame: *mut PrTime,
            outMediaTimeDisplay: *mut PF_TimeDisplay,
        ) -> PF_Err,
    >,
    pub GetSequenceZeroPoint: ::std::option::Option<
        unsafe extern "C" fn(inEffectRef: PF_ProgPtr, outZeroPointTime: *mut PrTime) -> PF_Err,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_UtilitySuite11 {
    pub GetFilterInstanceID: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outFilterInstanceID: *mut A_long) -> PF_Err,
    >,
    pub GetMediaTimecode: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            outCurrentFrame: *mut A_long,
            outTimeDisplay: *mut PF_TimeDisplay,
        ) -> PF_Err,
    >,
    pub GetClipSpeed: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, speed: *mut f64) -> PF_Err,
    >,
    pub GetClipDuration: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetClipStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetUnscaledClipDuration: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetUnscaledClipStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetTrackItemStart: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, frameDuration: *mut A_long) -> PF_Err,
    >,
    pub GetMediaFieldType: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outFieldType: *mut prFieldType) -> PF_Err,
    >,
    pub GetMediaFrameRate: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTicksPerFrame: *mut PrTime) -> PF_Err,
    >,
    pub GetContainingTimelineID: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTimelineID: *mut PrTimelineID) -> PF_Err,
    >,
    pub GetClipName: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inGetMasterClipName: A_Boolean,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub EffectWantsCheckedOutFramesToMatchRenderPixelFormat:
        ::std::option::Option<unsafe extern "C" fn(effect_ref: PF_ProgPtr) -> PF_Err>,
    pub EffectDependsOnClipName: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, inDependsOnClipName: A_Boolean) -> PF_Err,
    >,
    pub SetEffectInstanceName: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, inSDKString: *const PrSDKString) -> PF_Err,
    >,
    pub GetFileName: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outSDKString: *mut PrSDKString) -> PF_Err,
    >,
    pub GetOriginalClipFrameRate: ::std::option::Option<
        unsafe extern "C" fn(effect_ref: PF_ProgPtr, outTicksPerFrame: *mut PrTime) -> PF_Err,
    >,
    pub GetSourceTrackMediaTimecode: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inApplyTransform: bool,
            inAddStartTimeOffset: bool,
            outCurrentFrame: *mut A_long,
        ) -> PF_Err,
    >,
    pub GetSourceTrackClipName: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inGetMasterClipName: A_Boolean,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSourceTrackFileName: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub EffectDependsOnClipName2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inDependsOnClipName: A_Boolean,
            inLayerParamIndex: csSDK_uint32,
        ) -> PF_Err,
    >,
    pub GetMediaTimecode2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inApplyTrim: bool,
            outCurrentFrame: *mut A_long,
            outTimeDisplay: *mut PF_TimeDisplay,
        ) -> PF_Err,
    >,
    pub GetSourceTrackMediaTimecode2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inApplyTransform: bool,
            inAddStartTimeOffset: bool,
            inSequenceTime: PrTime,
            outCurrentFrame: *mut A_long,
        ) -> PF_Err,
    >,
    pub GetSourceTrackClipName2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inGetMasterClipName: A_Boolean,
            outSDKString: *mut PrSDKString,
            inSequenceTime: PrTime,
        ) -> PF_Err,
    >,
    pub GetSourceTrackFileName2: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            outSDKString: *mut PrSDKString,
            inSequenceTime: PrTime,
        ) -> PF_Err,
    >,
    pub GetCommentString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetLogNoteString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetCameraRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetClientMetadataString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetDailyRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetDescriptionString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetLabRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSceneString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetShotString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetTapeNameString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetVideoCodecString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetGoodMetadataString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSoundRollString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
    pub GetSequenceTime: ::std::option::Option<
        unsafe extern "C" fn(inEffectRef: PF_ProgPtr, outSequenceTime: *mut PrTime) -> PF_Err,
    >,
    pub GetSoundTimecode: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outCurrentFrame: *mut A_long,
        ) -> PF_Err,
    >,
    pub GetOriginalClipFrameRateForSourceTrack: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            outTicksPerFrame: *mut PrTime,
        ) -> PF_Err,
    >,
    pub GetMediaFrameRateForSourceTrack: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outTicksPerFrame: *mut PrTime,
        ) -> PF_Err,
    >,
    pub GetSourceTrackMediaActualStartTime: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inSequenceTime: PrTime,
            outClipActualStartTime: *mut PrTime,
        ) -> PF_Err,
    >,
    pub IsSourceTrackMediaTrimmed: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inSequenceTime: PrTime,
            outTrimApplied: *mut bool,
        ) -> PF_Err,
    >,
    pub IsMediaTrimmed: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSequenceTime: PrTime,
            outTrimApplied: *mut bool,
        ) -> PF_Err,
    >,
    pub IsTrackEmpty: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inSequenceTime: PrTime,
            outIsTrackEmpty: *mut bool,
        ) -> PF_Err,
    >,
    pub IsTrackItemEffectAppliedToSynthetic: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            outIsTrackItemEffectAppliedToSynthetic: *mut bool,
        ) -> PF_Err,
    >,
    pub GetSourceTrackCurrentMediaTimeInfo: ::std::option::Option<
        unsafe extern "C" fn(
            effect_ref: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inUseSoundTimecodeAsStartTime: bool,
            inSequenceTime: PrTime,
            outCurrentMediaTime: *mut PrTime,
            outMediaTicksPerFrame: *mut PrTime,
            outMediaTimeDisplay: *mut PF_TimeDisplay,
        ) -> PF_Err,
    >,
    pub GetSequenceZeroPoint: ::std::option::Option<
        unsafe extern "C" fn(inEffectRef: PF_ProgPtr, outZeroPointTime: *mut PrTime) -> PF_Err,
    >,
    pub GetSourceTrackCurrentClipDuration: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inLayerParamIndex: csSDK_uint32,
            inSequenceTime: PrTime,
            outClipDuration: *mut PrTime,
        ) -> PF_Err,
    >,
    pub GetSequenceDuration: ::std::option::Option<
        unsafe extern "C" fn(inEffectRef: PF_ProgPtr, outSequenceDuration: *mut PrTime) -> PF_Err,
    >,
    pub GetVideoResolutionString: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inSourceTrack: i32,
            inSequenceTime: PrTime,
            outSDKString: *mut PrSDKString,
        ) -> PF_Err,
    >,
}
pub type PF_UtilitySuiteVersion1 = PF_UtilitySuite;
pub type PF_UtilitySuite2 = PF_UtilitySuite;
pub type PF_UtilitySuite3 = PF_UtilitySuite;
pub type PF_UtilitySuite5 = PF_UtilitySuite;
pub type PF_UtilitySuite6 = PF_UtilitySuite;
pub type PF_UtilitySuite7 = PF_UtilitySuite;
pub type PF_UtilitySuite8 = PF_UtilitySuite;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_SourceSettingsSuite {
    pub PerformSourceSettingsCommand: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            ioCommandStruct: *mut ::std::os::raw::c_void,
            inDataSize: csSDK_uint32,
        ) -> PF_Err,
    >,
    pub SetIsSourceSettingsEffect: ::std::option::Option<
        unsafe extern "C" fn(
            inEffectRef: PF_ProgPtr,
            inIsSourceSettingsEffect: A_Boolean,
        ) -> PF_Err,
    >,
}
pub type PF_SourceSettingsSuite2 = PF_SourceSettingsSuite;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PF_TransitionSuite {
    #[doc = "\tRegister an effect as a transition using the passed in\n\tinput layer as the outgoing clip. When registered the effect\n\twill be available to be dragged directly onto clip ends rather\n\tthan only applied to layers."]
    pub RegisterTransitionInputParam: ::std::option::Option<
        unsafe extern "C" fn(inEffectRef: PF_ProgPtr, inIndex: PF_ParamIndex) -> PF_Err,
    >,
    #[doc = "\tRegister a PF_ADD_FLOAT_SLIDER parameter to receive\n\tchanges to the start of the transition region through the\n\tPF_Cmd_USER_CHANGED_PARAM command."]
    pub RegisterTransitionStartParam: ::std::option::Option<
        unsafe extern "C" fn(inEffectRef: PF_ProgPtr, inIndex: PF_ParamIndex) -> PF_Err,
    >,
    #[doc = "\tRegister a PF_ADD_FLOAT_SLIDER parameter to receive\n\tchanges to the end of the transition region through the\n\tPF_Cmd_USER_CHANGED_PARAM command."]
    pub RegisterTransitionEndParam: ::std::option::Option<
        unsafe extern "C" fn(inEffectRef: PF_ProgPtr, inIndex: PF_ParamIndex) -> PF_Err,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OpaqueEffectDataType {
    _unused: [u8; 0],
}
#[doc = "\tThis suite provides effects a means to share unflattened sequence data between its instances.\n  The data is opaque to the host and effects are responsible for maintaining thread safety\n  of the shared data.  The host provides ref counting that the effect can use to manage\n  the lifetime of the shared data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrSDKOpaqueEffectDataSuite {
    #[doc = "\tAcquire pointer to opaque effect data.  This is reference counted meaning that\n  AcquireOpaqueEffectData and ReleaseOpaqueEffectData should always be called in pairs.\n  If no opaque effect was registered for the given effect_ref AcquireOpaqueEffectData\n  will return 0 and the reference count remains 0."]
    pub AcquireOpaqueEffectData: ::std::option::Option<
        unsafe extern "C" fn(
            instanceID: csSDK_int32,
            outOpaqueEffectDataPP: *mut *mut OpaqueEffectDataType,
        ) -> PF_Err,
    >,
    #[doc = "Register opaque effect data.  If multiple threads invoke RegisterOpaqueEffectData\n  only one will be successful.  The ioOpaqueEffectDataPP of the successful thread\n  will be returned to all callers.  Calling threads are always responsible for\n  managing the data they register.  This is the case whether or not threads are\n  successful registering their data.\n  Similarly, RegisterOpaqueEffectData always increments the internal reference count.\n\n//\n// Sample code showing how to use RegisterOpaqueEffectData.\n// Note: code is simplified (not exception-safe, etc.)\n//\n\n//\n// Try to acquire first, in case another thread registered the opaque effect data earlier\n//\nOpaqueEffectDataType * pData = 0;\nPF_Err err = opaqueEffectDataSuite->AcquireOpaqueEffectData(instanceID, &pData);\nassert(err == PF_Err_NONE);\n\n//\n// If acquire did not return a valid pointer, create a new object and register it\n// otherwise we are done\n//\nif (pData == 0)\n{\nOpaqueEffectDataType * pNewData(new OpaqueEffectDataType());\npData = pNewData;\nerr = opaqueEffectDataSuite->RegisterOpaqueEffectData(instanceID, &pData);\nassert(err == PF_Err_NONE);\n\n// now we check if this thread actually succeeded registering\n// if the returned pData is unchanged it means that it was successful\nif (pData != pNewData)\n{\ndelete pNewData;\n}\n}\n\n// pData now points to the right OpaqueEffectDataType object and we can start using it\n...\n\n\n\n"]
    pub RegisterOpaqueEffectData: ::std::option::Option<
        unsafe extern "C" fn(
            instanceID: csSDK_int32,
            ioOpaqueEffectDataPP: *mut *mut OpaqueEffectDataType,
        ) -> PF_Err,
    >,
    #[doc = "\tRelease opaque effect data.  This decrements the internal reference count.\n  If the internal reference count goes to 0 outDisposeOpaqueEffectDataPP is set\n  to the managed data that should be deleted, otherwise it is set to NULL.\n  If the internal reference count goes to 0 any calls made to AcquireOpaqueEffectData\n  will return 0 until new opaque effect data is registered via RegisterOpaqueEffectData."]
    pub ReleaseOpaqueEffectData: ::std::option::Option<
        unsafe extern "C" fn(
            instanceID: csSDK_int32,
            outDisposeOpaqueEffectDataPP: *mut *mut OpaqueEffectDataType,
        ) -> PF_Err,
    >,
}
pub const PrPixelFormatGpu_GPU_BGRA_4444_32f: PrPixelFormatGpu = 1094992704;
pub const PrPixelFormatGpu_GPU_BGRA_4444_16f: PrPixelFormatGpu = 1631863616;
pub type PrPixelFormatGpu = ::std::os::raw::c_int;
